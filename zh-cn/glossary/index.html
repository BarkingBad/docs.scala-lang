<!DOCTYPE html>

<html>

  <head>
    <title>
      Glossary | 
      
      Scala Documentation
    </title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta property="og:site_name" content="Scala Documentation"/>
    <meta property="og:type" content="article"/>
    <meta property="og:url" content="http://localhost:4000/zh-cn/glossary/index.html"/>
    <meta property="og:image" content="http://localhost:4000/resources/img/scala-spiral-3d-2-toned-down.png"/>
    <meta property="og:title" content="Glossary"/>
    

    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@scala_lang"/>
    <meta name="twitter:creator" content="@scala_lang"/>
    <meta name="twitter:title" content="Glossary"/>
    

    <link rel="icon" type="image/png" href="/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/resources/favicon-16x16.png">
    <link rel="manifest" href="/resources/site.webmanifest">
    <link rel="mask-icon" href="/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="/resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>





<div class="navigation-fade-screen"></div>



<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="/resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="/" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>



<header id="doc-header">

  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      
      <div class="navigation-bdand">
      <a href="/zh-cn">
        <img src="/resources/img/documentation-logo@2x.png" alt="docs">
      </a>
      <span class="doc-language-version">
        — Scala  2 
      </span>
      </div>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              
              
              <a href="#" id="api" >API</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    
                    
                    <a href="https://www.scala-lang.org/api/current/">Current</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="/api/all.html">All Versions</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              
              
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    
                    
                    <a href="/getting-started/index.html">Getting Started</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="/zh-cn/tour/tour-of-scala.html">Tour of Scala</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="/zh-cn/overviews/scala-book/introduction.html">Scala Book</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="/zh-cn/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="/learn.html">Online Resources</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              
              
              <a href="#" id="reference" >Reference</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    
                    
                    <a href="/zh-cn/overviews/index.html">Guides & Overviews</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="/books.html">Books</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="/tutorials/FAQ/index.html">Scala FAQ</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="http://scala-lang.org/files/archive/spec/2.13/">Language Spec</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              
              
              <a href="/style/index.html" id="style guide" >Style Guide</a>
                
            </li>
        
            <li class="navigation-menu-item">
              
              
              <a href="/zh-cn/cheatsheets/index.html" id="cheatsheet" >Cheatsheet</a>
                
            </li>
        
            <li class="navigation-menu-item">
              
              
              <a href="/zh-cn/glossary/index.html" id="glossary" class="active">Glossary</a>
                
            </li>
        
            <li class="navigation-menu-item">
              
              
              <a href="/sips/index.html" id="sips" >SIPs</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="api" style="display: none;">
            
              <li>
                <a href="https://www.scala-lang.org/api/current/">Current</a>
              </li>
            
              <li>
                <a href="/api/all.html">All Versions</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="/getting-started/index.html">Getting Started</a>
              </li>
            
              <li>
                <a href="/tour/tour-of-scala.html">Tour of Scala</a>
              </li>
            
              <li>
                <a href="/overviews/scala-book/introduction.html">Scala Book</a>
              </li>
            
              <li>
                <a href="/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
              </li>
            
              <li>
                <a href="/learn.html">Online Resources</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="reference" style="display: none;">
            
              <li>
                <a href="/overviews/index.html">Guides & Overviews</a>
              </li>
            
              <li>
                <a href="/books.html">Books</a>
              </li>
            
              <li>
                <a href="/tutorials/FAQ/index.html">Scala FAQ</a>
              </li>
            
              <li>
                <a href="http://scala-lang.org/files/archive/spec/2.13/">Language Spec</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="/style/index.html">Style Guide</a></li>
          
        
          
            <li><a href="/cheatsheets/index.html">Cheatsheet</a></li>
          
        
          
            <li><a href="/glossary/index.html">Glossary</a></li>
          
        
          
            <li><a href="/sips/index.html">SIPs</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">
  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        

        <div class="titles">
          
            <div class="supertitle">&nbsp;</div>
          
          <h1>Glossary</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation glossary">
			<div class="inner-box">
				<div class="toc-context">
					<h5>该术语表摘自Scala权威书籍《<a href="https://www.artima.com/shop/programming_in_scala">Programming in Scala</a>》</h5>

<div class="filterbar">
  <div class="icon-search">
    <i class="fa fa-search"></i>
  </div>
  <input type="text" id="filter-glossary-terms" placeholder="Look up a term..." />
  <!-- <input class="field" id="filter" type="text" /> -->
  <span id="filter-count">&nbsp;</span>
</div>

<ul>
  <li>
    <h4 id="代数数据类型algebraic-data-type">代数数据类型（algebraic data type）</h4>
    <p>通过提供若干个带有独立构造器的备选项来定义的类型。它一般通过模式匹配的方式来结构类型，在规约语言和函数式编程语言中常见到这个概念。Scala可通过案例类来模拟代数数据类型。</p>
  </li>
  <li>
    <h4 id="备选项alternative">备选项（alternative）</h4>
    <p>match表达式的一个分支，形如 “<code class="language-plaintext highlighter-rouge">case</code> <em>pattern</em> =&gt; <em>expression</em>”。备选项的别名是 <em>案例</em>（<em>case</em>）。</p>
  </li>
  <li>
    <h4 id="注解annotation">注解（annotation）</h4>
    <p>注解一般出现在源码中，并附加到语法的某个部分。注解对于计算机来说都是可处理的，所以可以用来有效的增加Scala扩展。</p>
  </li>
  <li>
    <h4 id="匿名类anonymous-class">匿名类（anonymous class）</h4>
    <p>匿名类是由Scala编译器根据一种new表达式生成的合成子类，这种new表达式由类名或特质名后面紧跟一对花括号组成。花括号内包含了匿名子类的构造体，可为空，不过一旦跟在new后面名称指向的特质或类包含了抽象成员，则这些抽象成员就必须在其匿名子类的构造体内具化，即在花括号内要实现这些成员。</p>
  </li>
  <li>
    <h4 id="匿名函数anonymous-function">匿名函数（anonymous function）</h4>
    <p><a href="#函数字面量function-literal">函数字面量</a>的另一种叫法。</p>
  </li>
  <li>
    <h4 id="应用apply">应用（apply）</h4>
    <p>方法、函数或闭包应用于参数，意思是说通过这些实参来调用方法、函数或闭包。</p>
  </li>
  <li>
    <h4 id="实参argument">实参（argument）</h4>
    <p>在函数调用过程中实参被传给函数的各个参数，其中参数就是指向实参的变量，实参则是调用发生时被传入的对象。另外，应用程序都可以获取被传入单例对象的main方法且类型为<code class="language-plaintext highlighter-rouge">Array[String]</code>的实参（来自命令行）。</p>
  </li>
  <li>
    <h4 id="赋值assign">赋值（assign）</h4>
    <p>可把对象赋值给变量，之后，变量就会指向对象。</p>
  </li>
  <li>
    <h4 id="辅助构造器auxiliary-constructor">辅助构造器（auxiliary constructor）</h4>
    <p>在类定义体花括号里面定义的所有附加构造器，其形似名为<code class="language-plaintext highlighter-rouge">this</code>但无结果类型的方法定义。</p>
  </li>
  <li>
    <h4 id="块block">块（block）</h4>
    <p>被花括号围起来的一个或多个表达式和声明。求值块的时候，块内所有表达式和声明会被顺序处理，然后会返回最后一个表达式的值作为其自身的值。块通常被用来作为构造体，诸如函数、<a href="#for表达式for-expression">for表达式</a>、<code class="language-plaintext highlighter-rouge">while</code>循环以及其他任何需要把语句组织到一起的地方，都会用到块。更正式点说，块是一个只其副作用和结果值对外可见的封装构造体。因此，类或对象的花括号是不会形成块的，因其内部定义字段和方法均对外可见。这样的花括号形成的是模板。</p>
  </li>
  <li>
    <h4 id="绑定变量bound-variable">绑定变量（bound variable）</h4>
    <p>表达式的绑定变量是定义和使用都在表达式内部的变量。例如，在函数字面量表达式<code class="language-plaintext highlighter-rouge">(x: Int) =&gt; (x, y)</code>里面，<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>都被用到了，但只有<code class="language-plaintext highlighter-rouge">x</code>被绑定了，因为它在表达式中被定义为一个<code class="language-plaintext highlighter-rouge">Int</code>变量，并且它也是表达式所描述函数的唯一实参。</p>
  </li>
  <li>
    <h4 id="传名参数by-name-parameter">传名参数（by-name parameter）</h4>
    <p>参数类型前面带有<code class="language-plaintext highlighter-rouge">=&gt;</code>的参数，如<code class="language-plaintext highlighter-rouge">(x: =&gt; Int)</code>。传名参数对应的实参求值不在方法被调用前，而是在每次方法通过名称引用到参数的时候。参数若不是传名的，则定是传值的。</p>
  </li>
  <li>
    <h4 id="传值参数by-value-parameter">传值参数（by-value parameter）</h4>
    <p>参数类型前面不带<code class="language-plaintext highlighter-rouge">=&gt;</code>的参数，如<code class="language-plaintext highlighter-rouge">(x: Int)</code>。传值参数对应的实参是在方法调用前被求值的。传值参数是相对传名参数而言的。</p>
  </li>
  <li>
    <h4 id="类class">类（class）</h4>
    <p>通过关键字<code class="language-plaintext highlighter-rouge">class</code>来定义的类，可抽象可具体，且在实例化时可用类型和值对其进行参数化处理。比如<code class="language-plaintext highlighter-rouge">new Array[String](2)</code>，被实例化的类是<code class="language-plaintext highlighter-rouge">Array</code>，产生的值类型为<code class="language-plaintext highlighter-rouge">Array[String]</code>。带有类型参数的类被称为 <em>类型构造器</em> ，也可说成是类型具有类属性，如：类型<code class="language-plaintext highlighter-rouge">Array[String]</code>具有的类属性是<code class="language-plaintext highlighter-rouge">Array</code>。</p>
  </li>
  <li>
    <h4 id="闭包closure">闭包（closure）</h4>
    <p>可以捕获自由变量，或者说”关闭”函数创建时可见变量的函数对象。</p>
  </li>
  <li>
    <h4 id="伴生类companion-class">伴生类（companion class）</h4>
    <p>和定义在相同源文件中的单例对象共享同一个名称的类，这样的类就叫做那个单例对象的伴生类。</p>
  </li>
  <li>
    <h4 id="伴生对象companion-object">伴生对象（companion object）</h4>
    <p>和定义在相同源文件中的类共享同一个名称的单例对象。伴生对象和伴生类具备访问彼此私有成员的能力。另外，类不管被用在何处，其伴生对象中定义的任何隐式转换都在其作用域内。</p>
  </li>
  <li>
    <h4 id="逆变contravariant">逆变（contravariant）</h4>
    <p>逆变标注可应用于类或特质的类型参数上，把减号（-）置于类型参数前即可。标注为逆变后类或特质的子类型将逆向（向相反的方向）协变于类型标注的参数。比如，<code class="language-plaintext highlighter-rouge">Function1</code>的第一个类型参数就是逆变的，所以<code class="language-plaintext highlighter-rouge">Function1[Any, Any]</code>是<code class="language-plaintext highlighter-rouge">Function1[String, Any]</code>的子类。</p>
  </li>
  <li>
    <h4 id="协变covariant">协变（covariant）</h4>
    <p>协变标注可应用于类或特质的类型参数上，把加号（+）置于类型参数前即可。标注为协变后类或特质的子类型将正向（向相同的方向）协变于类型标注的参数。比如，<code class="language-plaintext highlighter-rouge">List</code>的类型参数是协变的，所以<code class="language-plaintext highlighter-rouge">List[String]</code>是<code class="language-plaintext highlighter-rouge">List[Any]</code>的子类。</p>
  </li>
  <li>
    <h4 id="柯里化currying">柯里化（currying）</h4>
    <p>把函数写成多个参数列表的方式。例如：<code class="language-plaintext highlighter-rouge">def f(x: Int)(y: Int)</code>是一个带有两个参数列表的柯里化函数。应用柯里化函数时需传入若干个实参列表，像<code class="language-plaintext highlighter-rouge">f(3)(4)</code>这样。不过也可以写成柯里化函数的 <em>部分应用</em>（partial application），像<code class="language-plaintext highlighter-rouge">f(3)</code>这样。</p>
  </li>
  <li>
    <h4 id="声明declare">声明（declare）</h4>
    <p>可以通过 <em>声明</em> 抽象的字段、方法或类型来赋给实体一个名称，但是没有具体实现。声明和定义最关键的差异就是定义会为命名实体创建具体实现，而声明则不会。</p>
  </li>
  <li>
    <h4 id="定义define">定义（define）</h4>
    <p>在Scala程序中若提到 <em>定义</em> 什么东西，就是说给它赋个名称并给出实现。可以定义的东西包括类、特质、单例对象、字段、方法、局部函数、局部变量等。由于提到定义常常会涉及到某种具体实现，故而抽象成员应为声明而非定义。</p>
  </li>
  <li>
    <h4 id="直接子类direct-subclass">直接子类（direct subclass）</h4>
    <p>类是其 <em>直接子类</em> 的直接超类。</p>
  </li>
  <li>
    <h4 id="直接超类direct-superclass">直接超类（direct superclass）</h4>
    <p>从某个类直接衍生出类或特质，或者说在继承层级结构最接近自己的上层的某个类，这样的类就是直接超类。若类<code class="language-plaintext highlighter-rouge">Child</code>的可选的extends子句中含有类<code class="language-plaintext highlighter-rouge">Parent</code>，则<code class="language-plaintext highlighter-rouge">Parent</code>就是<code class="language-plaintext highlighter-rouge">Child</code>的直接超类。若<code class="language-plaintext highlighter-rouge">Child</code>的可选extends子句中含有特质，则特质的直接超类也是<code class="language-plaintext highlighter-rouge">Child</code>的直接超类。若<code class="language-plaintext highlighter-rouge">Child</code>没有extends子句，则<code class="language-plaintext highlighter-rouge">AnyRef</code>就是<code class="language-plaintext highlighter-rouge">Child</code>的直接超类。若类的直接超类带有类型参数，比如<code class="language-plaintext highlighter-rouge">Child extends Parent[String]</code>，<code class="language-plaintext highlighter-rouge">Child</code>的直接超类依旧是<code class="language-plaintext highlighter-rouge">Parent</code>，而不是<code class="language-plaintext highlighter-rouge">Parent[String]</code>。另一方面，<code class="language-plaintext highlighter-rouge">Parent[String]</code>应该叫做<code class="language-plaintext highlighter-rouge">Child</code>的直接超类型。参见<a href="#超类型supertype">超类型</a>了解更多关于类和类型间的区别。</p>
  </li>
  <li>
    <h4 id="相等性equality">相等性（equality）</h4>
    <p>在没有条件限制的情况下使用时，<em>相等性</em> 就是<code class="language-plaintext highlighter-rouge">==</code>所表达的两个值之间的关系。参见<a href="#引用相等性reference-equality">引用相等性</a>。</p>
  </li>
  <li>
    <h4 id="存在类型existential-type">存在类型（existential type）</h4>
    <p>存在类型包含未知类型变量的引用。比如：<code class="language-plaintext highlighter-rouge">Array[T] forSome { type T }</code>是个存在类型，是<code class="language-plaintext highlighter-rouge">T</code>的数组，而<code class="language-plaintext highlighter-rouge">T</code>是某个完全未知的类型，关于<code class="language-plaintext highlighter-rouge">T</code>唯一能够假定的是它是确定存在的。尽管这个假定很虚，但是至少意味着<code class="language-plaintext highlighter-rouge">Array[T] forSome { type T }</code>确实是个数组，而不是香蕉什么的东西。</p>
  </li>
  <li>
    <h4 id="表达式expression">表达式（expression）</h4>
    <p>任何能够得到结果的Scala代码，也可说成表达式求值为某个结果或结果为某个值。</p>
  </li>
  <li>
    <h4 id="过滤器filter">过滤器（filter）</h4>
    <p><a href="#for表达式for-expression">for表达式</a>中的<code class="language-plaintext highlighter-rouge">if</code>及跟在其后的布尔表达式。在<code class="language-plaintext highlighter-rouge">for(i &lt;- 1 to 10; if i % 2 == 0)</code>中，过滤器为”<code class="language-plaintext highlighter-rouge">if i % 2 == 0</code>“。<code class="language-plaintext highlighter-rouge">if</code>右边的值就是<a href="#过滤器表达式filter-expression">过滤器表达式</a>，也称为守卫。</p>
  </li>
  <li>
    <h4 id="过滤器表达式filter-expression">过滤器表达式（filter expression）</h4>
    <p>过滤器表达式就是<a href="#for表达式for-expression">for表达式</a>里面跟在<code class="language-plaintext highlighter-rouge">if</code>后面的布尔表达式。<code class="language-plaintext highlighter-rouge">for( i &lt;- 1 to 10 ; if i % 2 == 0)</code>的过滤器表达式为”<code class="language-plaintext highlighter-rouge">i % 2 == 0</code>“。</p>
  </li>
  <li>
    <h4 id="头等函数first-class-function">头等函数（first-class function）</h4>
    <p>Scala支持 <em>头等函数</em> ，意味着可以通过函数字面量语法来表达函数。如：<code class="language-plaintext highlighter-rouge">(x: Int) =&gt; x + 1</code>，并且函数可由对象来表达，叫做<a href="#函数值function-value">函数值</a>。</p>
  </li>
  <li>
    <h4 id="for推解式for-comprehension">for推解式（for comprehension）</h4>
    <p><em>for推解式</em> 是<a href="#for表达式for-expression">for表达式</a>的一种，一般用来创建新的集合。对<code class="language-plaintext highlighter-rouge">for</code>推解式的每次迭代，<a href="#产生yield">yield</a>子句都会定义新集合的一个元素。比如：<code class="language-plaintext highlighter-rouge">for (i &lt;- (0 until 2); j &lt;- (2 until 4)) yield (i, j)</code>将返回集合<code class="language-plaintext highlighter-rouge">Vector((0,2), (0,3), (1,2), (1,3))</code>。</p>
  </li>
  <li>
    <h4 id="for表达式for-expression">for表达式（for expression）</h4>
    <p><em>for表达式</em> 要么是个<a href="#for循环for-loop">for循环</a>，可以迭代一个或多个集合，要么是个<a href="#for推解式for-comprehension">for推解式</a>，可以从一个或多个集合的元素中推解出一个新的集合。<code class="language-plaintext highlighter-rouge">for</code>表达式建于<a href="#生成器generator">生成器</a>、<a href="#过滤器filter">过滤器</a>、变量定义和<a href="#产生yield">yield</a>子句（针对<a href="#for推解式for-comprehension">for推解式</a>）基础之上，</p>
  </li>
  <li>
    <h4 id="for循环for-loop">for循环（for loop）</h4>
    <p><em>for循环</em> 是<a href="#for表达式for-expression">for表达式</a>的一种，一般用来循环迭代一个或多个集合。因为<code class="language-plaintext highlighter-rouge">for</code>循环返回unit，所以经常被用来产生副作用。比如：<code class="language-plaintext highlighter-rouge">for (i &lt;- 0 until 100) println(i)</code>打印数字0到99。</p>
  </li>
  <li>
    <h4 id="自由变量free-variable">自由变量（free variable）</h4>
    <p>一个表达式的 <em>自由变量</em> 指的是在表达式中使用但不定义在其中的变量。例如，在函数字面量表达式<code class="language-plaintext highlighter-rouge">(x: Int) =&gt; (x, y)</code>中，变量<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>都被用到了，但只有<code class="language-plaintext highlighter-rouge">y</code>是自由变量，因其未在表达式中定义。</p>
  </li>
  <li>
    <h4 id="函数function">函数（function）</h4>
    <p><em>函数</em> 可通过一列实参来<a href="#调用invoke">调用</a>然后产生结果。函数一般具有参数列表、函数体和结果类型。作为类、特质或单例对象的函数叫做<a href="#方法method">方法</a>。定义在其他函数内部的函数叫做<a href="#局部函数local-function">局部函数</a>。结果类型为<code class="language-plaintext highlighter-rouge">Unit</code>的函数叫做<a href="#过程procedure">过程</a>。源码里面的匿名函数叫做<a href="#函数字面量function-literal">函数字面量</a>。运行时，函数字面量被实例化为对象，叫做<a href="#函数值function-value">函数值</a>。</p>
  </li>
  <li>
    <h4 id="函数字面量function-literal">函数字面量（function literal）</h4>
    <p>在Scala源码中的无名函数，通过函数字面量语法来特别对待。比如：<code class="language-plaintext highlighter-rouge">(x: Int, y: Int) =&gt; x + y</code>。</p>
  </li>
  <li>
    <h4 id="函数值function-value">函数值（function value）</h4>
    <p>可以像其他函数一样被调用的函数对象。函数值的类一般是继承了<code class="language-plaintext highlighter-rouge">scala</code>包中的<code class="language-plaintext highlighter-rouge">FunctionN</code>（比如<code class="language-plaintext highlighter-rouge">Function0</code>，<code class="language-plaintext highlighter-rouge">Function1</code>等）这类特质的其中之一，且在源码中常通过<a href="#函数字面量function-literal">函数字面量</a>语法来表示。当函数值的apply方法被调用时就说这个函数值被调用。捕获自由变量的函数值为<a href="#闭包closure">闭包</a>。</p>
  </li>
  <li>
    <h4 id="函数式风格functional-style">函数式风格（functional style）</h4>
    <p><em>函数式风格</em> 编程注重函数和求值结果而非操作发生的顺序。这种风格的特征是可传递函数值给循环方法、不可变数据、方法无副作用，是像Haskell和Erlang等这些语言的主要范式，与<a href="#命令式风格imperative-style">命令式风格</a>相对应。</p>
  </li>
  <li>
    <h4 id="生成器generator">生成器（generator）</h4>
    <p>生成器在<a href="#for表达式for-expression">for表达式</a>中定义一个命名的val变量并赋予其一系列值。比如：<code class="language-plaintext highlighter-rouge">for(i &lt;- 1 to 10)</code>的生成器是”<code class="language-plaintext highlighter-rouge">i &lt;- 1 to 10</code>“，<code class="language-plaintext highlighter-rouge">&lt;-</code>右边的值是<a href="#生成器表达式generator-expression">生成器表达式</a>。</p>
  </li>
  <li>
    <h4 id="生成器表达式generator-expression">生成器表达式（generator expression）</h4>
    <p>生成器表达式在<a href="#for表达式for-expression">for表达式</a>中生成一些列值。比如：<code class="language-plaintext highlighter-rouge">for(i &lt;- 1 to 10)</code>的生成器表达式是”<code class="language-plaintext highlighter-rouge">1 to 10</code>“。</p>
  </li>
  <li>
    <h4 id="泛型类generic-class">泛型类（generic class）</h4>
    <p>带有类型参数的类。例如，因<code class="language-plaintext highlighter-rouge">scala.List</code>带一类型参数，故其为泛型类。</p>
  </li>
  <li>
    <h4 id="泛型特质generic-trait">泛型特质（generic trait）</h4>
    <p>带有类型参数的特质。例如，因<code class="language-plaintext highlighter-rouge">scala.collection.Set</code>带一类型参数，故其为泛型特质。</p>
  </li>
  <li>
    <h4 id="守卫guard">守卫（guard）</h4>
    <p>参见<a href="#过滤器filter">过滤器</a>.</p>
  </li>
  <li>
    <h4 id="辅助函数helper-function">辅助函数（helper function）</h4>
    <p>目的是为一个或多个其他邻近函数提供服务的函数。辅助函数常实现为局部函数。</p>
  </li>
  <li>
    <h4 id="辅助方法helper-method">辅助方法（helper method）</h4>
    <p>作为类成员的<a href="#辅助函数helper-function">辅助函数</a>。辅助方法常为私有方法。</p>
  </li>
  <li>
    <h4 id="不可变immutable">不可变（immutable）</h4>
    <p>若对象的值在任何对客户端可见的方式下创建后不会被修改则称对象是 <em>不可变</em> 的。对象既可以是不可变的，也可以是可变的。</p>
  </li>
  <li>
    <h4 id="命令式风格imperative-style">命令式风格（imperative style）</h4>
    <p><em>命令式风格</em> 编程强调严谨的操作序列以令效用能在正确的顺序发生。这种风格的特征是循环迭代、适当变更数据、方法有副作用，是像C, C++, C#和Java等这些语言的主要范式，与<a href="#函数式风格functional-style">函数式风格</a>相对应。</p>
  </li>
  <li>
    <h4 id="初始化initialize">初始化（initialize）</h4>
    <p>变量在Scala源码中被定义时，必须用对象对其进行初始化。</p>
  </li>
  <li>
    <h4 id="实例instance">实例（instance）</h4>
    <p><em>实例</em> ，或叫类实例，是个对象，是个仅在运行时存在的概念</p>
  </li>
  <li>
    <h4 id="实例化instantiate">实例化（instantiate）</h4>
    <p><em>实例化</em> 类是根据类创建一个新对象，是仅在运行时发生的动作。</p>
  </li>
  <li>
    <h4 id="不变性invariant">不变性（invariant）</h4>
    <p><em>不变性</em> 用在两个地方。首先在数据结构组织良好的情况下它可以表示某个属性始终为真。比如，若排序二叉树具有右子节点，则其各节点就会在其右子节点前完成排序，这就属于排序二叉树的不变性。其次有时不变性也作为非协变的同义词，如：”类<code class="language-plaintext highlighter-rouge">Array</code>在类型参数上具备不变性”。</p>
  </li>
  <li>
    <h4 id="调用invoke">调用（invoke）</h4>
    <p>在实参上 <em>调用</em> 方法、函数或闭包，意即其方法体会在指定实参上执行。</p>
  </li>
  <li>
    <h4 id="java虚拟机jvm">Java虚拟机（JVM）</h4>
    <p><em>JVM</em> 是Java虚拟机(#runtime)的缩写，或叫<a href="#运行时runtime">运行时</a>，是运行Scala程序的宿主。</p>
  </li>
  <li>
    <h4 id="字面量literal">字面量（literal）</h4>
    <p><code class="language-plaintext highlighter-rouge">1</code>，<code class="language-plaintext highlighter-rouge">"One"</code>，和<code class="language-plaintext highlighter-rouge">(x: Int) =&gt; x + 1</code>是 <em>字面量</em> 的例子，字面量是描述对象的便捷方式，便捷在这种方式正好反映了所创建对象的结构。</p>
  </li>
  <li>
    <h4 id="局部函数local-function">局部函数（local function）</h4>
    <p><em>局部函数</em> 是块内<code class="language-plaintext highlighter-rouge">def</code>定义的，作为对比，同为<code class="language-plaintext highlighter-rouge">def</code>定义的作为类、特质或单例对象的成员则被称作<a href="#方法method">方法</a>。</p>
  </li>
  <li>
    <h4 id="局部变量local-variable">局部变量（local variable）</h4>
    <p><em>局部变量</em> 是块内<code class="language-plaintext highlighter-rouge">val</code>或<code class="language-plaintext highlighter-rouge">var</code>定义的。尽管函数参数和<a href="#局部变量local-variable">局部变量</a>类似，但并不叫局部变量，而是去掉”局部”直接叫”参数”或”变量”。</p>
  </li>
  <li>
    <h4 id="成员member">成员（member）</h4>
    <p><em>成员</em> 是类、特质或单例对象模板中被命名的元素。成员可通过所有者名称，点及其简名访问。例如，定义在类的最顶层字段和方法是这个类的成员。定义在类中的特质是包围它的类的成员。类中通过type关键字定义的类型是这个类的成员。类是其定义所在的包的成员。相比之下，局部变量或局部函数就不是包围他们的块的成员。</p>
  </li>
  <li>
    <h4 id="消息message">消息（message）</h4>
    <p>Actor是通过给彼此之间发送 <em>消息</em> 来进行通信的。发送消息不会打断接收者正在处理的事情，接收者可一直等到当前活动结束且其不变性被重建之后。</p>
  </li>
  <li>
    <h4 id="元编程meta-programming">元编程（meta-programming）</h4>
    <p>元编程程序是指其输入是其自身程序的程序。编译器都是元程序，像<code class="language-plaintext highlighter-rouge">scaladoc</code>这样的工具也是。要用注解做任何事都需要元编程程序。</p>
  </li>
  <li>
    <h4 id="方法method">方法（method）</h4>
    <p><em>方法</em> 就是类、特质或单例对象的成员函数。</p>
  </li>
  <li>
    <h4 id="混入mixin">混入（mixin）</h4>
    <p><em>混入</em> 就是特质用在混入组合时的名称。换言之，在”<code class="language-plaintext highlighter-rouge">trait Hat</code>“里面，<code class="language-plaintext highlighter-rouge">Hat</code>仅为特质，而”<code class="language-plaintext highlighter-rouge">new Cat extends AnyRef with Hat</code>“里面的<code class="language-plaintext highlighter-rouge">Hat</code>就可叫混入。用作动词时，”混”和”入”（”mix in”）是两个词。比如，可 <em>混</em> 特质 <em>入</em> 至类或其他特质。</p>
  </li>
  <li>
    <h4 id="混入组合mixin-composition">混入组合（mixin composition）</h4>
    <p>把特质混入类或其他特质的过程。<em>混入组合</em> 与传统的多重继承不同之处在于父级引用的类型不是在特质定义时已知的，而是在每次特质每次混入到类或其他特质时才被重新确定。</p>
  </li>
  <li>
    <h4 id="修饰符modifier">修饰符（modifier）</h4>
    <p>用来以某种方式限定类、特质、字段或方法等的定义的关键字。比如，<code class="language-plaintext highlighter-rouge">private</code>修饰符表明被定义的类、特质、字段或方法是私有的。</p>
  </li>
  <li>
    <h4 id="多重定义multiple-definitions">多重定义（multiple definitions）</h4>
    <p>通过使用类似这样的语法<code class="language-plaintext highlighter-rouge">val v1, v2, v3 = exp</code>，同一个表达式根据 <em>多重定义</em> 概念可被赋值给多个变量。</p>
  </li>
  <li>
    <h4 id="非协变nonvariant">非协变（nonvariant）</h4>
    <p>类或特质的类型参数默认是 <em>非协变</em> 的，故而参数变化并不会子类化相应的类或特质。比如，因类<code class="language-plaintext highlighter-rouge">Array</code>非协变于其类型参数，故<code class="language-plaintext highlighter-rouge">Array[String]</code>既非<code class="language-plaintext highlighter-rouge">Array[Any]</code>之子类，亦非其超类。</p>
  </li>
  <li>
    <h4 id="操作operation">操作（operation）</h4>
    <p>在Scala中，每个 <em>操作</em> 都是一个方法调用。方法也可以 <em>操作符符号</em> 的方式被调用，像在<code class="language-plaintext highlighter-rouge">b + 2</code>里面符号<code class="language-plaintext highlighter-rouge">+</code>就是一个 <em>操作符</em>。</p>
  </li>
  <li>
    <h4 id="参数parameter">参数（parameter）</h4>
    <p>函数可带有零至多个 <em>参数</em>，每个参数都有名称和类型。参数与实参之间的区别在于函数调用时实参指向具体的对象，参数则是指向这些传入实参的变量。</p>
  </li>
  <li>
    <h4 id="无参函数parameterless-function">无参函数（parameterless function）</h4>
    <p>不带参数的函数，其定义时没有任何空括号。无参函数可不带括号调用，这种方式符合<a href="#统一访问原则uniform-access-principle">统一访问原则</a>，就是在客户端不改变任何代码的情况下把<code class="language-plaintext highlighter-rouge">def</code>改成<code class="language-plaintext highlighter-rouge">val</code>。</p>
  </li>
  <li>
    <h4 id="无参方法parameterless-method">无参方法（parameterless method）</h4>
    <p><em>无参方法</em> 就是作为类、特质或单例对象成员的无参函数。</p>
  </li>
  <li>
    <h4 id="参数化字段parametric-field">参数化字段（parametric field）</h4>
    <p>定义为类参数的字段。</p>
  </li>
  <li>
    <h4 id="偏应用函数部分应用函数partially-applied-function">偏应用函数（部分应用函数）（partially applied function）</h4>
    <p>用在表达式中，省掉某些参数的函数。例如：若函数<code class="language-plaintext highlighter-rouge">f</code>的类型为<code class="language-plaintext highlighter-rouge">Int =&gt; Int =&gt; Int</code>，则<code class="language-plaintext highlighter-rouge">f</code>和<code class="language-plaintext highlighter-rouge">f(1)</code>就是 <em>偏应用函数</em>。</p>
  </li>
  <li>
    <h4 id="路径依赖类型path-dependent-type">路径依赖类型（path-dependent type）</h4>
    <p>类似<code class="language-plaintext highlighter-rouge">swiss.cow.Food</code>的一种类型，<code class="language-plaintext highlighter-rouge">swiss.cow</code>部分形成一个对象引用的路径。这种类型的含义对于用来访问它的路径是敏感的，比如，<code class="language-plaintext highlighter-rouge">swiss.cow.Food</code>和<code class="language-plaintext highlighter-rouge">fish.Food</code>这两个是不同的类型。</p>
  </li>
  <li>
    <h4 id="模式pattern">模式（pattern）</h4>
    <p>在<code class="language-plaintext highlighter-rouge">match</code>表达式的某个备选项中，<em>模式</em> 跟在<code class="language-plaintext highlighter-rouge">case</code>关键字后，先于 <em>模式守卫</em> 或<code class="language-plaintext highlighter-rouge">=&gt;</code>符号二者之一。</p>
  </li>
  <li>
    <h4 id="模式守卫pattern-guard">模式守卫（pattern guard）</h4>
    <p>在<code class="language-plaintext highlighter-rouge">match</code>表达式的某个备选项中，<em>模式守卫</em> 可跟在某个<a href="#模式pattern">模式</a>后面。比如，”<code class="language-plaintext highlighter-rouge">case x if x % 2 == 0 =&gt; x + 1</code>“中的模式守卫为”<code class="language-plaintext highlighter-rouge">if x % 2 == 0</code>“。带有模式守卫的备选项（case）仅当其模式匹配了并且模式守卫为真的时候才会被选中。</p>
  </li>
  <li>
    <h4 id="断言predicate">断言（predicate）</h4>
    <p>断言是结果类型为<code class="language-plaintext highlighter-rouge">Boolean</code>的函数。</p>
  </li>
  <li>
    <h4 id="主构造器primary-constructor">主构造器（primary constructor）</h4>
    <p>类的主要构造器，会调用超类构造器，如果有必要，也会初始化字段进行传值，并且会执行类的花括号内定义的的顶层（top-level）代码。字段仅由不传给超类构造器的值参数做初始化，那些类构造体内因未用到而被优化掉的除外。</p>
  </li>
  <li>
    <h4 id="过程procedure">过程（procedure）</h4>
    <p><em>过程</em> 是结果类型为<code class="language-plaintext highlighter-rouge">Unit</code>的函数，其存在的理由仅为产生副作用。</p>
  </li>
  <li>
    <h4 id="可重新赋值reassignable">可重新赋值（reassignable）</h4>
    <p>变量可以是可重新赋值的，也可以不是可重新赋值的。<code class="language-plaintext highlighter-rouge">var</code>是可重新赋值的，而<code class="language-plaintext highlighter-rouge">val</code>则不是。</p>
  </li>
  <li>
    <h4 id="递归的recursive">递归的（recursive）</h4>
    <p>若函数可调用自身就说它是 <em>递归的</em>。若函数调用自身的唯一位置是函数的最后一个表达式，则函数是<a href="#尾递归tail-recursive">尾递归</a>的。</p>
  </li>
  <li>
    <h4 id="引用reference">引用（reference）</h4>
    <p><em>引用</em> 是指针的Java抽象，可唯一确定存在JVM堆中的对象。引用类型变量持有对象的引用，因为引用类型（<code class="language-plaintext highlighter-rouge">AnyRef</code>的实例）是存在JVM堆上的Java对象实现的。相比之下，值类型变量有时会持有一个（装箱类型的）引用，也有时（当对象表示基础类型值的时候）不会。一般说来，Scala变量<a href="#指向refers">指向</a>对象。术语”指向”比”持有引用”更加抽象。如果类型为<code class="language-plaintext highlighter-rouge">scala.Int</code>的变量当前代表Java基础类型<code class="language-plaintext highlighter-rouge">int</code>的值，则这个变量仍然指向<code class="language-plaintext highlighter-rouge">Int</code>对象，但并不涉及任何引用。</p>
  </li>
  <li>
    <h4 id="引用相等性reference-equality">引用相等性（reference equality）</h4>
    <p><em>引用相等性</em> 意思是两个引用指向同一个Java对象。引用相等性仅针对引用类型有意义，是可以通过调用<code class="language-plaintext highlighter-rouge">AnyRef</code>中的<code class="language-plaintext highlighter-rouge">eq</code>来确定的（在Java程序中，引用相等性通过在Java<a href="#引用类型reference-type">引用类型</a>上调用<code class="language-plaintext highlighter-rouge">==</code>来确定）。</p>
  </li>
  <li>
    <h4 id="引用类型reference-type">引用类型（reference type）</h4>
    <p><em>引用类型</em> 是<code class="language-plaintext highlighter-rouge">AnyRef</code>的子类。在运行时，引用类型的实例常驻JVM堆中。</p>
  </li>
  <li>
    <h4 id="引用透明referential-transparency">引用透明（referential transparency）</h4>
    <p>独立于临时上下文且无副作用的函数属性。对于特定输入，引用透明函数的调用可由其结果替换而不改变程序语义。</p>
  </li>
  <li>
    <h4 id="指向refers">指向（refers）</h4>
    <p>运行的Scala程序中的变量常 <em>指向</em> 某个对象。变量即使被赋为<code class="language-plaintext highlighter-rouge">null</code>，概念上也是指向<code class="language-plaintext highlighter-rouge">Null</code>对象。在运行时，对象可由Java对象或基础类型值来实现，不过Scala允许程序员在更高层次抽象代码以他们设想的方式运行。参见<a href="#引用reference">引用</a>.</p>
  </li>
  <li>
    <h4 id="精化类型refinement-type">精化类型（refinement type）</h4>
    <p>通过提供基础类型及其构造体花括号内若干成员而形成的类型。花括号内的成员精细化了基础类型所体现的类型。比如，”食草动物”（animal that eats grass）的类型为<code class="language-plaintext highlighter-rouge">Animal { type SuitableFood = Grass }</code>。
A type formed by supplying a base type a number of members inside curly braces. The members in the curly braces refine the types that are present in the base type. For example, the type of “animal that eats grass” is <code class="language-plaintext highlighter-rouge">Animal { type SuitableFood = Grass }</code>.</p>
  </li>
  <li>
    <h4 id="结果result">结果（result）</h4>
    <p>Scala程序中的表达式会产生 <em>结果</em>。Scala中的每个表达式的结果都是对象。</p>
  </li>
  <li>
    <h4 id="结果类型result-type">结果类型（result type）</h4>
    <p>方法的 <em>结果类型</em> 是调用方法所产生的值的类型。（在Java中，这个概念被称为返回类型）</p>
  </li>
  <li>
    <h4 id="返回return">返回（return）</h4>
    <p>Scala程序中的函数会 <em>返回</em> 值，可把这个值叫做函数的<a href="#结果result">结果</a>。也可以说函数 <em>结果是</em> 某个值。Scala中的每个函数结果都是一个对象。</p>
  </li>
  <li>
    <h4 id="运行时runtime">运行时（runtime）</h4>
    <p>正在运行Scala程序的宿主Java虚拟机，或宿主<a href="#java虚拟机jvm">JVM</a>。运行时这个概念包含了Java虚拟机规范中定义的虚拟机以及Java API和标准Scala API的运行时库。在运行时的这个阶段，意味着程序正在运行中，与编译时是相对的概念。</p>
  </li>
  <li>
    <h4 id="运行时类型runtime-type">运行时类型（runtime type）</h4>
    <p>对象在运行时的类型。相比之下，<a href="#静态类型static-type">静态类型</a>指的是表达式在编译时的类型。多数运行时类型都是无类型参数的裸类，比如，<code class="language-plaintext highlighter-rouge">"Hi"</code>的运行时类型是<code class="language-plaintext highlighter-rouge">String</code>，<code class="language-plaintext highlighter-rouge">(x: Int) =&gt; x + 1</code>的运行时类型是<code class="language-plaintext highlighter-rouge">Function1</code>。运行时类型可通过<code class="language-plaintext highlighter-rouge">isInstanceOf</code>来检测。</p>
  </li>
  <li>
    <h4 id="脚本script">脚本（script）</h4>
    <p>包含顶层定义和语句，可直接通过<code class="language-plaintext highlighter-rouge">scala</code>命令来跑而无需显式编译的文件就是脚本，脚本结尾必须是表达式，而不能是定义。</p>
  </li>
  <li>
    <h4 id="选择器selector">选择器（selector）</h4>
    <p><code class="language-plaintext highlighter-rouge">match</code>表达式中被匹配的值。比如，在”<code class="language-plaintext highlighter-rouge">s match { case _ =&gt; }</code>“中，选择器是<code class="language-plaintext highlighter-rouge">s</code>。</p>
  </li>
  <li>
    <h4 id="自身类型self-type">自身类型（self type）</h4>
    <p>特质的 <em>自身类型</em> 是特质中用到的接收者<code class="language-plaintext highlighter-rouge">this</code>的假想类型。任何混入特质的具体类必须要确保其类型符合特质的自身类型。自身类型常被用来把大类分解为若干个特质（<a href="https://www.artima.com/shop/programming_in_scala">Programming in Scala</a>第29章有述）。</p>
  </li>
  <li>
    <h4 id="半结构化数据semi-structured-data">半结构化数据（semi-structured data）</h4>
    <p>XML数据就是半结构化的，因其相比于普通的二进制文件或文本文件更加结构化，而又不像编程语言的数据结构具备完全结构化。</p>
  </li>
  <li>
    <h4 id="序列化serialization">序列化（serialization）</h4>
    <p>可把对象 <em>序列化</em> 成字节流，以便将其保存至文件或通过网络传输。之后可对字节流进行 <em>反序列化</em> （可发生在不同计算机上）来获取和原始被序列化的对象一样的对象。</p>
  </li>
  <li>
    <h4 id="遮掩shadow">遮掩（shadow）</h4>
    <p>局部变量的重新声明会 <em>遮掩</em> 作用域内相同名称的变量声明。</p>
  </li>
  <li>
    <h4 id="签名signature">签名（signature）</h4>
    <p><em>签名</em> 是<a href="#类型签名type-signature">类型签名</a>的简写。</p>
  </li>
  <li>
    <h4 id="单例对象singleton-object">单例对象（singleton object）</h4>
    <p>由object关键字定义的对象。每个单例对象有且仅有一个实例。与某个类共享名称且与这个类定义在同一源文件中的单例对象，叫这个类的<a href="#伴生对象companion-object">伴生对象</a>，类则叫单列对象的<a href="#伴生类companion-class">伴生类</a>。无伴随类的单例对象叫<a href="#独立对象standalone-object">独立对象</a>。</p>
  </li>
  <li>
    <h4 id="独立对象standalone-object">独立对象（standalone object）</h4>
    <p>没有<a href="#伴生类companion-class">伴生类</a>的<a href="#单例对象singleton-object">单例对象</a>。</p>
  </li>
  <li>
    <h4 id="语句statement">语句（statement）</h4>
    <p>指的是表达式、定义或包导入等这些可放到Scala源码的模板或块中的东西。</p>
  </li>
  <li>
    <h4 id="静态类型static-type">静态类型（static type）</h4>
    <p>参见<a href="#类型type">类型</a>。</p>
  </li>
  <li>
    <h4 id="结构类型structural-type">结构类型（structural type）</h4>
    <p>也是一种<a href="#精化类型refinement-type">精化类型</a>，只是精化的目标是未在基类型中的成员。比如<code class="language-plaintext highlighter-rouge">{ def close(): Unit }</code>就是结构类型，因其基类型是<code class="language-plaintext highlighter-rouge">AnyRef</code>，而<code class="language-plaintext highlighter-rouge">AnyRef</code>并无名为<code class="language-plaintext highlighter-rouge">close</code>的成员。</p>
  </li>
  <li>
    <h4 id="子类subclass">子类（subclass）</h4>
    <p>一个类是其所有<a href="#超类superclass">超类</a>和<a href="#超特质supertrait">超特质</a>的 <em>子类</em>。</p>
  </li>
  <li>
    <h4 id="子特质subtrait">子特质（subtrait）</h4>
    <p>一个特质是其所有<a href="#超特质supertrait">超特质</a>的 <em>子特质</em>。</p>
  </li>
  <li>
    <h4 id="子类型subtype">子类型（subtype）</h4>
    <p>Scala编译器允许任何类型在需要该类型的地方使用其 <em>子类型</em> 作为替代。对不带类型参数的类和特质来说，子类型的关系会反映子类的关系。比如，若类<code class="language-plaintext highlighter-rouge">Cat</code>是抽象类<code class="language-plaintext highlighter-rouge">Animal</code>的子类，且也不带类型参数，则类型<code class="language-plaintext highlighter-rouge">Cat</code>就是类型<code class="language-plaintext highlighter-rouge">Animal</code>的子类型。同样，若特质<code class="language-plaintext highlighter-rouge">Apple</code>是特质<code class="language-plaintext highlighter-rouge">Fruit</code>的子特质且无类型参数，则类型<code class="language-plaintext highlighter-rouge">Apple</code>就是类型<code class="language-plaintext highlighter-rouge">Fruit</code>的子类型。而对于带有类型参数的类和特质来说，协变就起作用了。比如，由于抽象类<code class="language-plaintext highlighter-rouge">List</code>被声明为在其长类型参数上是协变的（例，<code class="language-plaintext highlighter-rouge">List</code>被声明为<code class="language-plaintext highlighter-rouge">List[+A]</code>），<code class="language-plaintext highlighter-rouge">List[Cat]</code>是<code class="language-plaintext highlighter-rouge">List[Animal]</code>的子类型，<code class="language-plaintext highlighter-rouge">List[Apple]</code>是<code class="language-plaintext highlighter-rouge">List[Fruit]</code>的子类型。尽管这些类型的类都是<code class="language-plaintext highlighter-rouge">List</code>，但其子类型的关系依旧是存在的。对比来看，因为<code class="language-plaintext highlighter-rouge">Set</code>未被声明在其类型参数上是协变的（例，<code class="language-plaintext highlighter-rouge">Set</code>被声明为<code class="language-plaintext highlighter-rouge">Set[A]</code>，不带加号），所以<code class="language-plaintext highlighter-rouge">Set[Cat]</code>并不是<code class="language-plaintext highlighter-rouge">Set[Animal]</code>的子类型。子类型应该正确实现其超类型的契约，以便应用里氏替换原则（Liskov Substitution Principle），不过编译器仅会在类型检查级别核验此属性。</p>
  </li>
  <li>
    <h4 id="超类superclass">超类（superclass）</h4>
    <p>一个类的 <em>超类</em> 包括其直接超类，其直接超类的直接超类，等等一直到<code class="language-plaintext highlighter-rouge">Any</code>。</p>
  </li>
  <li>
    <h4 id="超特质supertrait">超特质（supertrait）</h4>
    <p>类或特质的 <em>超特质</em>，如果有的话，就包括所有直接混入类或特质或其任意超类的特质，以及这些特质的所有超特质。</p>
  </li>
  <li>
    <h4 id="超类型supertype">超类型（supertype）</h4>
    <p>类型是其所有子类型的 <em>超类型</em>。</p>
  </li>
  <li>
    <h4 id="合成类synthetic-class">合成类（synthetic class）</h4>
    <p>合成类是编译器自动生成的而不是程序员手写的。</p>
  </li>
  <li>
    <h4 id="尾递归tail-recursive">尾递归（tail recursive）</h4>
    <p>函数是 <em>尾递归</em> 的，仅当函数调用自身的地方是函数的最后一条操作。</p>
  </li>
  <li>
    <h4 id="目标类型化target-typing">目标类型化（target typing）</h4>
    <p><em>目标类型化</em> 是参考所需类型来进行类型推导的一种形式。比如在<code class="language-plaintext highlighter-rouge">nums.filter((x) =&gt; x &gt; 0)</code>中，Scala编译器能推导出<code class="language-plaintext highlighter-rouge">x</code>的类型是<code class="language-plaintext highlighter-rouge">nums</code>的元素类型，因为<code class="language-plaintext highlighter-rouge">filter</code>方法会在<code class="language-plaintext highlighter-rouge">nums</code>的每个元素上调用函数。</p>
  </li>
  <li>
    <h4 id="模板template">模板（template）</h4>
    <p><em>模板</em> 是类、特质或单例对象定义体，它定义了类、特质或对象的类型签名，行为以及初始状态。</p>
  </li>
  <li>
    <h4 id="特质trait">特质（trait）</h4>
    <p><em>特质</em> 通过<code class="language-plaintext highlighter-rouge">trait</code>关键字定义，是像抽象类一样不带任何值参数，并且可通过被称为<a href="#混入组合mixin-composition">混入组合</a>的过程”混入到”类或其他特质。当某个特质被混入到其他类或特质，它就被叫做<a href="#混入mixin">混入</a>。特质可通过一个或多个类型参数化。用类型来参数化后，特质就形成了类型。比如，<code class="language-plaintext highlighter-rouge">Set</code>是带有单类型参数的特质，而<code class="language-plaintext highlighter-rouge">Set[Int]</code>却是一个类型。<code class="language-plaintext highlighter-rouge">Set</code>也被说成是类型<code class="language-plaintext highlighter-rouge">Set[Int]</code>的”特质”。</p>
  </li>
  <li>
    <h4 id="类型type">类型（type）</h4>
    <p>Scala程序中每个变量和表达式都有编译时确定的 <em>类型</em>。类型可以在运行时限定变量能指向的值和表达式所能产生的值。如果有必要从对象的<a href="#运行时类型runtime-type">运行时类型</a>的角度对变量和表达式的类型进行区分的话，他们也被称为 <em>静态类型</em>。换句话说，”类型”这个词本身意味着静态类型。类型与类是区分开的因为带有类型参数的类可以构成许多类型。比如，<code class="language-plaintext highlighter-rouge">List</code>是类不是类型，<code class="language-plaintext highlighter-rouge">List[T]</code>则是一个带有自由类型参数的类型，<code class="language-plaintext highlighter-rouge">List[Int]</code>和<code class="language-plaintext highlighter-rouge">List[String]</code>也是类型（称为实类型因为他们没有自由类型参数）。类型可以有”<a href="#类class">类</a>“或”<a href="#特质trait">特质</a>“，比如类型<code class="language-plaintext highlighter-rouge">List[Int]</code>的类是<code class="language-plaintext highlighter-rouge">List</code>，类型<code class="language-plaintext highlighter-rouge">Set[String]</code>的特质是<code class="language-plaintext highlighter-rouge">Set</code>。</p>
  </li>
  <li>
    <h4 id="类型约束type-constraint">类型约束（type constraint）</h4>
    <p>有些<a href="#注解annotation">注解</a>是 <em>类型约束</em>，意味着他们会对类型能够包含的取值增加额外的限制或约束。比如，<code class="language-plaintext highlighter-rouge">@positive</code>可以是类型<code class="language-plaintext highlighter-rouge">Int</code>的类型约束，用来限制32位整型的取值为正的整数。类型约束虽然不会被标准Scala编译器检查，但相应的必须可被额外的工具或编译器插件检查。</p>
  </li>
  <li>
    <h4 id="类型构造器type-constructor">类型构造器（type constructor）</h4>
    <p>带类型参数的类或特质。</p>
  </li>
  <li>
    <h4 id="类型参数type-parameter">类型参数（type parameter）</h4>
    <p>必须被填入类型的泛型类或泛型方法的参数。比如，类<code class="language-plaintext highlighter-rouge">List</code>定义为”<code class="language-plaintext highlighter-rouge">class List[T] { . . . </code>“，对象<code class="language-plaintext highlighter-rouge">Predef</code>的一个成员方法<code class="language-plaintext highlighter-rouge">identity</code>定义为”<code class="language-plaintext highlighter-rouge">def identity[T](x:T) = x</code>“，二者定义中的<code class="language-plaintext highlighter-rouge">T</code>就是类型参数。</p>
  </li>
  <li>
    <h4 id="类型签名type-signature">类型签名（type signature）</h4>
    <p>方法的 <em>类型签名</em> 包括名称，参数（如果有的话）的数量、顺序和类型，以及结果类型。类、特质或单例对象的类型签名包括名称，所有成员和构造器的类型签名，及其声明的继承和混入关系。</p>
  </li>
  <li>
    <h4 id="统一访问原则uniform-access-principle">统一访问原则（uniform access principle）</h4>
    <p><em>统一访问原则</em> 指的是变量和无参函数应以相同的语法来访问。Scala通过不允许在无参函数的调用点放置括号来支持该原则。这样的话，无参函数定义就可以改成<code class="language-plaintext highlighter-rouge">val</code>而不影响客户端代码，<em>反之亦然</em>。</p>
  </li>
  <li>
    <h4 id="不可达unreachable">不可达（unreachable）</h4>
    <p>在Scala层面，对象可以是 <em>不可达</em> 的，此时其所占据的内存可被运行时回收。不可达并不一定意味着未被引用。引用类型（<code class="language-plaintext highlighter-rouge">AnyRef</code>的实例）被实现为驻于JVM堆上的对象。当引用类型的实例不可达后，它也确实不被引用了，且可被垃圾回收。值类型（<code class="language-plaintext highlighter-rouge">AnyVal</code>的实例）可被实现为驻于堆中的基础类型值或Java包装类型实例（如<code class="language-plaintext highlighter-rouge">java.lang.Integer</code>）。值类型实例可在指向他们的变量的整个生命周期内被装箱（从基础类型值转成包装类型对象）或拆箱（从包装类型对象转成基础类型值）。若表现为JVM堆上的包装类型对象的值类型实例不可达，那就确实不会被引用并且可被垃圾回收。但是若正在表现为基础类型值的值类型不可达，则其仍可被引用，因为此时它并不会以作为对象驻于JVM堆上。运行时可回收不可达对象所占据的内存，但是假如一个Int在运行时被实现为Java基础类型int，在一个运行中的方法的栈帧上占据了一些内存，则这个对象的内存将在方法运行完成且栈帧弹出时才被回收。引用类型的内存，比如<code class="language-plaintext highlighter-rouge">Strings</code>，可在不可达之后由JVM的垃圾收集器回收。</p>
  </li>
  <li>
    <h4 id="未引用unreferenced">未引用（unreferenced）</h4>
    <p>参见<a href="#不可达unreachable">不可达</a>。</p>
  </li>
  <li>
    <h4 id="值value">值（value）</h4>
    <p>Scala中的任何计算或表达式的结果都是一个 <em>值</em>，而Scala中的每个值都是一个对象。值这个术语本质上是指对象在内存中（在JVM堆或栈上）的镜像。</p>
  </li>
  <li>
    <h4 id="值类型value-type">值类型（value type）</h4>
    <p><em>值类型</em> 是<code class="language-plaintext highlighter-rouge">AnyVal</code>的任意子类，像<code class="language-plaintext highlighter-rouge">Int</code>，<code class="language-plaintext highlighter-rouge">Double</code>或<code class="language-plaintext highlighter-rouge">Unit</code>。该术语具有Scala源码级别的意味。在运行时，对应于Java基础类型的值类型实例可由基础类型值或包装类型实例来实现，比如<code class="language-plaintext highlighter-rouge">java.lang.Integer</code>。在值类型实例的整个生命周期内，运行时可将其在基础类型和包装类型间来回转换（如，对其装箱和拆箱）。</p>
  </li>
  <li>
    <h4 id="变量variable">变量（variable）</h4>
    <p>指向对象的命名实体。变量要么是<code class="language-plaintext highlighter-rouge">val</code>，要么是 <code class="language-plaintext highlighter-rouge">var</code>，<code class="language-plaintext highlighter-rouge">val</code>变量和<code class="language-plaintext highlighter-rouge">var</code>变量在定义时都必须被初始化，但仅<code class="language-plaintext highlighter-rouge">var</code>变量可被重新赋值来指向不同对象。</p>
  </li>
  <li>
    <h4 id="型变variance">型变（variance）</h4>
    <p>类或特质的类型参数可用 <em>型变</em> 标号来做标记，即<a href="#协变covariant">协变</a>（+）或<a href="#逆变contravariant">逆变</a>（-）。这样的型变标号表明了泛型类或特质的子类化是如何开展的，比如，泛型类<code class="language-plaintext highlighter-rouge">List</code>在其类型参数上是协变的，因此<code class="language-plaintext highlighter-rouge">List[String]</code>就是<code class="language-plaintext highlighter-rouge">List[Any]</code>的子类型。默认情况下，即缺少标号<code class="language-plaintext highlighter-rouge">+</code>或<code class="language-plaintext highlighter-rouge">-</code>的类型参数是<a href="#非协变nonvariant">非协变</a>的。</p>
  </li>
  <li>
    <h4 id="产生yield">产生（yield）</h4>
    <p>表达式可以 <em>产生</em> 结果。<code class="language-plaintext highlighter-rouge">yield</code>关键字指定了<a href="#for推解式for-comprehension">for推解式</a>的结果。</p>
  </li>
</ul>

				</div>
				
				
				
				<ul id="available-languages" style="display: none;">
					<li><a href="/glossary/index.html">English</a></li>
					
					
					<li><a href="/zh-cn/glossary/index.html" class="lang">中文 (简体)</a></li>
					
				</ul>
				
				<div class="content-contributors">
    <h3>Contributors to this page:</h3>
    <div id="contributors" class="contributors-container"></div>
</div>

			</div>
		</div>

		<!-- TOC -->
		<div class="content-nav">
	<div class="inner-box sidebar-toc-wrapper" style="">
		<h5 class="contents">Terms</h5>
		<div class="inner-toc glossary-toc" id="sidebar-toc">
      <div id="toc"></div>
		</div>
		<hr>
		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/glossary/index.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
	</div>
</div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="/getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="/overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.13/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="/scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="/resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>

<!-- moment js -->
<script src="/resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="/resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="/resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="/resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="/resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="/resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom JavaScript -->
<script src="/resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
if ($("#doc-search-bar").length) {
  docsearch({
    apiKey: 'fbc439670f5d4e3730cdcb715c359391',
    indexName: 'scala-lang',
    inputSelector: '#doc-search-bar',
    algoliaOptions: { 'facetFilters': ["language:en"] },
    debug: false // Set debug to true if you want to inspect the dropdown
  });
}
</script>
</body>

</html>


<script src="/scripts/scaladoc-scalajs.js" type="text/javascript"></script>
<link rel="stylesheet" href="/resources/css/colors.css" type="text/css" />
<link rel="stylesheet" href="/resources/css/code-snippets.css" type="text/css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">

