---
title: "Context Functions"
next-page: /scala3/reference/contextual/conversions
num: 23
type: section
previous-page: /scala3/reference/contextual/multiversal-equality
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

_Context functions_ are functions with (only) context parameters.
Their types are _context function types_. Here is an example of a context function type:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type Executable[T] = ExecutionContext ?=&gt; T
</span></code></pre></div>

Context functions are written using `?=>` as the "arrow" sign.
They are applied to synthesized arguments, in
the same way methods with context parameters are applied. For instance:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given ec: ExecutionContext = ...
</span><span id="1" class="" >
</span><span id="2" class="" >  def f(x: Int): ExecutionContext ?=&gt; Int = ...
</span><span id="3" class="" >
</span><span id="4" class="" >  // could be written as follows with the type alias from above
</span><span id="5" class="" >  // def f(x: Int): Executable[Int] = ...
</span><span id="6" class="" >
</span><span id="7" class="" >  f(2)(using ec)   // explicit argument
</span><span id="8" class="" >  f(2)             // argument is inferred
</span></code></pre></div>

Conversely, if the expected type of an expression `E` is a context function type
`(T_1, ..., T_n) ?=> U` and `E` is not already an
context function literal, `E` is converted to a context function literal by rewriting it to

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >(x_1: T1, ..., x_n: Tn) ?=&gt; E
</span></code></pre></div>

where the names `x_1`, ..., `x_n` are arbitrary. This expansion is performed
before the expression `E` is typechecked, which means that `x_1`, ..., `x_n`
are available as givens in `E`.

Like their types, context function literals are written using `?=>` as the arrow between parameters and results. They differ from normal function literals in that their types are context function types.

For example, continuing with the previous definitions,

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def g(arg: Executable[Int]) = ...
</span><span id="1" class="" >
</span><span id="2" class="" >  g(22)      // is expanded to g((ev: ExecutionContext) ?=&gt; 22)
</span><span id="3" class="" >
</span><span id="4" class="" >  g(f(2))    // is expanded to g((ev: ExecutionContext) ?=&gt; f(2)(using ev))
</span><span id="5" class="" >
</span><span id="6" class="" >  g((ctx: ExecutionContext) ?=&gt; f(3))  // is expanded to g((ctx: ExecutionContext) ?=&gt; f(3)(using ctx))
</span><span id="7" class="" >  g((ctx: ExecutionContext) ?=&gt; f(3)(using ctx)) // is left as it is
</span></code></pre></div>

### Example: Builder Pattern

Context function types have considerable expressive power. For
instance, here is how they can support the "builder pattern", where
the aim is to construct tables like this:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >table {
</span><span id="1" class="" >    row {
</span><span id="2" class="" >      cell(&quot;top left&quot;)
</span><span id="3" class="" >      cell(&quot;top right&quot;)
</span><span id="4" class="" >    }
</span><span id="5" class="" >    row {
</span><span id="6" class="" >      cell(&quot;bottom left&quot;)
</span><span id="7" class="" >      cell(&quot;bottom right&quot;)
</span><span id="8" class="" >    }
</span><span id="9" class="" >  }
</span></code></pre></div>

The idea is to define classes for `Table` and `Row` that allow the
addition of elements via `add`:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class Table:
</span><span id="1" class="" >    val rows = new ArrayBuffer[Row]
</span><span id="2" class="" >    def add(r: Row): Unit = rows += r
</span><span id="3" class="" >    override def toString = rows.mkString(&quot;Table(&quot;, &quot;, &quot;, &quot;)&quot;)
</span><span id="4" class="" >
</span><span id="5" class="" >  class Row:
</span><span id="6" class="" >    val cells = new ArrayBuffer[Cell]
</span><span id="7" class="" >    def add(c: Cell): Unit = cells += c
</span><span id="8" class="" >    override def toString = cells.mkString(&quot;Row(&quot;, &quot;, &quot;, &quot;)&quot;)
</span><span id="9" class="" >
</span><span id="10" class="" >  case class Cell(elem: String)
</span></code></pre></div>

Then, the `table`, `row` and `cell` constructor methods can be defined
with context function types as parameters to avoid the plumbing boilerplate
that would otherwise be necessary.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def table(init: Table ?=&gt; Unit) =
</span><span id="1" class="" >    given t: Table = Table()
</span><span id="2" class="" >    init
</span><span id="3" class="" >    t
</span><span id="4" class="" >
</span><span id="5" class="" >  def row(init: Row ?=&gt; Unit)(using t: Table) =
</span><span id="6" class="" >     given r: Row = Row()
</span><span id="7" class="" >     init
</span><span id="8" class="" >     t.add(r)
</span><span id="9" class="" >
</span><span id="10" class="" >  def cell(str: String)(using r: Row) =
</span><span id="11" class="" >     r.add(new Cell(str))
</span></code></pre></div>

With that setup, the table construction code above compiles and expands to:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >table { ($t: Table) ?=&gt;
</span><span id="1" class="" >
</span><span id="2" class="" >    row { ($r: Row) ?=&gt;
</span><span id="3" class="" >      cell(&quot;top left&quot;)(using $r)
</span><span id="4" class="" >      cell(&quot;top right&quot;)(using $r)
</span><span id="5" class="" >    }(using $t)
</span><span id="6" class="" >
</span><span id="7" class="" >    row { ($r: Row) ?=&gt;
</span><span id="8" class="" >      cell(&quot;bottom left&quot;)(using $r)
</span><span id="9" class="" >      cell(&quot;bottom right&quot;)(using $r)
</span><span id="10" class="" >    }(using $t)
</span><span id="11" class="" >  }
</span></code></pre></div>

### Example: Postconditions

As a larger example, here is a way to define constructs for checking arbitrary postconditions using an extension method `ensuring` so that the checked result can be referred to simply by `result`. The example combines opaque type aliases, context function types, and extension methods to provide a zero-overhead abstraction.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object PostConditions:
</span><span id="1" class="" >  opaque type WrappedResult[T] = T
</span><span id="2" class="" >
</span><span id="3" class="" >  def result[T](using r: WrappedResult[T]): T = r
</span><span id="4" class="" >
</span><span id="5" class="" >  extension [T](x: T)
</span><span id="6" class="" >    def ensuring(condition: WrappedResult[T] ?=&gt; Boolean): T =
</span><span id="7" class="" >      assert(condition(using x))
</span><span id="8" class="" >      x
</span><span id="9" class="" >end PostConditions
</span><span id="10" class="" >import PostConditions.{ensuring, result}
</span><span id="11" class="" >
</span><span id="12" class="" >val s = List(1, 2, 3).sum.ensuring(result == 6)
</span></code></pre></div>

**Explanations**: We use a context function type `WrappedResult[T] ?=> Boolean`
as the type of the condition of `ensuring`. An argument to `ensuring` such as
`(result == 6)` will therefore have a given of type `WrappedResult[T]` in
scope to pass along to the `result` method. `WrappedResult` is a fresh type, to make sure
that we do not get unwanted givens in scope (this is good practice in all cases
where context parameters are involved). Since `WrappedResult` is an opaque type alias, its
values need not be boxed, and since `ensuring` is added as an extension method, its argument
does not need boxing either. Hence, the implementation of `ensuring` is close in efficiency to the best possible code one could write by hand:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val s =
</span><span id="1" class="" >  val result = List(1, 2, 3).sum
</span><span id="2" class="" >  assert(result == 6)
</span><span id="3" class="" >  result
</span></code></pre></div>

### Reference

For more information, see the [blog article](https://www.scala-lang.org/blog/2016/12/07/implicit-function-types.html),
(which uses a different syntax that has been superseded).

[More details](./context-functions-spec.html)
