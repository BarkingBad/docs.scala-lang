---
title: "Importing Givens"
next-page: /scala3/reference/contextual/extension-methods
num: 18
type: section
previous-page: /scala3/reference/contextual/context-bounds
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

A special form of import wildcard selector is used to import given instances. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object A:
</span><span id="1" class="" >  class TC
</span><span id="2" class="" >  given tc: TC = ???
</span><span id="3" class="" >  def f(using TC) = ???
</span><span id="4" class="" >
</span><span id="5" class="" >object B:
</span><span id="6" class="" >  import A.*
</span><span id="7" class="" >  import A.given
</span><span id="8" class="" >  ...
</span></code></pre></div>

In the code above, the `import A.*` clause in object `B` imports all members
of `A` _except_ the given instance `tc`. Conversely, the second import `import A.given` will import _only_ that given instance.
The two import clauses can also be merged into one:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object B:
</span><span id="1" class="" >  import A.{given, *}
</span><span id="2" class="" >   ...
</span></code></pre></div>

Generally, a normal wildcard selector `*` brings all definitions other than givens or extensions into scope
whereas a `given` selector brings all givens (including those resulting from extensions) into scope.

There are two main benefits arising from these rules:

- It is made clearer where givens in scope are coming from.
  In particular, it is not possible to hide imported givens in a long list of regular wildcard imports.
- It enables importing all givens
  without importing anything else. This is particularly important since givens
  can be anonymous, so the usual recourse of using named imports is not
  practical.

### Importing By Type

Since givens can be anonymous it is not always practical to import them by their name, and wildcard imports are typically used instead. By-type imports provide a more specific alternative to wildcard imports, which makes it clearer what is imported. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import A.given TC
</span></code></pre></div>

This imports any given in `A` that has a type which conforms to `TC`. Importing givens of several types `T1,...,Tn`
is expressed by multiple `given` selectors.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import A.{given T1, ..., given Tn}
</span></code></pre></div>

Importing all given instances of a parameterized type is expressed by wildcard arguments.
For instance, assuming the object

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object Instances:
</span><span id="1" class="" >  given intOrd: Ordering[Int] = ...
</span><span id="2" class="" >  given listOrd[T: Ordering]: Ordering[List[T]] = ...
</span><span id="3" class="" >  given ec: ExecutionContext = ...
</span><span id="4" class="" >  given im: Monoid[Int] = ...
</span></code></pre></div>

the import clause

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import Instances.{given Ordering[?], given ExecutionContext}
</span></code></pre></div>

would import the `intOrd`, `listOrd`, and `ec` instances but leave out the `im` instance, since it fits none of the specified bounds.

By-type imports can be mixed with by-name imports. If both are present in an import clause, by-type imports come last. For instance, the import clause

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import Instances.{im, given Ordering[?]}
</span></code></pre></div>

would import `im`, `intOrd`, and `listOrd` but leave out `ec`.

### Migration

The rules for imports stated above have the consequence that a library
would have to migrate in lockstep with all its users from old style implicits and
normal imports to givens and given imports.

The following modifications avoid this hurdle to migration.

1. A `given` import selector also brings old style implicits into scope. So, in Scala 3.0
   an old-style implicit definition can be brought into scope either by a `*` or a `given` wildcard selector.

2. In Scala 3.1, old-style implicits accessed through a `*` wildcard import will give a deprecation warning.

3. In some version after 3.1, old-style implicits accessed through a `*` wildcard import will give a compiler error.

These rules mean that library users can use `given` selectors to access old-style implicits in Scala 3.0,
and will be gently nudged and then forced to do so in later versions. Libraries can then switch to
given instances once their user base has migrated.

### Syntax

```
Import            ::=  ‘import’ ImportExpr {‘,’ ImportExpr}
Export            ::=  ‘export’ ImportExpr {‘,’ ImportExpr}
ImportExpr        ::=  SimpleRef {‘.’ id} ‘.’ ImportSpec
ImportSpec        ::=  NamedSelector
                    |  WildcardSelector
                    | ‘{’ ImportSelectors) ‘}’
NamedSelector     ::=  id [‘as’ (id | ‘_’)]
WildCardSelector  ::=  ‘*' | ‘given’ [InfixType]
ImportSelectors   ::=  NamedSelector [‘,’ ImportSelectors]
                    |  WildCardSelector {‘,’ WildCardSelector}
```

