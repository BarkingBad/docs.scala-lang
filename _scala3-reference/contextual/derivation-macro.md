---
layout: singlepage-overview
title: "How to write a type class `derived` method using macros"
scala3: true
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/contextual/derivation-macro.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

In the main [derivation](./derivation.html) documentation page, we explained the
details behind `Mirror`s and type class derivation. Here we demonstrate how to
implement a type class `derived` method using macros only. We follow the same
example of deriving `Eq` instances and for simplicity we support a `Product`
type e.g., a case class `Person`. The low-level method we will use to implement
the `derived` method exploits quotes, splices of both expressions and types and
the `scala.quoted.Expr.summon` method which is the equivalent of
`summonFrom`. The former is suitable for use in a quote context, used within
macros.

As in the original code, the type class definition is the same:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Eq[T]:
</span><span id="1" class="" >  def eqv(x: T, y: T): Boolean
</span></code></pre></div>

we need to implement a method `Eq.derived` on the companion object of `Eq` that
produces a quoted instance for `Eq[T]`. Here is a possible signature,

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given derived[T: Type](using Quotes): Expr[Eq[T]]
</span></code></pre></div>

and for comparison reasons we give the same signature we had with `inline`:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >inline given derived[T]: (m: Mirror.Of[T]) =&gt; Eq[T] = ???
</span></code></pre></div>

Note, that since a type is used in a subsequent stage it will need to be lifted
to a `Type` by using the corresponding context bound. Also, not that we can
summon the quoted `Mirror` inside the body of the `derived` this we can omit it
from the signature. The body of the `derived` method is shown below:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given derived[T: Type](using Quotes): Expr[Eq[T]] =
</span><span id="1" class="" >  import quotes.reflect.*
</span><span id="2" class="" >
</span><span id="3" class="" >  val ev: Expr[Mirror.Of[T]] = Expr.summon[Mirror.Of[T]].get
</span><span id="4" class="" >
</span><span id="5" class="" >  ev match
</span><span id="6" class="" >    case &apos;{ $m: Mirror.ProductOf[T] { type MirroredElemTypes = elementTypes }} =&gt;
</span><span id="7" class="" >      val elemInstances = summonAll[elementTypes]
</span><span id="8" class="" >      val eqProductBody: (Expr[T], Expr[T]) =&gt; Expr[Boolean] = (x, y) =&gt;
</span><span id="9" class="" >        elemInstances.zipWithIndex.foldLeft(Expr(true: Boolean)) {
</span><span id="10" class="" >          case (acc, (elem, index)) =&gt;
</span><span id="11" class="" >            val e1 = &apos;{$x.asInstanceOf[Product].productElement(${Expr(index)})}
</span><span id="12" class="" >            val e2 = &apos;{$y.asInstanceOf[Product].productElement(${Expr(index)})}
</span><span id="13" class="" >            &apos;{ $acc &amp;&amp; $elem.asInstanceOf[Eq[Any]].eqv($e1, $e2) }
</span><span id="14" class="" >        }
</span><span id="15" class="" >
</span><span id="16" class="" >      &apos;{ eqProduct((x: T, y: T) =&gt; ${eqProductBody(&apos;x, &apos;y)}) }
</span><span id="17" class="" >
</span><span id="18" class="" >  // case for Mirror.ProductOf[T]
</span><span id="19" class="" >  // ...
</span></code></pre></div>

Note, that in the `inline` case we can merely write
`summonAll[m.MirroredElemTypes]` inside the inline method but here, since
`Expr.summon` is required, we can extract the element types in a macro fashion.
Being inside a macro, our first reaction would be to write the code below. Since
the path inside the type argument is not stable this cannot be used:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >&apos;{
</span><span id="1" class="" >  summonAll[$m.MirroredElemTypes]
</span><span id="2" class="" >}
</span></code></pre></div>

Instead we extract the tuple-type for element types using pattern matching over
quotes and more specifically of the refined type:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case &apos;{ $m: Mirror.ProductOf[T] { type MirroredElemTypes = elementTypes }} =&gt; ...
</span></code></pre></div>

Shown below is the implementation of `summonAll` as a macro. We assume that
given instances for our primitive types exist.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def summonAll[T: Type](using Quotes): List[Expr[Eq[_]]] =
</span><span id="1" class="" >   Type.of[T] match
</span><span id="2" class="" >      case &apos;[String *: tpes] =&gt; &apos;{ summon[Eq[String]] } :: summonAll[tpes]
</span><span id="3" class="" >      case &apos;[Int *: tpes]    =&gt; &apos;{ summon[Eq[Int]] }    :: summonAll[tpes]
</span><span id="4" class="" >      case &apos;[tpe *: tpes]    =&gt; derived[tpe] :: summonAll[tpes]
</span><span id="5" class="" >      case &apos;[EmptyTuple]     =&gt; Nil
</span></code></pre></div>

One additional difference with the body of `derived` here as opposed to the one
with `inline` is that with macros we need to synthesize the body of the code during the
macro-expansion time. That is the rationale behind the `eqProductBody` function.
Assuming that we calculate the equality of two `Person`s defined with a case
class that holds a name of type [`String`](https://scala-lang.org/api/3.x/scala/Predef$.html#String-0)
and an age of type `Int`, the equality check we want to generate is the following:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >true
</span><span id="1" class="" >   &amp;&amp; Eq[String].eqv(x.productElement(0),y.productElement(0))
</span><span id="2" class="" >   &amp;&amp; Eq[Int].eqv(x.productElement(1), y.productElement(1))
</span></code></pre></div>

## Calling the derived method inside the macro

Following the rules in [Macros](../metaprogramming.html) we create two methods.
One that hosts the top-level splice `eqv` and one that is the implementation.
Alternatively and what is shown below is that we can call the `eqv` method
directly. The `eqGen` can trigger the derivation.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >extension [T](inline x: T)
</span><span id="1" class="" >   inline def === (inline y: T)(using eq: Eq[T]): Boolean = eq.eqv(x, y)
</span><span id="2" class="" >
</span><span id="3" class="" >inline given eqGen[T]: Eq[T] = ${ Eq.derived[T] }
</span></code></pre></div>

Note, that we use inline method syntax and we can compare instance such as
`Sm(Person("Test", 23)) === Sm(Person("Test", 24))` for e.g., the following two
types:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case class Person(name: String, age: Int)
</span><span id="1" class="" >
</span><span id="2" class="" >enum Opt[+T]:
</span><span id="3" class="" >   case Sm(t: T)
</span><span id="4" class="" >   case Nn
</span></code></pre></div>

The full code is shown below:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.deriving.*
</span><span id="1" class="" >import scala.quoted.*
</span><span id="2" class="" >
</span><span id="3" class="" >
</span><span id="4" class="" >trait Eq[T]:
</span><span id="5" class="" >   def eqv(x: T, y: T): Boolean
</span><span id="6" class="" >
</span><span id="7" class="" >object Eq:
</span><span id="8" class="" >   given Eq[String] with
</span><span id="9" class="" >      def eqv(x: String, y: String) = x == y
</span><span id="10" class="" >
</span><span id="11" class="" >   given Eq[Int] with
</span><span id="12" class="" >      def eqv(x: Int, y: Int) = x == y
</span><span id="13" class="" >
</span><span id="14" class="" >   def eqProduct[T](body: (T, T) =&gt; Boolean): Eq[T] =
</span><span id="15" class="" >      new Eq[T]:
</span><span id="16" class="" >         def eqv(x: T, y: T): Boolean = body(x, y)
</span><span id="17" class="" >
</span><span id="18" class="" >   def eqSum[T](body: (T, T) =&gt; Boolean): Eq[T] =
</span><span id="19" class="" >      new Eq[T]:
</span><span id="20" class="" >         def eqv(x: T, y: T): Boolean = body(x, y)
</span><span id="21" class="" >
</span><span id="22" class="" >   def summonAll[T: Type](using Quotes): List[Expr[Eq[_]]] =
</span><span id="23" class="" >      Type.of[T] match
</span><span id="24" class="" >         case &apos;[String *: tpes] =&gt; &apos;{ summon[Eq[String]] } :: summonAll[tpes]
</span><span id="25" class="" >         case &apos;[Int *: tpes]    =&gt; &apos;{ summon[Eq[Int]] }    :: summonAll[tpes]
</span><span id="26" class="" >         case &apos;[tpe *: tpes]    =&gt; derived[tpe] :: summonAll[tpes]
</span><span id="27" class="" >         case &apos;[EmptyTuple]     =&gt; Nil
</span><span id="28" class="" >
</span><span id="29" class="" >   given derived[T: Type](using q: Quotes): Expr[Eq[T]] =
</span><span id="30" class="" >      import quotes.reflect.*
</span><span id="31" class="" >
</span><span id="32" class="" >      val ev: Expr[Mirror.Of[T]] = Expr.summon[Mirror.Of[T]].get
</span><span id="33" class="" >
</span><span id="34" class="" >      ev match
</span><span id="35" class="" >         case &apos;{ $m: Mirror.ProductOf[T] { type MirroredElemTypes = elementTypes }} =&gt;
</span><span id="36" class="" >            val elemInstances = summonAll[elementTypes]
</span><span id="37" class="" >            val eqProductBody: (Expr[T], Expr[T]) =&gt; Expr[Boolean] = (x, y) =&gt;
</span><span id="38" class="" >               elemInstances.zipWithIndex.foldLeft(Expr(true: Boolean)) {
</span><span id="39" class="" >                  case (acc, (elem, index)) =&gt;
</span><span id="40" class="" >                     val e1 = &apos;{$x.asInstanceOf[Product].productElement(${Expr(index)})}
</span><span id="41" class="" >                     val e2 = &apos;{$y.asInstanceOf[Product].productElement(${Expr(index)})}
</span><span id="42" class="" >
</span><span id="43" class="" >                     &apos;{ $acc &amp;&amp; $elem.asInstanceOf[Eq[Any]].eqv($e1, $e2) }
</span><span id="44" class="" >               }
</span><span id="45" class="" >            &apos;{ eqProduct((x: T, y: T) =&gt; ${eqProductBody(&apos;x, &apos;y)}) }
</span><span id="46" class="" >
</span><span id="47" class="" >         case &apos;{ $m: Mirror.SumOf[T] { type MirroredElemTypes = elementTypes }} =&gt;
</span><span id="48" class="" >            val elemInstances = summonAll[elementTypes]
</span><span id="49" class="" >            val eqSumBody: (Expr[T], Expr[T]) =&gt; Expr[Boolean] = (x, y) =&gt;
</span><span id="50" class="" >               val ordx = &apos;{ $m.ordinal($x) }
</span><span id="51" class="" >               val ordy = &apos;{ $m.ordinal($y) }
</span><span id="52" class="" >
</span><span id="53" class="" >               val elements = Expr.ofList(elemInstances)
</span><span id="54" class="" >               &apos;{ $ordx == $ordy &amp;&amp; $elements($ordx).asInstanceOf[Eq[Any]].eqv($x, $y) }
</span><span id="55" class="" >
</span><span id="56" class="" >         &apos;{ eqSum((x: T, y: T) =&gt; ${eqSumBody(&apos;x, &apos;y)}) }
</span><span id="57" class="" >   end derived
</span><span id="58" class="" >end Eq
</span><span id="59" class="" >
</span><span id="60" class="" >object Macro3:
</span><span id="61" class="" >   extension [T](inline x: T)
</span><span id="62" class="" >      inline def === (inline y: T)(using eq: Eq[T]): Boolean = eq.eqv(x, y)
</span><span id="63" class="" >
</span><span id="64" class="" >   inline given eqGen[T]: Eq[T] = ${ Eq.derived[T] }
</span></code></pre></div>
