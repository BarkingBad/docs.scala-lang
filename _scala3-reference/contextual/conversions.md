---
title: "Implicit Conversions"
next-page: /scala3/reference/contextual/by-name-context-parameters
num: 24
type: section
previous-page: /scala3/reference/contextual/context-functions
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

Implicit conversions are defined by given instances of the `scala.Conversion` class.
This class is defined in package `scala` as follows:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >abstract class Conversion[-T, +U] extends (T =&gt; U):
</span><span id="1" class="" >  def apply (x: T): U
</span></code></pre></div>

For example, here is an implicit conversion from `String` to `Token`:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given Conversion[String, Token] with
</span><span id="1" class="" >  def apply(str: String): Token = new KeyWord(str)
</span></code></pre></div>

Using an alias this can be expressed more concisely as:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given Conversion[String, Token] = new KeyWord(_)
</span></code></pre></div>

An implicit conversion is applied automatically by the compiler in three situations:

1. If an expression `e` has type `T`, and `T` does not conform to the expression's expected type `S`.
2. In a selection `e.m` with `e` of type `T`, but `T` defines no member `m`.
3. In an application `e.m(args)` with `e` of type `T`, if `T` does define
   some member(s) named `m`, but none of these members can be applied to the arguments `args`.

In the first case, the compiler looks for a given `scala.Conversion` instance that maps
an argument of type `T` to type `S`. In the second and third
case, it looks for a given `scala.Conversion` instance that maps an argument of type `T`
to a type that defines a member `m` which can be applied to `args` if present.
If such an instance `C` is found, the expression `e` is replaced by `C.apply(e)`.

## Examples

1. The `Predef` package contains "auto-boxing" conversions that map
   primitive number types to subclasses of `java.lang.Number`. For instance, the
   conversion from `Int` to `java.lang.Integer` can be defined as follows:

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given int2Integer: Conversion[Int, java.lang.Integer] =
   </span><span id="1" class="" >  java.lang.Integer.valueOf(_)
   </span></code></pre></div>2. The "magnet" pattern is sometimes used to express many variants of a method. Instead of defining overloaded versions of the method, one can also let the method take one or more arguments of specially defined "magnet" types, into which various argument types can be converted. Example:

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object Completions:
   </span><span id="1" class="" >
   </span><span id="2" class="" >  // The argument &quot;magnet&quot; type
   </span><span id="3" class="" >  enum CompletionArg:
   </span><span id="4" class="" >    case Error(s: String)
   </span><span id="5" class="" >    case Response(f: Future[HttpResponse])
   </span><span id="6" class="" >    case Status(code: Future[StatusCode])
   </span><span id="7" class="" >
   </span><span id="8" class="" >  object CompletionArg:
   </span><span id="9" class="" >
   </span><span id="10" class="" >    // conversions defining the possible arguments to pass to `complete`
   </span><span id="11" class="" >    // these always come with CompletionArg
   </span><span id="12" class="" >    // They can be invoked explicitly, e.g.
   </span><span id="13" class="" >    //
   </span><span id="14" class="" >    //   CompletionArg.fromStatusCode(statusCode)
   </span><span id="15" class="" >
   </span><span id="16" class="" >    given fromString    : Conversion[String, CompletionArg]               = Error(_)
   </span><span id="17" class="" >    given fromFuture    : Conversion[Future[HttpResponse], CompletionArg] = Response(_)
   </span><span id="18" class="" >    given fromStatusCode: Conversion[Future[StatusCode], CompletionArg]   = Status(_)
   </span><span id="19" class="" >  end CompletionArg
   </span><span id="20" class="" >  import CompletionArg.*
   </span><span id="21" class="" >
   </span><span id="22" class="" >  def complete[T](arg: CompletionArg) = arg match
   </span><span id="23" class="" >    case Error(s) =&gt; ...
   </span><span id="24" class="" >    case Response(f) =&gt; ...
   </span><span id="25" class="" >    case Status(code) =&gt; ...
   </span><span id="26" class="" >
   </span><span id="27" class="" >end Completions
   </span></code></pre></div>

This setup is more complicated than simple overloading of `complete`, but it can still be useful if normal overloading is not available (as in the case above, since we cannot have two overloaded methods that take `Future[...]` arguments), or if normal overloading would lead to a combinatorial explosion of variants.
