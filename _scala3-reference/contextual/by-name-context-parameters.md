---
title: "By-Name Context Parameters"
next-page: /scala3/reference/contextual/relationship-implicits
num: 25
type: section
previous-page: /scala3/reference/contextual/conversions
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

Context parameters can be declared by-name to avoid a divergent inferred expansion. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Codec[T]:
</span><span id="1" class="" >  def write(x: T): Unit
</span><span id="2" class="" >
</span><span id="3" class="" >given intCodec: Codec[Int] = ???
</span><span id="4" class="" >
</span><span id="5" class="" >given optionCodec[T](using ev: =&gt; Codec[T]): Codec[Option[T]] with
</span><span id="6" class="" >  def write(xo: Option[T]) = xo match
</span><span id="7" class="" >    case Some(x) =&gt; ev.write(x)
</span><span id="8" class="" >    case None =&gt;
</span><span id="9" class="" >
</span><span id="10" class="" >val s = summon[Codec[Option[Int]]]
</span><span id="11" class="" >
</span><span id="12" class="" >s.write(Some(33))
</span><span id="13" class="" >s.write(None)
</span></code></pre></div>

As is the case for a normal by-name parameter, the argument for the context parameter `ev`
is evaluated on demand. In the example above, if the option value `x` is `None`, it is
not evaluated at all.

The synthesized argument for a context parameter is backed by a local val
if this is necessary to prevent an otherwise diverging expansion.

The precise steps for synthesizing an argument for a by-name context parameter of type `=> T` are as follows.

1. Create a new given of type `T`:

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given lv: T = ???
   </span></code></pre></div>

   where `lv` is an arbitrary fresh name.

2. This given is not immediately available as candidate for argument inference (making it immediately available could result in a loop in the synthesized computation). But it becomes available in all nested contexts that look again for an argument to a by-name context parameter.

3. If this search succeeds with expression `E`, and `E` contains references to `lv`, replace `E` by

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >{ given lv: T = E; lv }
   </span></code></pre></div>

   Otherwise, return `E` unchanged.

In the example above, the definition of `s` would be expanded as follows.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val s = summon[Test.Codec[Option[Int]]](
</span><span id="1" class="" >  optionCodec[Int](using intCodec)
</span><span id="2" class="" >)
</span></code></pre></div>

No local given instance was generated because the synthesized argument is not recursive.

### Reference

For more information, see [Issue #1998](https://github.com/lampepfl/dotty/issues/1998)
and the associated [Scala SIP](https://docs.scala-lang.org/sips/byname-implicits.html).
