---
title: "Implementing Type classes"
next-page: /scala3/reference/contextual/derivation
num: 20
type: section
previous-page: /scala3/reference/contextual/extension-methods
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/contextual/type-classes.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

A _type class_ is an abstract, parameterized type that lets you add new behavior to any closed data type without using sub-typing. This can be useful in multiple use-cases, for example:

* expressing how a type you don't own (from the standard or 3rd-party library) conforms to such behavior
* expressing such a behavior for multiple types without involving sub-typing relationships (one `extends` another) between those types (see: [ad hoc polymorphism](https://en.wikipedia.org/wiki/Ad_hoc_polymorphism) for instance)

Therefore in Scala 3, _type classes_ are just _traits_ with one or more parameters whose implementations are not defined through the `extends` keyword, but by **given instances**.
Here are some examples of common type classes:

### Semigroups and monoids

Here's the `Monoid` type class definition:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait SemiGroup[T]:
</span><span id="1" class="" >  extension (x: T) def combine (y: T): T
</span><span id="2" class="" >
</span><span id="3" class="" >trait Monoid[T] extends SemiGroup[T]:
</span><span id="4" class="" >  def unit: T
</span></code></pre></div>

An implementation of this `Monoid` type class for the type `String` can be the following:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given Monoid[String] with
</span><span id="1" class="" >  extension (x: String) def combine (y: String): String = x.concat(y)
</span><span id="2" class="" >  def unit: String = &quot;&quot;
</span></code></pre></div>

Whereas for the type `Int` one could write the following:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given Monoid[Int] with
</span><span id="1" class="" >  extension (x: Int) def combine (y: Int): Int = x + y
</span><span id="2" class="" >  def unit: Int = 0
</span></code></pre></div>

This monoid can now be used as _context bound_ in the following `combineAll` method:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def combineAll[T: Monoid](xs: List[T]): T =
</span><span id="1" class="" >  xs.foldLeft(summon[Monoid[T]].unit)(_.combine(_))
</span></code></pre></div>

To get rid of the `summon[...]` we can define a `Monoid` object as follows:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object Monoid:
</span><span id="1" class="" >  def apply[T](using m: Monoid[T]) = m
</span></code></pre></div>

Which would allow to re-write the `combineAll` method this way:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def combineAll[T: Monoid](xs: List[T]): T =
</span><span id="1" class="" >  xs.foldLeft(Monoid[T].unit)(_.combine(_))
</span></code></pre></div>

### Functors

A `Functor` for a type provides the ability for its values to be "mapped over", i.e. apply a function that transforms inside a value while remembering its shape. For example, to modify every element of a collection without dropping or adding elements.
We can represent all types that can be "mapped over" with `F`. It's a type constructor: the type of its values becomes concrete when provided a type argument.
Therefore we write it `F[_]`, hinting that the type `F` takes another type as argument.
The definition of a generic `Functor` would thus be written as:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Functor[F[_]]:
</span><span id="1" class="" >  def map[A, B](x: F[A], f: A =&gt; B): F[B]
</span></code></pre></div>

Which could read as follows: "A `Functor` for the type constructor `F[_]` represents the ability to transform `F[A]` to `F[B]` through the application of function `f` with type `A => B`". We call the `Functor` definition here a _type class_.
This way, we could define an instance of `Functor` for the `List` type:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given Functor[List] with
</span><span id="1" class="" >  def map[A, B](x: List[A], f: A =&gt; B): List[B] =
</span><span id="2" class="" >    x.map(f) // List already has a `map` method
</span></code></pre></div>

With this `given` instance in scope, everywhere a `Functor` is expected, the compiler will accept a `List` to be used.

For instance, we may write such a testing method:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def assertTransformation[F[_]: Functor, A, B](expected: F[B], original: F[A], mapping: A =&gt; B): Unit =
</span><span id="1" class="" >  assert(expected == summon[Functor[F]].map(original, mapping))
</span></code></pre></div>

And use it this way, for example:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >assertTransformation(List(&quot;a1&quot;, &quot;b1&quot;), List(&quot;a&quot;, &quot;b&quot;), elt =&gt; s&quot;${elt}1&quot;)
</span></code></pre></div>

That's a first step, but in practice we probably would like the `map` function to be a method directly accessible on the type `F`. So that we can call `map` directly on instances of `F`, and get rid of the `summon[Functor[F]]` part.
As in the previous example of Monoids, [`extension` methods](extension-methods.html) help achieving that. Let's re-define the `Functor` type class with extension methods.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Functor[F[_]]:
</span><span id="1" class="" >  extension [A](x: F[A])
</span><span id="2" class="" >    def map[B](f: A =&gt; B): F[B]
</span></code></pre></div>

The instance of `Functor` for `List` now becomes:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given Functor[List] with
</span><span id="1" class="" >  extension [A](xs: List[A])
</span><span id="2" class="" >    def map[B](f: A =&gt; B): List[B] =
</span><span id="3" class="" >      xs.map(f) // List already has a `map` method
</span></code></pre></div>

It simplifies the `assertTransformation` method:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def assertTransformation[F[_]: Functor, A, B](expected: F[B], original: F[A], mapping: A =&gt; B): Unit =
</span><span id="1" class="" >  assert(expected == original.map(mapping))
</span></code></pre></div>

The `map` method is now directly used on `original`. It is available as an extension method
since `original`'s type is `F[A]` and a given instance for `Functor[F[A]]` which defines `map`
is in scope.

### Monads

Applying `map` in `Functor[List]` to a mapping function of type `A => B` results in a `List[B]`. So applying it to a mapping function of type `A => List[B]` results in a `List[List[B]]`. To avoid managing lists of lists, we may want to "flatten" the values in a single list.

That's where `Monad` comes in. A `Monad` for type `F[_]` is a `Functor[F]` with two more operations:

* `flatMap`, which turns an `F[A]` into an `F[B]` when given a function of type `A => F[B]`,
* `pure`, which creates an `F[A]` from a single value `A`.

Here is the translation of this definition in Scala 3:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Monad[F[_]] extends Functor[F]:
</span><span id="1" class="" >
</span><span id="2" class="" >  /** The unit value for a monad */
</span><span id="3" class="" >  def pure[A](x: A): F[A]
</span><span id="4" class="" >
</span><span id="5" class="" >  extension [A](x: F[A])
</span><span id="6" class="" >    /** The fundamental composition operation */
</span><span id="7" class="" >    def flatMap[B](f: A =&gt; F[B]): F[B]
</span><span id="8" class="" >
</span><span id="9" class="" >    /** The `map` operation can now be defined in terms of `flatMap` */
</span><span id="10" class="" >    def map[B](f: A =&gt; B) = x.flatMap(f.andThen(pure))
</span><span id="11" class="" >
</span><span id="12" class="" >end Monad
</span></code></pre></div>

#### List

A `List` can be turned into a monad via this `given` instance:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given listMonad: Monad[List] with
</span><span id="1" class="" >  def pure[A](x: A): List[A] =
</span><span id="2" class="" >    List(x)
</span><span id="3" class="" >  extension [A](xs: List[A])
</span><span id="4" class="" >    def flatMap[B](f: A =&gt; List[B]): List[B] =
</span><span id="5" class="" >      xs.flatMap(f) // rely on the existing `flatMap` method of `List`
</span></code></pre></div>

Since `Monad` is a subtype of `Functor`, `List` is also a functor. The Functor's `map`
operation is already provided by the `Monad` trait, so the instance does not need to define
it explicitly.

#### Option

`Option` is an other type having the same kind of behaviour:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given optionMonad: Monad[Option] with
</span><span id="1" class="" >  def pure[A](x: A): Option[A] =
</span><span id="2" class="" >    Option(x)
</span><span id="3" class="" >  extension [A](xo: Option[A])
</span><span id="4" class="" >    def flatMap[B](f: A =&gt; Option[B]): Option[B] = xo match
</span><span id="5" class="" >      case Some(x) =&gt; f(x)
</span><span id="6" class="" >      case None =&gt; None
</span></code></pre></div>

#### Reader

Another example of a `Monad` is the _Reader_ Monad, which acts on functions instead of
data types like `List` or `Option`. It can be used to combine multiple functions
that all need the same parameter. For instance multiple functions needing access to some configuration, context, environment variables, etc.

Let's define a `Config` type, and two functions using it:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Config
</span><span id="1" class="" >// ...
</span><span id="2" class="" >def compute(i: Int)(config: Config): String = ???
</span><span id="3" class="" >def show(str: String)(config: Config): Unit = ???
</span></code></pre></div>

We may want to combine `compute` and `show` into a single function, accepting a `Config` as parameter, and showing the result of the computation, and we'd like to use
a monad to avoid passing the parameter explicitly multiple times. So postulating
the right `flatMap` operation, we could write:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def computeAndShow(i: Int): Config =&gt; Unit = compute(i).flatMap(show)
</span></code></pre></div>

instead of

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >show(compute(i)(config))(config)
</span></code></pre></div>

Let's define this m then. First, we are going to define a type named `ConfigDependent` representing a function that when passed a `Config` produces a `Result`.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type ConfigDependent[Result] = Config =&gt; Result
</span></code></pre></div>

The monad instance will look like this:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given configDependentMonad: Monad[ConfigDependent] with
</span><span id="1" class="" >
</span><span id="2" class="" >  def pure[A](x: A): ConfigDependent[A] =
</span><span id="3" class="" >    config =&gt; x
</span><span id="4" class="" >
</span><span id="5" class="" >  extension [A](x: ConfigDependent[A])
</span><span id="6" class="" >    def flatMap[B](f: A =&gt; ConfigDependent[B]): ConfigDependent[B] =
</span><span id="7" class="" >      config =&gt; f(x(config))(config)
</span><span id="8" class="" >
</span><span id="9" class="" >end configDependentMonad
</span></code></pre></div>

The type `ConfigDependent` can be written using [type lambdas](../new-types/type-lambdas.html):

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type ConfigDependent = [Result] =&gt;&gt; Config =&gt; Result
</span></code></pre></div>

Using this syntax would turn the previous `configDependentMonad` into:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given configDependentMonad: Monad[[Result] =&gt;&gt; Config =&gt; Result] with
</span><span id="1" class="" >
</span><span id="2" class="" >  def pure[A](x: A): Config =&gt; A =
</span><span id="3" class="" >    config =&gt; x
</span><span id="4" class="" >
</span><span id="5" class="" >  extension [A](x: Config =&gt; A)
</span><span id="6" class="" >    def flatMap[B](f: A =&gt; Config =&gt; B): Config =&gt; B =
</span><span id="7" class="" >      config =&gt; f(x(config))(config)
</span><span id="8" class="" >
</span><span id="9" class="" >end configDependentMonad
</span></code></pre></div>

It is likely that we would like to use this pattern with other kinds of environments than our `Config` trait. The Reader monad allows us to abstract away `Config` as a type _parameter_, named `Ctx` in the following definition:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given readerMonad[Ctx]: Monad[[X] =&gt;&gt; Ctx =&gt; X] with
</span><span id="1" class="" >
</span><span id="2" class="" >  def pure[A](x: A): Ctx =&gt; A =
</span><span id="3" class="" >    ctx =&gt; x
</span><span id="4" class="" >
</span><span id="5" class="" >  extension [A](x: Ctx =&gt; A)
</span><span id="6" class="" >    def flatMap[B](f: A =&gt; Ctx =&gt; B): Ctx =&gt; B =
</span><span id="7" class="" >      ctx =&gt; f(x(ctx))(ctx)
</span><span id="8" class="" >
</span><span id="9" class="" >end readerMonad
</span></code></pre></div>

### Summary

The definition of a _type class_ is expressed with a parameterised type with abstract members, such as a `trait`.
The main difference between subtype polymorphism and ad-hoc polymorphism with _type classes_ is how the definition of the _type class_ is implemented, in relation to the type it acts upon.
In the case of a _type class_, its implementation for a concrete type is expressed through a `given` instance definition, which is supplied as an implicit argument alongside the value it acts upon. With subtype polymorphism, the implementation is mixed into the parents of a class, and only a single term is required to perform a polymorphic operation. The type class solution
takes more effort to set up, but is more extensible: Adding a new interface to a
class requires changing the source code of that class. But contrast, instances for type classes can be defined anywhere.

To conclude, we have seen that traits and given instances, combined with other constructs like extension methods, context bounds and type lambdas allow a concise and natural expression of _type classes_.
