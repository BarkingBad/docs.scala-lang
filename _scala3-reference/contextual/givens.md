---
title: "Given Instances"
next-page: /scala3/reference/contextual/using-clauses
num: 15
type: section
previous-page: /scala3/reference/contextual
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

Given instances (or, simply, "givens") define "canonical" values of certain types
that serve for synthesizing arguments to [context parameters](./using-clauses.html). Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Ord[T]:
</span><span id="1" class="" >  def compare(x: T, y: T): Int
</span><span id="2" class="" >  extension (x: T) def &lt; (y: T) = compare(x, y) &lt; 0
</span><span id="3" class="" >  extension (x: T) def &gt; (y: T) = compare(x, y) &gt; 0
</span><span id="4" class="" >
</span><span id="5" class="" >given intOrd: Ord[Int] with
</span><span id="6" class="" >  def compare(x: Int, y: Int) =
</span><span id="7" class="" >    if x &lt; y then -1 else if x &gt; y then +1 else 0
</span><span id="8" class="" >
</span><span id="9" class="" >given listOrd[T](using ord: Ord[T]): Ord[List[T]] with
</span><span id="10" class="" >
</span><span id="11" class="" >  def compare(xs: List[T], ys: List[T]): Int = (xs, ys) match
</span><span id="12" class="" >    case (Nil, Nil) =&gt; 0
</span><span id="13" class="" >    case (Nil, _) =&gt; -1
</span><span id="14" class="" >    case (_, Nil) =&gt; +1
</span><span id="15" class="" >    case (x :: xs1, y :: ys1) =&gt;
</span><span id="16" class="" >      val fst = ord.compare(x, y)
</span><span id="17" class="" >      if fst != 0 then fst else compare(xs1, ys1)
</span></code></pre></div>

This code defines a trait `Ord` with two given instances. `intOrd` defines
a given for the type `Ord[Int]` whereas `listOrd[T]` defines givens
for `Ord[List[T]]` for all types `T` that come with a given instance for `Ord[T]`
themselves. The `using` clause in `listOrd` defines a condition: There must be a
given of type `Ord[T]` for a given of type `Ord[List[T]]` to exist.
Such conditions are expanded by the compiler to [context parameters](./using-clauses.html).

## Anonymous Givens

The name of a given can be left out. So the definitions
of the last section can also be expressed like this:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given Ord[Int] with
</span><span id="1" class="" >  ...
</span><span id="2" class="" >given [T](using Ord[T]): Ord[List[T]] with
</span><span id="3" class="" >  ...
</span></code></pre></div>

If the name of a given is missing, the compiler will synthesize a name from
the implemented type(s).

**Note** The name synthesized by the compiler is chosen to be readable and reasonably concise. For instance, the two instances above would get the names:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given_Ord_Int
</span><span id="1" class="" >given_Ord_List_T
</span></code></pre></div>

The precise rules for synthesizing names are found [here](./relationship-implicits.html#anonymous-given-instances). These rules do not guarantee absence of name conflicts between
given instances of types that are "too similar". To avoid conflicts one can
use named instances.

**Note** To ensure robust binary compatibility, publicly available libraries should prefer named instances.

## Alias Givens

An alias can be used to define a given instance that is equal to some expression. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given global: ExecutionContext = ForkJoinPool()
</span></code></pre></div>

This creates a given `global` of type `ExecutionContext` that resolves to the right
hand side `ForkJoinPool()`.
The first time `global` is accessed, a new `ForkJoinPool` is created, which is then
returned for this and all subsequent accesses to `global`. This operation is thread-safe.

Alias givens can be anonymous as well, e.g.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given Position = enclosingTree.position
</span><span id="1" class="" >given (using config: Config): Factory = MemoizingFactory(config)
</span></code></pre></div>

An alias given can have type parameters and context parameters just like any other given,
but it can only implement a single type.

## Given Macros

Given aliases can have the `inline` and `transparent` modifiers.
Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >transparent inline given mkAnnotations[A, T]: Annotations[A, T] = ${
</span><span id="1" class="" >  // code producing a value of a subtype of Annotations
</span><span id="2" class="" >}
</span></code></pre></div>

Since `mkAnnotations` is `transparent`, the type of an application is the type of its right-hand side, which can be a proper subtype of the declared result type `Annotations[A, T]`.

## Pattern-Bound Given Instances

Given instances can also appear in patterns. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >for given Context &lt;- applicationContexts do
</span><span id="1" class="" >
</span><span id="2" class="" >pair match
</span><span id="3" class="" >  case (ctx @ given Context, y) =&gt; ...
</span></code></pre></div>

In the first fragment above, anonymous given instances for class `Context` are established by enumerating over `applicationContexts`. In the second fragment, a given `Context`
instance named `ctx` is established by matching against the first half of the `pair` selector.

In each case, a pattern-bound given instance consists of `given` and a type `T`. The pattern matches exactly the same selectors as the type ascription pattern `_: T`.

## Negated Givens

Scala 2's somewhat puzzling behavior with respect to ambiguity has been exploited to implement the analogue of a "negated" search in implicit resolution,
where a query Q1 fails if some other query Q2 succeeds and Q1 succeeds if Q2 fails. With the new cleaned up behavior these techniques no longer work.
But the new special type `scala.util.NotGiven` now implements negation directly.

For any query type `Q`, `NotGiven[Q]` succeeds if and only if the implicit
search for `Q` fails, for example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.util.NotGiven
</span><span id="1" class="" >
</span><span id="2" class="" >trait Tagged[A]
</span><span id="3" class="" >
</span><span id="4" class="" >case class Foo[A](value: Boolean)
</span><span id="5" class="" >object Foo:
</span><span id="6" class="" >  given fooTagged[A](using Tagged[A]): Foo[A] = Foo(true)
</span><span id="7" class="" >  given fooNotTagged[A](using NotGiven[Tagged[A]]): Foo[A] = Foo(false)
</span><span id="8" class="" >
</span><span id="9" class="" >@main def test(): Unit =
</span><span id="10" class="" >  given Tagged[Int]()
</span><span id="11" class="" >  assert(summon[Foo[Int]].value) // fooTagged is found
</span><span id="12" class="" >  assert(!summon[Foo[String]].value) // fooNotTagged is found
</span></code></pre></div>

## Given Instance Initialization

A given instance without type or context parameters is initialized on-demand, the first
time it is accessed. If a given has type or context parameters, a fresh instance
is created for each reference.

## Syntax

Here is the syntax for given instances:

```
TmplDef             ::=  ...
                     |   ‘given’ GivenDef
GivenDef            ::=  [GivenSig] StructuralInstance
                     |   [GivenSig] AnnotType ‘=’ Expr
                     |   [GivenSig] AnnotType
GivenSig            ::=  [id] [DefTypeParamClause] {UsingParamClause} ‘:’
StructuralInstance  ::=  ConstrApp {‘with’ ConstrApp} ‘with’ TemplateBody
```

A given instance starts with the reserved word `given` and an optional _signature_. The signature
defines a name and/or parameters for the instance. It is followed by `:`. There are three kinds
of given instances:

- A _structural instance_ contains one or more types or constructor applications,
  followed by `with` and a template body that contains member definitions of the instance.
- An _alias instance_ contains a type, followed by `=` and a right-hand side expression.
- An _abstract instance_ contains just the type, which is not followed by anything.

