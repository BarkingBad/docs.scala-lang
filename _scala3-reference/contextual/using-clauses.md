---
title: "Using Clauses"
next-page: /scala3/reference/contextual/context-bounds
num: 16
type: section
previous-page: /scala3/reference/contextual/givens
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/contextual/using-clauses.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

Functional programming tends to express most dependencies as simple function parameterization.
This is clean and powerful, but it sometimes leads to functions that take many parameters where the same value is passed over and over again in long call chains to many
functions. Context parameters can help here since they enable the compiler to synthesize
repetitive arguments instead of the programmer having to write them explicitly.

For example, with the [given instances](./givens.html) defined previously,
a `max` function that works for any arguments for which an ordering exists can be defined as follows:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def max[T](x: T, y: T)(using ord: Ord[T]): T =
</span><span id="1" class="" >  if ord.compare(x, y) &lt; 0 then y else x
</span></code></pre></div>

Here, `ord` is a _context parameter_ introduced with a `using` clause.
The `max` function can be applied as follows:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >max(2, 3)(using intOrd)
</span></code></pre></div>

The `(using intOrd)` part passes `intOrd` as an argument for the `ord` parameter. But the point of context parameters is that this argument can also be left out (and it usually is). So the following applications are equally valid:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >max(2, 3)
</span><span id="1" class="" >max(List(1, 2, 3), Nil)
</span></code></pre></div>

## Anonymous Context Parameters

In many situations, the name of a context parameter need not be
mentioned explicitly at all, since it is used only in synthesized arguments for
other context parameters. In that case one can avoid defining a parameter name
and just provide its type. Example:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def maximum[T](xs: List[T])(using Ord[T]): T =
</span><span id="1" class="" >  xs.reduceLeft(max)
</span></code></pre></div>

`maximum` takes a context parameter of type `Ord` only to pass it on as an
inferred argument to `max`. The name of the parameter is left out.

Generally, context parameters may be defined either as a full parameter list `(p_1: T_1, ..., p_n: T_n)` or just as a sequence of types `T_1, ..., T_n`. Vararg parameters are not supported in `using` clauses.

## Class Context Parameters

If a class context parameter is made a member by adding a `val` or `var` modifier,
then that member is available as a given instance.

Compare the following examples, where the attempt to supply an explicit `given` member induces an ambiguity:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class GivenIntBox(using val givenInt: Int):
</span><span id="1" class="" >  def n = summon[Int]
</span><span id="2" class="" >
</span><span id="3" class="" >class GivenIntBox2(using givenInt: Int):
</span><span id="4" class="" >  given Int = givenInt
</span><span id="5" class="" >  //def n = summon[Int]     // ambiguous
</span></code></pre></div>

The `given` member is importable as explained in the section on [importing `given`s](./given-imports.html):

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val b = GivenIntBox(using 23)
</span><span id="1" class="" >import b.given
</span><span id="2" class="" >summon[Int]  // 23
</span><span id="3" class="" >
</span><span id="4" class="" >import b.*
</span><span id="5" class="" >//givenInt   // Not found
</span></code></pre></div>

## Inferring Complex Arguments

Here are two other methods that have a context parameter of type `Ord[T]`:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def descending[T](using asc: Ord[T]): Ord[T] = new Ord[T]:
</span><span id="1" class="" >  def compare(x: T, y: T) = asc.compare(y, x)
</span><span id="2" class="" >
</span><span id="3" class="" >def minimum[T](xs: List[T])(using Ord[T]) =
</span><span id="4" class="" >  maximum(xs)(using descending)
</span></code></pre></div>

The `minimum` method's right-hand side passes `descending` as an explicit argument to `maximum(xs)`.
With this setup, the following calls are all well-formed, and they all normalize to the last one:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >minimum(xs)
</span><span id="1" class="" >maximum(xs)(using descending)
</span><span id="2" class="" >maximum(xs)(using descending(using listOrd))
</span><span id="3" class="" >maximum(xs)(using descending(using listOrd(using intOrd)))
</span></code></pre></div>

## Multiple `using` Clauses

There can be several `using` clauses in a definition and `using` clauses can be freely mixed with normal parameter clauses. Example:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def f(u: Universe)(using ctx: u.Context)(using s: ctx.Symbol, k: ctx.Kind) = ...
</span></code></pre></div>

Multiple `using` clauses are matched left-to-right in applications. Example:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object global extends Universe { type Context = ... }
</span><span id="1" class="" >given ctx : global.Context with { type Symbol = ...; type Kind = ... }
</span><span id="2" class="" >given sym : ctx.Symbol
</span><span id="3" class="" >given kind: ctx.Kind
</span></code></pre></div>

Then the following calls are all valid (and normalize to the last one)

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >f(global)
</span><span id="1" class="" >f(global)(using ctx)
</span><span id="2" class="" >f(global)(using ctx)(using sym, kind)
</span></code></pre></div>

But `f(global)(using sym, kind)` would give a type error.

## Summoning Instances

The method `summon` in `Predef` returns the given of a specific type. For example,
the given instance for `Ord[List[Int]]` is produced by

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >summon[Ord[List[Int]]]  // reduces to listOrd(using intOrd)
</span></code></pre></div>

The `summon` method is simply defined as the (non-widening) identity function over a context parameter.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def summon[T](using x: T): x.type = x
</span></code></pre></div>

## Syntax

Here is the new syntax of parameters and arguments seen as a delta from the [standard context free syntax of Scala 3](../syntax.html). `using` is a soft keyword, recognized only at the start of a parameter or argument list. It can be used as a normal identifier everywhere else.

```
ClsParamClause      ::=  ... | UsingClsParamClause
DefParamClauses     ::=  ... | UsingParamClause
UsingClsParamClause ::=  ‘(’ ‘using’ (ClsParams | Types) ‘)’
UsingParamClause    ::=  ‘(’ ‘using’ (DefParams | Types) ‘)’
ParArgumentExprs    ::=  ... | ‘(’ ‘using’ ExprsInParens ‘)’
```

