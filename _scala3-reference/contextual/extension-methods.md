---
title: "Extension Methods"
next-page: /scala3/reference/contextual/type-classes
num: 19
type: section
previous-page: /scala3/reference/contextual/given-imports
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/contextual/extension-methods.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

Extension methods allow one to add methods to a type after the type is defined. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case class Circle(x: Double, y: Double, radius: Double)
</span><span id="1" class="" >
</span><span id="2" class="" >extension (c: Circle)
</span><span id="3" class="" >  def circumference: Double = c.radius * math.Pi * 2
</span></code></pre></div>

Like regular methods, extension methods can be invoked with infix `.`:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val circle = Circle(0, 0, 1)
</span><span id="1" class="" >circle.circumference
</span></code></pre></div>

### Translation of Extension Methods

An extension method translates to a specially labelled method that takes the leading parameter section as its first argument list. The label, expressed
as `<extension>` here, is compiler-internal. So, the definition of `circumference` above translates to the following method, and can also be invoked as such:

```
<extension> def circumference(c: Circle): Double = c.radius * math.Pi * 2

assert(circle.circumference == circumference(circle))
```

### Operators

The extension method syntax can also be used to define operators. Examples:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >extension (x: String)
</span><span id="1" class="" >  def &lt; (y: String): Boolean = ...
</span><span id="2" class="" >extension (x: Elem)
</span><span id="3" class="" >  def +: (xs: Seq[Elem]): Seq[Elem] = ...
</span><span id="4" class="" >extension (x: Number)
</span><span id="5" class="" >  infix def min (y: Number): Number = ...
</span><span id="6" class="" >
</span><span id="7" class="" >&quot;ab&quot; &lt; &quot;c&quot;
</span><span id="8" class="" >1 +: List(2, 3)
</span><span id="9" class="" >x min 3
</span></code></pre></div>

The three definitions above translate to

```
<extension> def < (x: String)(y: String): Boolean = ...
<extension> def +: (xs: Seq[Elem])(x: Elem): Seq[Elem] = ...
<extension> infix def min(x: Number)(y: Number): Number = ...
```

Note the swap of the two parameters `x` and `xs` when translating
the right-associative operator `+:` to an extension method. This is analogous
to the implementation of right binding operators as normal methods. The Scala
compiler preprocesses an infix operation `x +: xs` to `xs.+:(x)`, so the extension
method ends up being applied to the sequence as first argument (in other words, the
two swaps cancel each other out). See [here for details](./right-associative-extension-methods.html).

### Generic Extensions

It is also possible to extend generic types by adding type parameters to an extension. For instance:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >extension [T](xs: List[T])
</span><span id="1" class="" >  def second = xs.tail.head
</span><span id="2" class="" >
</span><span id="3" class="" >extension [T: Numeric](x: T)
</span><span id="4" class="" >  def + (y: T): T = summon[Numeric[T]].plus(x, y)
</span></code></pre></div>

Type parameters on extensions can also be combined with type parameters on the methods
themselves:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >extension [T](xs: List[T])
</span><span id="1" class="" >  def sumBy[U: Numeric](f: T =&gt; U): U = ...
</span></code></pre></div>

Type arguments matching method type parameters are passed as usual:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >List(&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;).sumBy[Int](_.length)
</span></code></pre></div>

By contrast, type arguments matching type parameters following `extension` can be passed
only if the method is referenced as a non-extension method:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >sumBy[String](List(&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;))(_.length)
</span></code></pre></div>

Or, when passing both type arguments:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >sumBy[String](List(&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;))[Int](_.length)
</span></code></pre></div>

Extensions can also take using clauses. For instance, the `+` extension above could equivalently be written with a using clause:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >extension [T](x: T)(using n: Numeric[T])
</span><span id="1" class="" >  def + (y: T): T = n.plus(x, y)
</span></code></pre></div>

### Collective Extensions

Sometimes, one wants to define several extension methods that share the same
left-hand parameter type. In this case one can "pull out" the common parameters into
a single extension and enclose all methods in braces or an indented region.
Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >extension (ss: Seq[String])
</span><span id="1" class="" >
</span><span id="2" class="" >  def longestStrings: Seq[String] =
</span><span id="3" class="" >    val maxLength = ss.map(_.length).max
</span><span id="4" class="" >    ss.filter(_.length == maxLength)
</span><span id="5" class="" >
</span><span id="6" class="" >  def longestString: String = longestStrings.head
</span></code></pre></div>

The same can be written with braces as follows (note that indented regions can still be used inside braces):

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >extension (ss: Seq[String]) {
</span><span id="1" class="" >
</span><span id="2" class="" >  def longestStrings: Seq[String] = {
</span><span id="3" class="" >    val maxLength = ss.map(_.length).max
</span><span id="4" class="" >    ss.filter(_.length == maxLength)
</span><span id="5" class="" >  }
</span><span id="6" class="" >
</span><span id="7" class="" >  def longestString: String = longestStrings.head
</span><span id="8" class="" >}
</span></code></pre></div>

Note the right-hand side of `longestString`: it calls `longestStrings` directly, implicitly
assuming the common extended value `ss` as receiver.

Collective extensions like these are a shorthand for individual extensions
where each method is defined separately. For instance, the first extension above expands to:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >extension (ss: Seq[String])
</span><span id="1" class="" >  def longestStrings: Seq[String] =
</span><span id="2" class="" >    val maxLength = ss.map(_.length).max
</span><span id="3" class="" >    ss.filter(_.length == maxLength)
</span><span id="4" class="" >
</span><span id="5" class="" >extension (ss: Seq[String])
</span><span id="6" class="" >  def longestString: String = ss.longestStrings.head
</span></code></pre></div>

Collective extensions also can take type parameters and have using clauses. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >extension [T](xs: List[T])(using Ordering[T])
</span><span id="1" class="" >  def smallest(n: Int): List[T] = xs.sorted.take(n)
</span><span id="2" class="" >  def smallestIndices(n: Int): List[Int] =
</span><span id="3" class="" >    val limit = smallest(n).max
</span><span id="4" class="" >    xs.zipWithIndex.collect { case (x, i) if x &lt;= limit =&gt; i }
</span></code></pre></div>

### Translation of Calls to Extension Methods

To convert a reference to an extension method, the compiler has to know about the extension
method. We say in this case that the extension method is _applicable_ at the point of reference.
There are four possible ways for an extension method to be applicable:

1. The extension method is visible under a simple name, by being defined or inherited or imported in a scope enclosing the reference.
2. The extension method is a member of some given
   instance that is visible at the point of the reference.
3. The reference is of the form `r.m` and the extension method
   is defined in the implicit scope of the type of `r`.
4. The reference is of the form `r.m` and the extension method
   is defined in some given instance in the implicit scope of the type of `r`.

Here is an example for the first rule:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait IntOps:
</span><span id="1" class="" >  extension (i: Int) def isZero: Boolean = i == 0
</span><span id="2" class="" >
</span><span id="3" class="" >  extension (i: Int) def safeMod(x: Int): Option[Int] =
</span><span id="4" class="" >    // extension method defined in same scope IntOps
</span><span id="5" class="" >    if x.isZero then None
</span><span id="6" class="" >    else Some(i % x)
</span><span id="7" class="" >
</span><span id="8" class="" >object IntOpsEx extends IntOps:
</span><span id="9" class="" >  extension (i: Int) def safeDiv(x: Int): Option[Int] =
</span><span id="10" class="" >    // extension method brought into scope via inheritance from IntOps
</span><span id="11" class="" >    if x.isZero then None
</span><span id="12" class="" >    else Some(i / x)
</span><span id="13" class="" >
</span><span id="14" class="" >trait SafeDiv:
</span><span id="15" class="" >  import IntOpsEx.* // brings safeDiv and safeMod into scope
</span><span id="16" class="" >
</span><span id="17" class="" >  extension (i: Int) def divide(d: Int): Option[(Int, Int)] =
</span><span id="18" class="" >    // extension methods imported and thus in scope
</span><span id="19" class="" >    (i.safeDiv(d), i.safeMod(d)) match
</span><span id="20" class="" >      case (Some(d), Some(r)) =&gt; Some((d, r))
</span><span id="21" class="" >      case _ =&gt; None
</span></code></pre></div>

By the second rule, an extension method can be made available by defining a given instance containing it, like this:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given ops1: IntOps()  // brings safeMod into scope
</span><span id="1" class="" >
</span><span id="2" class="" >1.safeMod(2)
</span></code></pre></div>

By the third and fourth rule, an extension method is available if it is in the implicit scope of the receiver type or in a given instance in that scope. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class List[T]:
</span><span id="1" class="" >  ...
</span><span id="2" class="" >object List:
</span><span id="3" class="" >  ...
</span><span id="4" class="" >  extension [T](xs: List[List[T]])
</span><span id="5" class="" >    def flatten: List[T] = xs.foldLeft(List.empty[T])(_ ++ _)
</span><span id="6" class="" >
</span><span id="7" class="" >  given [T: Ordering]: Ordering[List[T]] with
</span><span id="8" class="" >    extension (xs: List[T])
</span><span id="9" class="" >      def &lt; (ys: List[T]): Boolean = ...
</span><span id="10" class="" >end List
</span><span id="11" class="" >
</span><span id="12" class="" >// extension method available since it is in the implicit scope
</span><span id="13" class="" >// of List[List[Int]]
</span><span id="14" class="" >List(List(1, 2), List(3, 4)).flatten
</span><span id="15" class="" >
</span><span id="16" class="" >// extension method available since it is in the given Ordering[List[T]],
</span><span id="17" class="" >// which is itself in the implicit scope of List[Int]
</span><span id="18" class="" >List(1, 2) &lt; List(3)
</span></code></pre></div>

The precise rules for resolving a selection to an extension method are as follows.

Assume a selection `e.m[Ts]` where `m` is not a member of `e`, where the type arguments `[Ts]` are optional, and where `T` is the expected type.
The following two rewritings are tried in order:

1. The selection is rewritten to `m[Ts](e)`.

2. If the first rewriting does not typecheck with expected type `T`,
   and there is an extension method `m` in some eligible object `o`, the selection is rewritten to `o.m[Ts](e)`. An object `o` is _eligible_ if

   - `o` forms part of the implicit scope of `T`, or
   - `o` is a given instance that is visible at the point of the application, or
   - `o` is a given instance in the implicit scope of `T`.

   This second rewriting is attempted at the time where the compiler also tries an implicit conversion
   from `T` to a type containing `m`. If there is more than one way of rewriting, an ambiguity error results.

An extension method can also be referenced using a simple identifier without a preceding expression. If an identifier `g` appears in the body of an extension method `f` and refers to an extension method `g` that is defined in the same collective extension

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >extension (x: T)
</span><span id="1" class="" >  def f ... = ... g ...
</span><span id="2" class="" >  def g ...
</span></code></pre></div>

the identifier is rewritten to `x.g`. This is also the case if `f` and `g` are the same method. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >extension (s: String)
</span><span id="1" class="" >  def position(ch: Char, n: Int): Int =
</span><span id="2" class="" >    if n &lt; s.length &amp;&amp; s(n) != ch then position(ch, n + 1)
</span><span id="3" class="" >    else n
</span></code></pre></div>

The recursive call `position(ch, n + 1)` expands to `s.position(ch, n + 1)` in this case. The whole extension method rewrites to

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def position(s: String)(ch: Char, n: Int): Int =
</span><span id="1" class="" >  if n &lt; s.length &amp;&amp; s(n) != ch then position(s)(ch, n + 1)
</span><span id="2" class="" >  else n
</span></code></pre></div>

### Syntax

Here are the syntax changes for extension methods and collective extensions relative
to the [current syntax](../syntax.html).

```
BlockStat         ::=  ... | Extension
TemplateStat      ::=  ... | Extension
TopStat           ::=  ... | Extension
Extension         ::=  ‘extension’ [DefTypeParamClause] {UsingParamClause}
                       ‘(’ DefParam ‘)’ {UsingParamClause} ExtMethods
ExtMethods        ::=  ExtMethod | [nl] <<< ExtMethod {semi ExtMethod} >>>
ExtMethod         ::=  {Annotation [nl]} {Modifier} ‘def’ DefDef
```

In the above the notation `<<< ts >>>` in the production rule `ExtMethods` is defined as follows :

```
<<< ts >>>        ::=  ‘{’ ts ‘}’ | indent ts outdent
```

`extension` is a soft keyword. It is recognized as a keyword only if it appears
at the start of a statement and is followed by `[` or `(`. In all other cases
it is treated as an identifier.
