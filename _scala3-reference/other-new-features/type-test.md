---
title: "TypeTest"
next-page: /scala3/reference/changed-features
num: 50
type: section
previous-page: /scala3/reference/other-new-features/safe-initialization
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

## TypeTest

When pattern matching there are two situations where a runtime type test must be performed.
The first case is an explicit type test using the ascription pattern notation.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >(x: X) match
</span><span id="1" class="" >  case y: Y =&gt;
</span></code></pre></div>

The second case is when an extractor takes an argument that is not a subtype of the scrutinee type.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >(x: X) match
</span><span id="1" class="" >  case y @ Y(n) =&gt;
</span><span id="2" class="" >
</span><span id="3" class="" >object Y:
</span><span id="4" class="" >  def unapply(x: Y): Some[Int] = ...
</span></code></pre></div>

In both cases, a class test will be performed at runtime.
But when the type test is on an abstract type (type parameter or type member), the test cannot be performed because the type is erased at runtime.

A `TypeTest` can be provided to make this test possible.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >package scala.reflect
</span><span id="1" class="" >
</span><span id="2" class="" >trait TypeTest[-S, T]:
</span><span id="3" class="" >  def unapply(s: S): Option[s.type &amp; T]
</span></code></pre></div>

It provides an extractor that returns its argument typed as a `T` if the argument is a `T`.
It can be used to encode a type test.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def f[X, Y](x: X)(using tt: TypeTest[X, Y]): Option[Y] = x match
</span><span id="1" class="" >  case tt(x @ Y(1)) =&gt; Some(x)
</span><span id="2" class="" >  case tt(x) =&gt; Some(x)
</span><span id="3" class="" >  case _ =&gt; None
</span></code></pre></div>

To avoid the syntactic overhead the compiler will look for a type test automatically if it detects that the type test is on abstract types.
This means that `x: Y` is transformed to `tt(x)` and `x @ Y(_)` to `tt(x @ Y(_))` if there is a contextual `TypeTest[X, Y]` in scope.
The previous code is equivalent to

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def f[X, Y](x: X)(using TypeTest[X, Y]): Option[Y] = x match
</span><span id="1" class="" >  case x @ Y(1) =&gt; Some(x)
</span><span id="2" class="" >  case x: Y =&gt; Some(x)
</span><span id="3" class="" >  case _ =&gt; None
</span></code></pre></div>

We could create a type test at call site where the type test can be performed with runtime class tests directly as follows

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val tt: TypeTest[Any, String] =
</span><span id="1" class="" >  new TypeTest[Any, String]:
</span><span id="2" class="" >    def unapply(s: Any): Option[s.type &amp; String] = s match
</span><span id="3" class="" >      case s: String =&gt; Some(s)
</span><span id="4" class="" >      case _ =&gt; None
</span><span id="5" class="" >
</span><span id="6" class="" >f[AnyRef, String](&quot;acb&quot;)(using tt)
</span></code></pre></div>

The compiler will synthesize a new instance of a type test if none is found in scope as:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >new TypeTest[A, B]:
</span><span id="1" class="" >  def unapply(s: A): Option[s.type &amp; B] = s match
</span><span id="2" class="" >    case s: B =&gt; Some(s)
</span><span id="3" class="" >    case _ =&gt; None
</span></code></pre></div>

If the type tests cannot be done there will be an unchecked warning that will be raised on the `case s: B =>` test.

The most common `TypeTest` instances are the ones that take any parameters (i.e. `TypeTest[Any, T]`).
To make it possible to use such instances directly in context bounds we provide the alias

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >package scala.reflect
</span><span id="1" class="" >
</span><span id="2" class="" >type Typeable[T] = TypeTest[Any, T]
</span></code></pre></div>

This alias can be used as

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def f[T: Typeable]: Boolean =
</span><span id="1" class="" >  &quot;abc&quot; match
</span><span id="2" class="" >    case x: T =&gt; true
</span><span id="3" class="" >    case _ =&gt; false
</span><span id="4" class="" >
</span><span id="5" class="" >f[String] // true
</span><span id="6" class="" >f[Int] // false
</span></code></pre></div>

## TypeTest and ClassTag

`TypeTest` is a replacement for functionality provided previously by `ClassTag.unapply`.
Using `ClassTag` instances was unsound since classtags can check only the class component of a type.
`TypeTest` fixes that unsoundness.
`ClassTag` type tests are still supported but a warning will be emitted after 3.0.

## Example

Given the following abstract definition of Peano numbers that provides two given instances of types `TypeTest[Nat, Zero]` and `TypeTest[Nat, Succ]`

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.reflect.*
</span><span id="1" class="" >
</span><span id="2" class="" >trait Peano:
</span><span id="3" class="" >  type Nat
</span><span id="4" class="" >  type Zero &lt;: Nat
</span><span id="5" class="" >  type Succ &lt;: Nat
</span><span id="6" class="" >
</span><span id="7" class="" >  def safeDiv(m: Nat, n: Succ): (Nat, Nat)
</span><span id="8" class="" >
</span><span id="9" class="" >  val Zero: Zero
</span><span id="10" class="" >
</span><span id="11" class="" >  val Succ: SuccExtractor
</span><span id="12" class="" >  trait SuccExtractor:
</span><span id="13" class="" >    def apply(nat: Nat): Succ
</span><span id="14" class="" >    def unapply(succ: Succ): Some[Nat]
</span><span id="15" class="" >
</span><span id="16" class="" >  given typeTestOfZero: TypeTest[Nat, Zero]
</span><span id="17" class="" >  given typeTestOfSucc: TypeTest[Nat, Succ]
</span></code></pre></div>

together with an implementation of Peano numbers based on type `Int`

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object PeanoInt extends Peano:
</span><span id="1" class="" >  type Nat  = Int
</span><span id="2" class="" >  type Zero = Int
</span><span id="3" class="" >  type Succ = Int
</span><span id="4" class="" >
</span><span id="5" class="" >  def safeDiv(m: Nat, n: Succ): (Nat, Nat) = (m / n, m % n)
</span><span id="6" class="" >
</span><span id="7" class="" >  val Zero: Zero = 0
</span><span id="8" class="" >
</span><span id="9" class="" >  val Succ: SuccExtractor = new:
</span><span id="10" class="" >    def apply(nat: Nat): Succ = nat + 1
</span><span id="11" class="" >    def unapply(succ: Succ) = Some(succ - 1)
</span><span id="12" class="" >
</span><span id="13" class="" >  def typeTestOfZero: TypeTest[Nat, Zero] = new:
</span><span id="14" class="" >    def unapply(x: Nat): Option[x.type &amp; Zero] =
</span><span id="15" class="" >      if x == 0 then Some(x) else None
</span><span id="16" class="" >
</span><span id="17" class="" >  def typeTestOfSucc: TypeTest[Nat, Succ] = new:
</span><span id="18" class="" >    def unapply(x: Nat): Option[x.type &amp; Succ] =
</span><span id="19" class="" >      if x &gt; 0 then Some(x) else None
</span></code></pre></div>

it is possible to write the following program

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >@main def test =
</span><span id="1" class="" >  import PeanoInt.*
</span><span id="2" class="" >
</span><span id="3" class="" >  def divOpt(m: Nat, n: Nat): Option[(Nat, Nat)] =
</span><span id="4" class="" >    n match
</span><span id="5" class="" >      case Zero =&gt; None
</span><span id="6" class="" >      case s @ Succ(_) =&gt; Some(safeDiv(m, s))
</span><span id="7" class="" >
</span><span id="8" class="" >  val two = Succ(Succ(Zero))
</span><span id="9" class="" >  val five = Succ(Succ(Succ(two)))
</span><span id="10" class="" >
</span><span id="11" class="" >  println(divOpt(five, two))  // prints &quot;Some((2,1))&quot;
</span><span id="12" class="" >  println(divOpt(two, five))  // prints &quot;Some((0,2))&quot;
</span><span id="13" class="" >  println(divOpt(two, Zero))  // prints &quot;None&quot;
</span></code></pre></div>Note that without the `TypeTest[Nat, Succ]` the pattern `Succ.unapply(nat: Succ)` would be unchecked.
