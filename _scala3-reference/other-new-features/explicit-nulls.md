---
title: "Explicit Nulls"
next-page: /scala3/reference/other-new-features/safe-initialization
num: 48
type: section
previous-page: /scala3/reference/other-new-features/indentation
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/other-new-features/explicit-nulls.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

Explicit nulls is an opt-in feature that modifies the Scala type system, which makes reference types
(anything that extends `AnyRef`) _non-nullable_.

This means the following code will no longer typecheck:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val x: String = null // error: found `Null`, but required `String`
</span></code></pre></div>

Instead, to mark a type as nullable we use a [union type](../new-types/union-types.html)

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val x: String | Null = null // ok
</span></code></pre></div>

A nullable type could have null value during runtime; hence, it is not safe to select a member without checking its nullity.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >x.trim // error: trim is not member of String | Null
</span></code></pre></div>

Explicit nulls are enabled via a `-Yexplicit-nulls` flag.

Read on for details.

## New Type Hierarchy

When explicit nulls are enabled, the type hierarchy changes so that `Null` is only a subtype of
`Any`, as opposed to every reference type, which means `null` is no longer a value of `AnyRef` and its subtypes.

This is the new type hierarchy:

!["Type Hierarchy for Explicit Nulls"](/resources/images/scala3/explicit-nulls/explicit-nulls-type-hierarchy.png)

After erasure, `Null` remains a subtype of all reference types (as forced by the JVM).

## Working with `Null`

To make working with nullable values easier, we propose adding a few utilities to the standard library.
So far, we have found the following useful:

- An extension method `.nn` to "cast away" nullability

  <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >extension [T](x: T | Null)
  </span><span id="1" class="" >   inline def nn: T =
  </span><span id="2" class="" >     assert(x != null)
  </span><span id="3" class="" >     x.asInstanceOf[T]
  </span></code></pre></div>

  This means that given `x: String | Null`, `x.nn` has type `String`, so we can call all the
  usual methods on it. Of course, `x.nn` will throw a NPE if `x` is `null`.

  Don't use `.nn` on mutable variables directly, because it may introduce an unknown type into the type of the variable.

- An `unsafeNulls` language feature.

  When imported, `T | Null` can be used as `T`, similar to regular Scala (without explicit nulls).

  See [UnsafeNulls](#unsafenulls) section for more details.

## Unsoundness

The new type system is unsound with respect to `null`. This means there are still instances where an expression has a non-nullable type like `String`, but its value is actually `null`.

The unsoundness happens because uninitialized fields in a class start out as `null`:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class C:
</span><span id="1" class="" >  val f: String = foo(f)
</span><span id="2" class="" >  def foo(f2: String): String = f2
</span><span id="3" class="" >
</span><span id="4" class="" >val c = new C()
</span><span id="5" class="" >// c.f == &quot;field is null&quot;
</span></code></pre></div>

The unsoundness above can be caught by the compiler with the option `-Ysafe-init`.
More details can be found in [safe initialization](./safe-initialization.html).

## Equality

We don't allow the double-equal (`==` and `!=`) and reference (`eq` and `ne`) comparison between
`AnyRef` and `Null` anymore, since a variable with a non-nullable type cannot have `null` as value.
`null` can only be compared with `Null`, nullable union (`T | Null`), or `Any` type.

For some reason, if we really want to compare `null` with non-null values, we have to provide a type hint (e.g. `: Any`).

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val x: String = ???
</span><span id="1" class="" >val y: String | Null = ???
</span><span id="2" class="" >
</span><span id="3" class="" >x == null       // error: Values of types String and Null cannot be compared with == or !=
</span><span id="4" class="" >x eq null       // error
</span><span id="5" class="" >&quot;hello&quot; == null // error
</span><span id="6" class="" >
</span><span id="7" class="" >y == null       // ok
</span><span id="8" class="" >y == x          // ok
</span><span id="9" class="" >
</span><span id="10" class="" >(x: String | Null) == null  // ok
</span><span id="11" class="" >(x: Any) == null            // ok
</span></code></pre></div>

## Java Interoperability

The Scala compiler can load Java classes in two ways: from source or from bytecode. In either case,
when a Java class is loaded, we "patch" the type of its members to reflect that Java types
remain implicitly nullable.

Specifically, we patch

- the type of fields

- the argument type and return type of methods

We illustrate the rules with following examples:

- The first two rules are easy: we nullify reference types but not value types.

  ```java
  class C {
    String s;
    int x;
  }
  ```

  ==>

  <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class C:
  </span><span id="1" class="" >  val s: String | Null
  </span><span id="2" class="" >  val x: Int
  </span></code></pre></div>- We nullify type parameters because in Java a type parameter is always nullable, so the following code compiles.

  ```java
  class C<T> { T foo() { return null; } }
  ```

  ==>

  <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class C[T] { def foo(): T | Null }
  </span></code></pre></div>

  Notice this is rule is sometimes too conservative, as witnessed by

  <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class InScala:
  </span><span id="1" class="" >  val c: C[Bool] = ???  // C as above
  </span><span id="2" class="" >  val b: Bool = c.foo() // no longer typechecks, since foo now returns Bool | Null
  </span></code></pre></div>- We can reduce the number of redundant nullable types we need to add. Consider

  ```java
  class Box<T> { T get(); }
  class BoxFactory<T> { Box<T> makeBox(); }
  ```

  ==>

  <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class Box[T] { def get(): T | Null }
  </span><span id="1" class="" >class BoxFactory[T] { def makeBox(): Box[T] | Null }
  </span></code></pre></div>

  Suppose we have a `BoxFactory[String]`. Notice that calling `makeBox()` on it returns a
  `Box[String] | Null`, not a `Box[String | Null] | Null`. This seems at first
  glance unsound ("What if the box itself has `null` inside?"), but is sound because calling
  `get()` on a `Box[String]` returns a `String | Null`.

  Notice that we need to patch _all_ Java-defined classes that transitively appear in the
  argument or return type of a field or method accessible from the Scala code being compiled.
  Absent crazy reflection magic, we think that all such Java classes _must_ be visible to
  the Typer in the first place, so they will be patched.

- We will append `Null` to the type arguments if the generic class is defined in Scala.

  ```java
  class BoxFactory<T> {
    Box<T> makeBox(); // Box is Scala-defined
    List<Box<List<T>>> makeCrazyBoxes(); // List is Java-defined
  }
  ```

  ==>

  <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class BoxFactory[T]:
  </span><span id="1" class="" >  def makeBox(): Box[T | Null] | Null
  </span><span id="2" class="" >  def makeCrazyBoxes(): java.util.List[Box[java.util.List[T] | Null]] | Null
  </span></code></pre></div>

  In this case, since `Box` is Scala-defined, we will get `Box[T | Null] | Null`.
  This is needed because our nullability function is only applied (modularly) to the Java
  classes, but not to the Scala ones, so we need a way to tell `Box` that it contains a
  nullable value.

  The `List` is Java-defined, so we don't append `Null` to its type argument. But we
  still need to nullify its inside.

- We don't nullify _simple_ literal constant (`final`) fields, since they are known to be non-null

  ```java
  class Constants {
    final String NAME = "name";
    final int AGE = 0;
    final char CHAR = 'a';
  
    final String NAME_GENERATED = getNewName();
  }
  ```

  ==>

  <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class Constants:
  </span><span id="1" class="" >  val NAME: String(&quot;name&quot;) = &quot;name&quot;
  </span><span id="2" class="" >  val AGE: Int(0) = 0
  </span><span id="3" class="" >  val CHAR: Char(&apos;a&apos;) = &apos;a&apos;
  </span><span id="4" class="" >
  </span><span id="5" class="" >  val NAME_GENERATED: String | Null = getNewName()
  </span></code></pre></div>- We don't append `Null` to a field nor to a return type of a method which is annotated with a
  `NotNull` annotation.

  ```java
  class C {
    @NotNull String name;
    @NotNull List<String> getNames(String prefix); // List is Java-defined
    @NotNull Box<String> getBoxedName(); // Box is Scala-defined
  }
  ```

  ==>

  <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class C:
  </span><span id="1" class="" >  val name: String
  </span><span id="2" class="" >  def getNames(prefix: String | Null): java.util.List[String] // we still need to nullify the paramter types
  </span><span id="3" class="" >  def getBoxedName(): Box[String | Null] // we don&apos;t append `Null` to the outmost level, but we still need to nullify inside
  </span></code></pre></div>

  The annotation must be from the list below to be recognized as `NotNull` by the compiler.
  Check `Definitions.scala` for an updated list.

  <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >// A list of annotations that are commonly used to indicate
  </span><span id="1" class="" >// that a field/method argument or return type is not null.
  </span><span id="2" class="" >// These annotations are used by the nullification logic in
  </span><span id="3" class="" >// JavaNullInterop to improve the precision of type nullification.
  </span><span id="4" class="" >// We don&apos;t require that any of these annotations be present
  </span><span id="5" class="" >// in the class path, but we want to create Symbols for the
  </span><span id="6" class="" >// ones that are present, so they can be checked during nullification.
  </span><span id="7" class="" >@tu lazy val NotNullAnnots: List[ClassSymbol] = ctx.getClassesIfDefined(
  </span><span id="8" class="" >  &quot;javax.annotation.Nonnull&quot; ::
  </span><span id="9" class="" >  &quot;edu.umd.cs.findbugs.annotations.NonNull&quot; ::
  </span><span id="10" class="" >  &quot;androidx.annotation.NonNull&quot; ::
  </span><span id="11" class="" >  &quot;android.support.annotation.NonNull&quot; ::
  </span><span id="12" class="" >  &quot;android.annotation.NonNull&quot; ::
  </span><span id="13" class="" >  &quot;com.android.annotations.NonNull&quot; ::
  </span><span id="14" class="" >  &quot;org.eclipse.jdt.annotation.NonNull&quot; ::
  </span><span id="15" class="" >  &quot;org.checkerframework.checker.nullness.qual.NonNull&quot; ::
  </span><span id="16" class="" >  &quot;org.checkerframework.checker.nullness.compatqual.NonNullDecl&quot; ::
  </span><span id="17" class="" >  &quot;org.jetbrains.annotations.NotNull&quot; ::
  </span><span id="18" class="" >  &quot;lombok.NonNull&quot; ::
  </span><span id="19" class="" >  &quot;io.reactivex.annotations.NonNull&quot; :: Nil map PreNamedString)
  </span></code></pre></div>

### Override check

When we check overriding between Scala classes and Java classes, the rules are relaxed for `Null` type with this feature, in order to help users to working with Java libraries.

Suppose we have Java method `String f(String x)`, we can override this method in Scala in any of the following forms:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def f(x: String | Null): String | Null
</span><span id="1" class="" >
</span><span id="2" class="" >def f(x: String): String | Null
</span><span id="3" class="" >
</span><span id="4" class="" >def f(x: String | Null): String
</span><span id="5" class="" >
</span><span id="6" class="" >def f(x: String): String
</span></code></pre></div>

Note that some of the definitions could cause unsoundness. For example, the return type is not nullable, but a `null` value is actually returned.

## Flow Typing

We added a simple form of flow-sensitive type inference. The idea is that if `p` is a
stable path or a trackable variable, then we can know that `p` is non-null if it's compared
with `null`. This information can then be propagated to the `then` and `else` branches
of an if-statement (among other places).

Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val s: String | Null = ???
</span><span id="1" class="" >if s != null then
</span><span id="2" class="" >  // s: String
</span><span id="3" class="" >
</span><span id="4" class="" >// s: String | Null
</span><span id="5" class="" >
</span><span id="6" class="" >assert(s != null)
</span><span id="7" class="" >// s: String
</span></code></pre></div>

A similar inference can be made for the `else` case if the test is `p == null`

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >if s == null then
</span><span id="1" class="" >  // s: String | Null
</span><span id="2" class="" >else
</span><span id="3" class="" >  // s: String
</span></code></pre></div>

`==` and `!=` is considered a comparison for the purposes of the flow inference.

### Logical Operators

We also support logical operators (`&&`, `||`, and `!`):

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val s: String | Null = ???
</span><span id="1" class="" >val s2: String | Null = ???
</span><span id="2" class="" >if s != null &amp;&amp; s2 != null then
</span><span id="3" class="" >  // s: String
</span><span id="4" class="" >  // s2: String
</span><span id="5" class="" >
</span><span id="6" class="" >if s == null || s2 == null then
</span><span id="7" class="" >  // s: String | Null
</span><span id="8" class="" >  // s2: String | Null
</span><span id="9" class="" >else
</span><span id="10" class="" >  // s: String
</span><span id="11" class="" >  // s2: String
</span></code></pre></div>

### Inside Conditions

We also support type specialization _within_ the condition, taking into account that `&&` and `||` are short-circuiting:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val s: String | Null = ???
</span><span id="1" class="" >
</span><span id="2" class="" >if s != null &amp;&amp; s.length &gt; 0 then // s: String in `s.length &gt; 0`
</span><span id="3" class="" >  // s: String
</span><span id="4" class="" >
</span><span id="5" class="" >if s == null || s.length &gt; 0 then // s: String in `s.length &gt; 0`
</span><span id="6" class="" >  // s: String | Null
</span><span id="7" class="" >else
</span><span id="8" class="" >  // s: String
</span></code></pre></div>

### Match Case

The non-null cases can be detected in match statements.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val s: String | Null = ???
</span><span id="1" class="" >
</span><span id="2" class="" >s match
</span><span id="3" class="" >  case _: String =&gt; // s: String
</span><span id="4" class="" >  case _ =&gt;
</span></code></pre></div>

### Mutable Variable

We are able to detect the nullability of some local mutable variables. A simple example is:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class C(val x: Int, val next: C | Null)
</span><span id="1" class="" >
</span><span id="2" class="" >var xs: C | Null = C(1, C(2, null))
</span><span id="3" class="" >// xs is trackable, since all assignments are in the same method
</span><span id="4" class="" >while xs != null do
</span><span id="5" class="" >  // xs: C
</span><span id="6" class="" >  val xsx: Int = xs.x
</span><span id="7" class="" >  val xscpy: C = xs
</span><span id="8" class="" >  xs = xscpy // since xscpy is non-null, xs still has type C after this line
</span><span id="9" class="" >  // xs: C
</span><span id="10" class="" >  xs = xs.next // after this assignment, xs can be null again
</span><span id="11" class="" >  // xs: C | Null
</span></code></pre></div>

When dealing with local mutable variables, there are two questions:

1. Whether to track a local mutable variable during flow typing.
   We track a local mutable variable if the variable is not assigned in a closure.
   For example, in the following code `x` is assigned to by the closure `y`, so we do not
   do flow typing on `x`.

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >var x: String | Null = ???
   </span><span id="1" class="" >def y =
   </span><span id="2" class="" >  x = null
   </span><span id="3" class="" >
   </span><span id="4" class="" >if x != null then
   </span><span id="5" class="" >   // y can be called here, which would break the fact
   </span><span id="6" class="" >   val a: String = x // error: x is captured and mutated by the closure, not trackable
   </span></code></pre></div>2. Whether to generate and use flow typing on a specific _use_ of a local mutable variable.
   We only want to do flow typing on a use that belongs to the same method as the definition
   of the local variable.
   For example, in the following code, even `x` is not assigned to by a closure, we can only
   use flow typing in one of the occurrences (because the other occurrence happens within a
   nested closure).

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >var x: String | Null = ???
   </span><span id="1" class="" >def y =
   </span><span id="2" class="" >  if x != null then
   </span><span id="3" class="" >    // not safe to use the fact (x != null) here
   </span><span id="4" class="" >    // since y can be executed at the same time as the outer block
   </span><span id="5" class="" >    val _: String = x
   </span><span id="6" class="" >if x != null then
   </span><span id="7" class="" >  val a: String = x // ok to use the fact here
   </span><span id="8" class="" >  x = null
   </span></code></pre></div>

See [more examples](https://github.com/lampepfl/dotty/blob/master/tests/explicit-nulls/neg/flow-varref-in-closure.scala).

Currently, we are unable to track paths with a mutable variable prefix.
For example, `x.a` if `x` is mutable.

### Unsupported Idioms

We don't support:

- flow facts not related to nullability (`if x == 0 then { // x: 0.type not inferred }`)

- tracking aliasing between non-nullable paths

  <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val s: String | Null = ???
  </span><span id="1" class="" >val s2: String | Null = ???
  </span><span id="2" class="" >if s != null &amp;&amp; s == s2 then
  </span><span id="3" class="" >  // s:  String inferred
  </span><span id="4" class="" >  // s2: String not inferred
  </span></code></pre></div>

### UnsafeNulls

It is difficult to work with many nullable values, we introduce a language feature `unsafeNulls`.
Inside this "unsafe" scope, all `T | Null` values can be used as `T`.

Users can import `scala.language.unsafeNulls` to create such scopes, or use `-language:unsafeNulls` to enable this feature globally (for migration purpose only).

Assume `T` is a reference type (a subtype of `AnyRef`), the following unsafe operation rules are
applied in this unsafe-nulls scope:

1. the members of `T` can be found on `T | Null`

2. a value with type `T` can be compared with `T | Null` and `Null`

3. suppose `T1` is not a subtype of `T2` using explicit-nulls subtyping (where `Null` is a direct
   subtype of Any), extension methods and implicit conversions designed for `T2` can be used for
   `T1` if `T1` is a subtype of `T2` using regular subtyping rules (where `Null` is a subtype of every
   reference type)

4. suppose `T1` is not a subtype of `T2` using explicit-nulls subtyping, a value with type `T1`
   can be used as `T2` if `T1` is a subtype of `T2` using regular subtyping rules

Addtionally, `null` can be used as `AnyRef` (`Object`), which means you can select `.eq` or `.toString` on it.

The program in `unsafeNulls` will have a **similar** semantic as regular Scala, but not **equivalent**.

For example, the following code cannot be compiled even using unsafe nulls. Because of the
Java interoperation, the type of the get method becomes `T | Null`.

```Scala
def head[T](xs: java.util.List[T]): T = xs.get(0) // error
```

Since the compiler doesn’t know whether `T` is a reference type, it is unable to cast `T | Null`
to `T`. A `.nn` need to be inserted after `xs.get(0)` by user manually to fix the error, which
strips the `Null` from its type.

The intention of this `unsafeNulls` is to give users a better migration path for explicit nulls.
Projects for Scala 2 or regular Scala 3 can try this by adding `-Yexplicit-nulls -language:unsafeNulls`
to the compile options. A small number of manual modifications are expected. To migrate to the full
explicit nulls feature in the future, `-language:unsafeNulls` can be dropped and add
`import scala.language.unsafeNulls` only when needed.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def f(x: String): String = ???
</span><span id="1" class="" >def nullOf[T &gt;: Null]: T = null
</span><span id="2" class="" >
</span><span id="3" class="" >import scala.language.unsafeNulls
</span><span id="4" class="" >
</span><span id="5" class="" >val s: String | Null = ???
</span><span id="6" class="" >val a: String = s // unsafely convert String | Null to String
</span><span id="7" class="" >
</span><span id="8" class="" >val b1 = s.trim // call .trim on String | Null unsafely
</span><span id="9" class="" >val b2 = b1.length
</span><span id="10" class="" >
</span><span id="11" class="" >f(s).trim // pass String | Null as an argument of type String unsafely
</span><span id="12" class="" >
</span><span id="13" class="" >val c: String = null // Null to String
</span><span id="14" class="" >
</span><span id="15" class="" >val d1: Array[String] = ???
</span><span id="16" class="" >val d2: Array[String | Null] = d1 // unsafely convert Array[String] to Array[String | Null]
</span><span id="17" class="" >val d3: Array[String] = Array(null) // unsafe
</span><span id="18" class="" >
</span><span id="19" class="" >class C[T &gt;: Null &lt;: String] // define a type bound with unsafe conflict bound
</span><span id="20" class="" >
</span><span id="21" class="" >val n = nullOf[String] // apply a type bound unsafely
</span></code></pre></div>

Without the `unsafeNulls`, all these unsafe operations will not be type-checked.

`unsafeNulls` also works for extension methods and implicit search.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.language.unsafeNulls
</span><span id="1" class="" >
</span><span id="2" class="" >val x = &quot;hello, world!&quot;.split(&quot; &quot;).map(_.length)
</span><span id="3" class="" >
</span><span id="4" class="" >given Conversion[String, Array[String]] = _ =&gt; ???
</span><span id="5" class="" >
</span><span id="6" class="" >val y: String | Null = ???
</span><span id="7" class="" >val z: Array[String | Null] = y
</span></code></pre></div>

## Binary Compatibility

Our strategy for binary compatibility with Scala binaries that predate explicit nulls
and new libraries compiled without `-Yexplicit-nulls` is to leave the types unchanged
and be compatible but unsound.

[More details](https://dotty.epfl.ch/docs/internals/explicit-nulls.html)
