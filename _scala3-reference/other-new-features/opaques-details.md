---
layout: singlepage-overview
title: "Opaque Type Aliases: More Details"
scala3: true
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

### Syntax

```
Modifier          ::=  ...
                    |  ‘opaque’
```

`opaque` is a [soft modifier](../soft-modifier.html). It can still be used as a normal identifier when it is not in front of a definition keyword.

Opaque type aliases must be members of classes, traits, or objects, or they are defined
at the top-level. They cannot be defined in local blocks.

### Type Checking

The general form of a (monomorphic) opaque type alias is

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >opaque type T &gt;: L &lt;: U = R
</span></code></pre></div>

where the lower bound `L` and the upper bound `U` may be missing, in which case they are assumed to be `scala.Nothing` and `scala.Any`, respectively. If bounds are given, it is checked that the right-hand side `R` conforms to them, i.e. `L <: R` and `R <: U`. F-bounds are not supported for opaque type aliases: `T` is not allowed to appear in `L` or `U`.

Inside the scope of the alias definition, the alias is transparent: `T` is treated
as a normal alias of `R`. Outside its scope, the alias is treated as the abstract type

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type T &gt;: L &lt;: U
</span></code></pre></div>

A special case arises if the opaque type alias is defined in an object. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object o:
</span><span id="1" class="" >  opaque type T = R
</span></code></pre></div>

In this case we have inside the object (also for non-opaque types) that `o.T` is equal to
`T` or its expanded form `o.this.T`. Equality is understood here as mutual subtyping, i.e.
`o.T <: o.this.T` and `o.this.T <: T`. Furthermore, we have by the rules of opaque type aliases
that `o.this.T` equals `R`. The two equalities compose. That is, inside `o`, it is
also known that `o.T` is equal to `R`. This means the following code type-checks:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object o:
</span><span id="1" class="" >  opaque type T = Int
</span><span id="2" class="" >  val x: Int = id(2)
</span><span id="3" class="" >def id(x: o.T): o.T = x
</span></code></pre></div>

### Type Parameters of Opaque Types

Opaque type aliases can have a single type parameter list. The following aliases
are well-formed

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >opaque type F[T] = (T, T)
</span><span id="1" class="" >opaque type G = [T] =&gt;&gt; List[T]
</span></code></pre></div>

but the following are not:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >opaque type BadF[T] = [U] =&gt;&gt; (T, U)
</span><span id="1" class="" >opaque type BadG = [T] =&gt;&gt; [U] =&gt; (T, U)
</span></code></pre></div>

### Translation of Equality

Comparing two values of opaque type with `==` or `!=` normally uses universal equality,
unless another overloaded `==` or `!=` operator is defined for the type. To avoid
boxing, the operation is mapped after type checking to the (in-)equality operator
defined on the underlying type. For instance,

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >opaque type T = Int
</span><span id="1" class="" >
</span><span id="2" class="" >  ...
</span><span id="3" class="" >  val x: T
</span><span id="4" class="" >  val y: T
</span><span id="5" class="" >  x == y    // uses Int equality for the comparison.
</span></code></pre></div>

### Top-level Opaque Types

An opaque type alias on the top-level is transparent in all other top-level definitions in the sourcefile where it appears, but is opaque in nested
objects and classes and in all other source files. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >// in test1.scala
</span><span id="1" class="" >opaque type A = String
</span><span id="2" class="" >val x: A = &quot;abc&quot;
</span><span id="3" class="" >
</span><span id="4" class="" >object obj:
</span><span id="5" class="" >  val y: A = &quot;abc&quot;  // error: found: &quot;abc&quot;, required: A
</span><span id="6" class="" >
</span><span id="7" class="" >// in test2.scala
</span><span id="8" class="" >def z: String = x   // error: found: A, required: String
</span></code></pre></div>

This behavior becomes clear if one recalls that top-level definitions are placed in their own synthetic object. For instance, the code in `test1.scala` would expand to

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object test1$package:
</span><span id="1" class="" >  opaque type A = String
</span><span id="2" class="" >  val x: A = &quot;abc&quot;
</span><span id="3" class="" >
</span><span id="4" class="" >object obj:
</span><span id="5" class="" >  val y: A = &quot;abc&quot;  // error: cannot assign &quot;abc&quot; to opaque type alias A
</span></code></pre></div>

The opaque type alias `A` is transparent in its scope, which includes the definition of `x`, but not the definitions of `obj` and `y`.

### Relationship to SIP 35

Opaque types in Scala 3 are an evolution from what is described in
[Scala SIP 35](https://docs.scala-lang.org/sips/opaque-types.html).

The differences compared to the state described in this SIP are:

1. Opaque type aliases cannot be defined anymore in local statement sequences.
2. The scope where an opaque type alias is visible is now the whole scope where
   it is defined, instead of just a companion object.
3. The notion of a companion object for opaque type aliases has been dropped.
4. Opaque type aliases can have bounds.
5. The notion of type equality involving opaque type aliases has been clarified. It was
   strengthened with respect to the previous implementation of SIP 35.

