---
title: "The Matchable Trait"
next-page: /scala3/reference/other-new-features/threadUnsafe-annotation
num: 43
type: section
previous-page: /scala3/reference/other-new-features/kind-polymorphism
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/other-new-features/matchable.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

A new trait `Matchable` controls the ability to pattern match.

### The Problem

The Scala 3 standard library has a type `IArray` for immutable
arrays that is defined like this:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >opaque type IArray[+T] = Array[_ &lt;: T]
</span></code></pre></div>

The `IArray` type offers extension methods for `length` and `apply`, but not for `update`; hence it seems values of type `IArray` cannot be updated.

However, there is a potential hole due to pattern matching. Consider:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val imm: IArray[Int] = ...
</span><span id="1" class="" >imm match
</span><span id="2" class="" >  case a: Array[Int] =&gt; a(0) = 1
</span></code></pre></div>

The test will succeed at runtime since `IArray`s _are_ represented as
`Array`s at runtime. But if we allowed it, it would break the fundamental abstraction of immutable arrays.

__Aside:__ One could also achieve the same by casting:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >imm.asInstanceOf[Array[Int]](0) = 1
</span></code></pre></div>

But that is not as much of a problem since in Scala `asInstanceOf` is understood to be low-level and unsafe. By contrast, a pattern match that compiles without warning or error should not break abstractions.

Note also that the problem is not tied to opaque types as match selectors. The following slight variant with a value of parametric
type `T` as match selector leads to the same problem:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def f[T](x: T) = x match
</span><span id="1" class="" >  case a: Array[Int] =&gt; a(0) = 0
</span><span id="2" class="" >f(imm)
</span></code></pre></div>

Finally, note that the problem is not linked to just opaque types. No unbounded type parameter or abstract type should be decomposable with a pattern match.

### The Solution

There is a new type `scala.Matchable` that controls pattern matching. When typing a pattern match of a constructor pattern `C(...)` or
a type pattern `_: C` it is required that the selector type conforms
to `Matchable`. If that's not the case a warning is issued. For instance when compiling the example at the start of this section we get:

```
> sc ../new/test.scala -source future
-- Warning: ../new/test.scala:4:12 ---------------------------------------------
4 |    case a: Array[Int] => a(0) = 0
  |            ^^^^^^^^^^
  |            pattern selector should be an instance of Matchable,
  |            but it has unmatchable type IArray[Int] instead
```

To allow migration from Scala 2 and cross-compiling
between Scala 2 and 3 the warning is turned on only for `-source future-migration` or higher.

`Matchable` is a universal trait with `Any` as its parent class. It is
extended by both `AnyVal` and `AnyRef`. Since `Matchable` is a supertype of every concrete value or reference class it means that instances of such classes can be matched as before. However, match selectors of the following types will produce a warning:

- Type `Any`: if pattern matching is required one should use `Matchable` instead.
- Unbounded type parameters and abstract types: If pattern matching is required they should have an upper bound `Matchable`.
- Type parameters and abstract types that are only bounded by some
  universal trait: Again, `Matchable` should be added as a bound.

Here is the hierarchy of top-level classes and traits with their defined methods:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >abstract class Any:
</span><span id="1" class="" >  def getClass
</span><span id="2" class="" >  def isInstanceOf
</span><span id="3" class="" >  def asInstanceOf
</span><span id="4" class="" >  def ==
</span><span id="5" class="" >  def !=
</span><span id="6" class="" >  def ##
</span><span id="7" class="" >  def equals
</span><span id="8" class="" >  def hashCode
</span><span id="9" class="" >  def toString
</span><span id="10" class="" >
</span><span id="11" class="" >trait Matchable extends Any
</span><span id="12" class="" >
</span><span id="13" class="" >class AnyVal extends Any, Matchable
</span><span id="14" class="" >class Object extends Any, Matchable
</span></code></pre></div>

`Matchable` is currently a marker trait without any methods. Over time
we might migrate methods `getClass` and `isInstanceOf` to it, since these are closely related to pattern-matching.

### `Matchable` and Universal Equality

Methods that pattern-match on selectors of type `Any` will need a cast once the
Matchable warning is turned on. The most common such method is the universal
`equals` method. It will have to be written as in the following example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class C(val x: String):
</span><span id="1" class="" >
</span><span id="2" class="" >  override def equals(that: Any): Boolean =
</span><span id="3" class="" >    that.asInstanceOf[Matchable] match
</span><span id="4" class="" >      case that: C =&gt; this.x == that.x
</span><span id="5" class="" >      case _ =&gt; false
</span></code></pre></div>

The cast of `that` to `Matchable` serves as an indication that universal equality
is unsafe in the presence of abstract types and opaque types since it cannot properly distinguish the meaning of a type from its representation. The cast
is guaranteed to succeed at run-time since `Any` and `Matchable` both erase to
`Object`.

For instance, consider the definitions

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >opaque type Meter = Double
</span><span id="1" class="" >def Meter(x: Double) = x
</span><span id="2" class="" >
</span><span id="3" class="" >opaque type Second = Double
</span><span id="4" class="" >def Second(x: Double) = x
</span></code></pre></div>

Here, universal `equals` will return true for

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >Meter(10).equals(Second(10))
</span></code></pre></div>

even though this is clearly false mathematically. With [multiversal equality](../contextual/multiversal-equality.html) one can mitigate that problem somewhat by turning

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >Meter(10) == Second(10)
</span></code></pre></div>into a type error.
