---
title: "Trait Parameters"
next-page: /scala3/reference/other-new-features/transparent-traits
num: 35
type: section
previous-page: /scala3/reference/other-new-features
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/other-new-features/trait-parameters.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

Scala 3 allows traits to have parameters, just like classes have parameters.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Greeting(val name: String):
</span><span id="1" class="" >  def msg = s&quot;How are you, $name&quot;
</span><span id="2" class="" >
</span><span id="3" class="" >class C extends Greeting(&quot;Bob&quot;):
</span><span id="4" class="" >  println(msg)
</span></code></pre></div>

Arguments to a trait are evaluated immediately before the trait is initialized.

One potential issue with trait parameters is how to prevent
ambiguities. For instance, you might try to extend `Greeting` twice,
with different parameters.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class D extends C, Greeting(&quot;Bill&quot;) // error: parameter passed twice
</span></code></pre></div>

Should this print "Bob" or "Bill"? In fact this program is illegal,
because it violates the second rule of the following for trait parameters:

1. If a class `C` extends a parameterized trait `T`, and its superclass does not, `C` _must_ pass arguments to `T`.

2. If a class `C` extends a parameterized trait `T`, and its superclass does as well, `C` _must not_  pass arguments to `T`.

3. Traits must never pass arguments to parent traits.

Here's a trait extending the parameterized trait `Greeting`.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait FormalGreeting extends Greeting:
</span><span id="1" class="" >  override def msg = s&quot;How do you do, $name&quot;
</span></code></pre></div>

As is required, no arguments are passed to `Greeting`. However, this poses an issue
when defining a class that extends `FormalGreeting`:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class E extends FormalGreeting // error: missing arguments for `Greeting`.
</span></code></pre></div>

The correct way to write `E` is to extend both `Greeting` and
`FormalGreeting` (in either order):

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class E extends Greeting(&quot;Bob&quot;), FormalGreeting
</span></code></pre></div>

### Traits With Context Parameters

This "explicit extension required" rule is relaxed if the missing trait contains only
[context parameters]({% link _scala3-reference/contextual/using-clauses.md %}). In that case the trait reference is
implicitly inserted as an additional parent with inferred arguments. For instance,
here's a variant of greetings where the addressee is a context parameter of type
`ImpliedName`:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case class ImpliedName(name: String):
</span><span id="1" class="" >  override def toString = name
</span><span id="2" class="" >
</span><span id="3" class="" >trait ImpliedGreeting(using val iname: ImpliedName):
</span><span id="4" class="" >  def msg = s&quot;How are you, $iname&quot;
</span><span id="5" class="" >
</span><span id="6" class="" >trait ImpliedFormalGreeting extends ImpliedGreeting:
</span><span id="7" class="" >  override def msg = s&quot;How do you do, $iname&quot;
</span><span id="8" class="" >
</span><span id="9" class="" >class F(using iname: ImpliedName) extends ImpliedFormalGreeting
</span></code></pre></div>

The definition of `F` in the last line is implicitly expanded to

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class F(using iname: ImpliedName) extends
</span><span id="1" class="" >  Object,
</span><span id="2" class="" >  ImpliedGreeting(using iname),
</span><span id="3" class="" >  ImpliedFormalGreeting(using iname)
</span></code></pre></div>

Note the inserted reference to the super trait `ImpliedGreeting`, which was not mentioned explicitly.

## Reference

For more information, see [Scala SIP 25](http://docs.scala-lang.org/sips/pending/trait-parameters.html).
