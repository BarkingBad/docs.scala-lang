---
layout: singlepage-overview
title: "Dropped: Weak Conformance - More Details"
scala3: true
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/dropped-features/weak-conformance-spec.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

To simplify the underlying type theory, Scala 3 drops the notion of
[*weak conformance*](https://www.scala-lang.org/files/archive/spec/2.13/03-types.html#weak-conformance)
altogether. Instead, it provides more flexibility when
assigning a type to a constant expression. The new rule is:

- *If* a list of expressions `Es` appears as one of

  - the elements of a vararg parameter, or
  - the alternatives of an if-then-else or match expression, or
  - the body and catch results of a try expression,
- *and* all expressions have primitive numeric types, but they do not
  all have the same type,

- *then* the following is attempted:

  - the expressions `Es` are partitioned into `Int` constants on the
    one hand, and all other expressions on the other hand,
  - if all the other expressions have the same numeric type `T`
    (which can be one of `Byte`, `Short`, `Char`, `Int`, `Long`, `Float`,
    `Double`), possibly after widening, and if none of the `Int`
    literals would incur a loss of precision when converted to `T`,
    then they are thus converted (the other expressions are left
    unchanged regardless),
  - otherwise, the expressions `Es` are used unchanged.

  A loss of precision occurs for

  - an `Int -> Float` conversion of a constant
    `c` if `c.toFloat.toInt != c`
  - an `Int -> Byte` conversion of a constant
    `c` if `c.toByte.toInt != c`,
  - an `Int -> Short` conversion of a constant
    `c` if `c.toShort.toInt != c`.

### Examples

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >inline val b = 33
</span><span id="1" class="" >def f(): Int = b + 1
</span><span id="2" class="" >Array(b, 33, 5.5)      : Array[Double] // b is an inline val
</span><span id="3" class="" >Array(f(), 33, 5.5)    : Array[AnyVal] // f() is not a constant
</span><span id="4" class="" >Array(5, 11L)          : Array[Long]
</span><span id="5" class="" >Array(5, 11L, 5.5)     : Array[AnyVal] // Long and Double found
</span><span id="6" class="" >Array(1.0f, 2)         : Array[Float]
</span><span id="7" class="" >Array(1.0f, 1234567890): Array[AnyVal] // loss of precision
</span><span id="8" class="" >Array(b, 33, &apos;a&apos;)      : Array[Char]
</span><span id="9" class="" >Array(5.toByte, 11)    : Array[Byte]
</span></code></pre></div>
