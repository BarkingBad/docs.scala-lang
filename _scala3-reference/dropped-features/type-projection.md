---
title: "Dropped: General Type Projection"
next-page: /scala3/reference/dropped-features/do-while
num: 75
type: section
previous-page: /scala3/reference/dropped-features/existential-types
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/dropped-features/type-projection.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

Scala so far allowed general type projection `T#A` where `T` is an arbitrary type
and `A` names a type member of `T`.

Scala 3 disallows this if `T` is an abstract type (class types and type aliases
are fine). This change was made because unrestricted type projection
is [unsound](https://github.com/lampepfl/dotty/issues/1050).

This restriction rules out the [type-level encoding of a combinator
calculus](https://michid.wordpress.com/2010/01/29/scala-type-level-encoding-of-the-ski-calculus/).

To rewrite code using type projections on abstract types, consider using
path-dependent types or implicit parameters.
