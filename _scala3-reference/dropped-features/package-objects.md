---
title: "Dropped: Package Objects"
next-page: /scala3/reference/dropped-features/early-initializers
num: 78
type: section
previous-page: /scala3/reference/dropped-features/procedure-syntax
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/dropped-features/package-objects.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

Package objects

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >package object p {
</span><span id="1" class="" >  val a = ...
</span><span id="2" class="" >  def b = ...
</span><span id="3" class="" >}
</span></code></pre></div>

will be dropped. They are still available in Scala 3.0, but will be deprecated and removed afterwards.

Package objects are no longer needed since all kinds of definitions can now be written at the top-level. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >package p
</span><span id="1" class="" >type Labelled[T] = (String, T)
</span><span id="2" class="" >val a: Labelled[Int] = (&quot;count&quot;, 1)
</span><span id="3" class="" >def b = a._2
</span><span id="4" class="" >
</span><span id="5" class="" >case class C()
</span><span id="6" class="" >
</span><span id="7" class="" >extension (x: C) def pair(y: C) = (x, y)
</span></code></pre></div>

There may be several source files in a package containing such top-level definitions, and source files can freely mix top-level value, method, and type definitions with classes and objects.

The compiler generates synthetic objects that wrap top-level definitions falling into one of the following categories:

- all pattern, value, method, and type definitions,
- implicit classes and objects,
- companion objects of opaque type aliases.

If a source file `src.scala` contains such top-level definitions, they will be put in a synthetic object named `src$package`. The wrapping is transparent, however. The definitions in `src` can still be accessed as members of the enclosing package. The synthetic object will be placed last in the file,
after any other package clauses, imports, or object and class definitions.

**Note:** This means that
1. The name of a source file containing wrapped top-level definitions is relevant for binary compatibility. If the name changes, so does the name of the generated object and its class.

2. A top-level main method `def main(args: Array[String]): Unit = ...` is wrapped as any other method. If it appears
   in a source file `src.scala`, it could be invoked from the command line using a command like `scala src$package`. Since the
   "program name" is mangled it is recommended to always put `main` methods in explicitly named objects.

3. The notion of `private` is independent of whether a definition is wrapped or not. A `private` top-level definition is always visible from everywhere in the enclosing package.

4. If several top-level definitions are overloaded variants with the same name,
   they must all come from the same source file.

