---
title: "Polymorphic Function Types"
next-page: /scala3/reference/enums
num: 8
type: section
previous-page: /scala3/reference/new-types/dependent-function-types
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

A polymorphic function type is a function type which accepts type parameters.
For example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >// A polymorphic method:
</span><span id="1" class="" >def foo[A](xs: List[A]): List[A] = xs.reverse
</span><span id="2" class="" >
</span><span id="3" class="" >// A polymorphic function value:
</span><span id="4" class="" >val bar: [A] =&gt; List[A] =&gt; List[A]
</span><span id="5" class="" >//       ^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span id="6" class="" >//       a polymorphic function type
</span><span id="7" class="" >       = [A] =&gt; (xs: List[A]) =&gt; foo[A](xs)
</span></code></pre></div>

Scala already has _polymorphic methods_, i.e. methods which accepts type parameters.
Method `foo` above is an example, accepting a type parameter `A`.
So far, it
was not possible to turn such methods into polymorphic function values like `bar` above,
which can be passed as parameters to other functions, or returned as results.

In Scala 3 this is now possible. The type of the `bar` value above is

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >[A] =&gt; List[A] =&gt; List[A]
</span></code></pre></div>

This type describes function values which take a type `A` as a parameter,
then take a list of type `List[A]`, and return a list of the same type `List[A]`.

[More details](https://github.com/lampepfl/dotty/pull/4672)

## Example Usage

Polymorphic function type are particularly useful
when callers of a method are required to provide a
function which has to be polymorphic,
meaning that it should accept arbitrary types as part of its inputs.

For instance, consider the situation where we have
a data type to represent the expressions of a simple language
(consisting only of variables and function applications)
in a strongly-typed way:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >enum Expr[A]:
</span><span id="1" class="" >  case Var(name: String)
</span><span id="2" class="" >  case Apply[A, B](fun: Expr[B =&gt; A], arg: Expr[B]) extends Expr[A]
</span></code></pre></div>

We would like to provide a way for users to map a function
over all immediate subexpressions of a given `Expr`.
This requires the given function to be polymorphic,
since each subexpression may have a different type.
Here is how to implement this using polymorphic function types:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def mapSubexpressions[A](e: Expr[A])(f: [B] =&gt; Expr[B] =&gt; Expr[B]): Expr[A] =
</span><span id="1" class="" >  e match
</span><span id="2" class="" >    case Apply(fun, arg) =&gt; Apply(f(fun), f(arg))
</span><span id="3" class="" >    case Var(n) =&gt; Var(n)
</span></code></pre></div>

And here is how to use this function to _wrap_ each subexpression
in a given expression with a call to some `wrap` function,
defined as a variable:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val e0 = Apply(Var(&quot;f&quot;), Var(&quot;a&quot;))
</span><span id="1" class="" >val e1 = mapSubexpressions(e0)(
</span><span id="2" class="" >  [B] =&gt; (se: Expr[B]) =&gt; Apply(Var[B =&gt; B](&quot;wrap&quot;), se))
</span><span id="3" class="" >println(e1) // Apply(Apply(Var(wrap),Var(f)),Apply(Var(wrap),Var(a)))
</span></code></pre></div>

## Relationship With Type Lambdas

Polymorphic function types are not to be confused with
[_type lambdas_](type-lambdas.html).
While the former describes the _type_ of a polymorphic _value_,
the latter is an actual function value _at the type level_.

A good way of understanding the difference is to notice that
**_type lambdas are applied in types,
whereas polymorphic functions are applied in terms_**:
One would call the function `bar` above
by passing it a type argument `bar[Int]` _within a method body_.
On the other hand, given a type lambda such as `type F = [A] =>> List[A]`,
one would call `F` _within a type expression_, as in `type Bar = F[Int]`.
