---
title: Intersection Types
next-page: /scala3/reference/new-types/union-types
num: 3
type: section
previous-page: /scala3/reference/new-types
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/new-types/intersection-types.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

Used on types, the `&` operator creates an intersection type.

## Type Checking

The type `S & T` represents values that are of the type `S` and `T` at the same time.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Resettable:
</span><span id="1" class="" >  def reset(): Unit
</span><span id="2" class="" >
</span><span id="3" class="" >trait Growable[T]:
</span><span id="4" class="" >  def add(t: T): Unit
</span><span id="5" class="" >
</span><span id="6" class="" >def f(x: Resettable &amp; Growable[String]) =
</span><span id="7" class="" >  x.reset()
</span><span id="8" class="" >  x.add(&quot;first&quot;)
</span></code></pre></div>

The parameter `x` is required to be _both_ a `Resettable` and a
`Growable[String]`.

The members of an intersection type `A & B` are all the members of `A` and all
the members of `B`.  For instance `Resettable & Growable[String]`
has member methods `reset` and `add`.

`&` is _commutative_: `A & B` is the same type as `B & A`.

If a member appears in both `A` and `B`, its type in `A & B` is the intersection
of its type in `A` and its type in `B`. For instance, assume the definitions:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait A:
</span><span id="1" class="" >  def children: List[A]
</span><span id="2" class="" >
</span><span id="3" class="" >trait B:
</span><span id="4" class="" >  def children: List[B]
</span><span id="5" class="" >
</span><span id="6" class="" >val x: A &amp; B = new C
</span><span id="7" class="" >val ys: List[A &amp; B] = x.children
</span></code></pre></div>

The type of `children` in `A & B` is the intersection of `children`'s
type in `A` and its type in `B`, which is `List[A] & List[B]`. This
can be further simplified to `List[A & B]` because `List` is
covariant.

One might wonder how the compiler could come up with a definition for
`children` of type `List[A & B]` since what is given are `children`
definitions of type `List[A]` and `List[B]`. The answer is the compiler does not
need to. `A & B` is just a type that represents a set of requirements for
values of the type. At the point where a value is _constructed_, one
must make sure that all inherited members are correctly defined.
So if one defines a class `C` that inherits `A` and `B`, one needs
to give at that point a definition of a `children` method with the required type.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class C extends A, B:
</span><span id="1" class="" >  def children: List[A &amp; B] = ???
</span></code></pre></div>[More details](./intersection-types-spec.html)
