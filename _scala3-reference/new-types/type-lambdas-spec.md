---
layout: singlepage-overview
title: "Type Lambdas - More Details"
scala3: true
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/new-types/type-lambdas-spec.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

## Syntax

```
Type            ::=  ... |  TypeParamClause ‘=>>’ Type
TypeParamClause ::=  ‘[’ TypeParam {‘,’ TypeParam} ‘]’
TypeParam       ::=  {Annotation} (id [HkTypeParamClause] | ‘_’) TypeBounds
TypeBounds      ::=  [‘>:’ Type] [‘<:’ Type]
```

### Type Checking

A type lambda such as `[X] =>> F[X]` defines a function from types to types. The parameter(s) may carry bounds.
If a parameter is bounded, as in `[X >: L <: U] =>> F[X]` it is checked that arguments to the parameters conform to the bounds `L` and `U`.
Only the upper bound `U` can be F-bounded, i.e. `X` can appear in it.

## Subtyping Rules

Assume two type lambdas

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type TL1  =  [X &gt;: L1 &lt;: U1] =&gt;&gt; R1
</span><span id="1" class="" >type TL2  =  [X &gt;: L2 &lt;: U2] =&gt;&gt; R2
</span></code></pre></div>

Then `TL1 <: TL2`, if

- the type interval `L2..U2` is contained in the type interval `L1..U1` (i.e.
  `L1 <: L2` and `U2 <: U1`),
- `R1 <: R2`

Here we have relied on [alpha renaming](https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion) to match the two bound types `X`.

A partially applied type constructor such as `List` is assumed to be equivalent to
its eta expansion. I.e, `List = [X] =>> List[X]`. This allows type constructors to be compared with type lambdas.

## Relationship with Parameterized Type Definitions

A parameterized type definition

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type T[X] = R
</span></code></pre></div>

is regarded as a shorthand for an unparameterized definition with a type lambda as right-hand side:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type T = [X] =&gt;&gt; R
</span></code></pre></div>

If the type definition carries `+` or `-` variance annotations,
it is checked that the variance annotations are satisfied by the type lambda.
For instance,

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type F2[A, +B] = A =&gt; B
</span></code></pre></div>

expands to

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type F2 = [A, B] =&gt;&gt; A =&gt; B
</span></code></pre></div>

and at the same time it is checked that the parameter `B` appears covariantly in `A => B`.

A parameterized abstract type

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type T[X] &gt;: L &lt;: U
</span></code></pre></div>

is regarded as shorthand for an unparameterized abstract type with type lambdas as bounds.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type T &gt;: ([X] =&gt;&gt; L) &lt;: ([X] =&gt;&gt; U)
</span></code></pre></div>

However, if `L` is `Nothing` it is not parameterized, since `Nothing` is treated as a bottom type for all kinds. For instance,

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type T[X] &lt;: X =&gt; X
</span></code></pre></div>

is expanded to

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type T &gt;: Nothing &lt;: ([X] =&gt;&gt; X =&gt; X)
</span></code></pre></div>

instead of

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type T &gt;: ([X] =&gt;&gt; Nothing) &lt;: ([X] =&gt;&gt; X =&gt; X)
</span></code></pre></div>

The same expansions apply to type parameters. For instance,

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >[F[X] &lt;: Coll[X]]
</span></code></pre></div>

is treated as a shorthand for

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >[F &gt;: Nothing &lt;: [X] =&gt;&gt; Coll[X]]
</span></code></pre></div>

Abstract types and opaque type aliases remember the variances they were created with. So the type

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type F2[-A, +B]
</span></code></pre></div>

is known to be contravariant in `A` and covariant in `B` and can be instantiated only
with types that satisfy these constraints. Likewise

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >opaque type O[X] = List[X]
</span></code></pre></div>

`O` is known to be invariant (and not covariant, as its right-hand side would suggest). On the other hand, a transparent alias

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type O2[X] = List[X]
</span></code></pre></div>

would be treated as covariant, `X` is used covariantly on its right-hand side.

**Note**: The decision to treat `Nothing` as universal bottom type is provisional, and might be changed after further discussion.

**Note**: Scala 2 and 3 differ in that Scala 2 also treats `Any` as universal top-type. This is not done in Scala 3. See also the discussion on [kind polymorphism](../other-new-features/kind-polymorphism.html)

## Curried Type Parameters

The body of a type lambda can again be a type lambda. Example:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >type TL = [X] =&gt;&gt; [Y] =&gt;&gt; (X, Y)
</span></code></pre></div>

Currently, no special provision is made to infer type arguments to such curried type lambdas. This is left for future work.

