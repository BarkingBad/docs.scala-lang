---
title: "Dependent Function Types"
next-page: /scala3/reference/new-types/polymorphic-function-types
num: 7
type: section
previous-page: /scala3/reference/new-types/match-types
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

A dependent function type is a function type whose result depends
on the function's parameters. For example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Entry { type Key; val key: Key }
</span><span id="1" class="" >
</span><span id="2" class="" >def extractKey(e: Entry): e.Key = e.key          // a dependent method
</span><span id="3" class="" >
</span><span id="4" class="" >val extractor: (e: Entry) =&gt; e.Key = extractKey  // a dependent function value
</span><span id="5" class="" >//             ^^^^^^^^^^^^^^^^^^^
</span><span id="6" class="" >//             a dependent function type
</span></code></pre></div>

Scala already has _dependent methods_, i.e. methods where the result
type refers to some of the parameters of the method. Method
`extractKey` is an example. Its result type, `e.Key` refers to its
parameter `e` (we also say, `e.Key` _depends_ on `e`). But so far it
was not possible to turn such methods into function values, so that
they can be passed as parameters to other functions, or returned as
results. Dependent methods could not be turned into functions simply
because there was no type that could describe them.

In Scala 3 this is now possible. The type of the `extractor` value above is

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >(e: Entry) =&gt; e.Key
</span></code></pre></div>

This type describes function values that take any argument `e` of type
`Entry` and return a result of type `e.Key`.

Recall that a normal function type `A => B` is represented as an
instance of the [`Function1` trait](https://scala-lang.org/api/3.x/scala/Function1.html)
(i.e. `Function1[A, B]`) and analogously for functions with more parameters. Dependent functions
are also represented as instances of these traits, but they get an additional
refinement. In fact, the dependent function type above is just syntactic sugar for

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >Function1[Entry, Entry#Key]:
</span><span id="1" class="" >  def apply(e: Entry): e.Key
</span></code></pre></div>[More details](./dependent-function-types-spec.html)
