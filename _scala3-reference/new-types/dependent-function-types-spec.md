---
layout: singlepage-overview
title: "Dependent Function Types - More Details"
scala3: true
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/new-types/dependent-function-types-spec.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

Initial implementation in [PR #3464](https://github.com/lampepfl/dotty/pull/3464).

## Syntax

```
FunArgTypes       ::=  InfixType
                    |  ‘(’ [ FunArgType {',' FunArgType } ] ‘)’
                    |  ‘(’ TypedFunParam {',' TypedFunParam } ‘)’
TypedFunParam     ::=  id ‘:’ Type
```

Dependent function types associate to the right, e.g.
`(s: S) => (t: T) => U` is the same as `(s: S) => ((t: T) => U)`.

## Implementation

Dependent function types are shorthands for class types that define `apply`
methods with a dependent result type. Dependent function types desugar to
refinement types of `scala.FunctionN`. A dependent function type
`(x1: K1, ..., xN: KN) => R` of arity `N` translates to:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >FunctionN[K1, ..., Kn, R&apos;]:
</span><span id="1" class="" >  def apply(x1: K1, ..., xN: KN): R
</span></code></pre></div>

where the result type parameter `R'` is the least upper approximation of the
precise result type `R` without any reference to value parameters `x1, ..., xN`.

The syntax and semantics of anonymous dependent functions is identical to the
one of regular functions. Eta expansion is naturally generalized to produce
dependent function types for methods with dependent result types.

Dependent functions can be implicit, and generalize to arity `N > 22` in the
same way that other functions do, see
[the corresponding documentation](../dropped-features/limit22.html).

## Examples

The example below defines a trait `C` and the two dependent function types
`DF` and `IDF` and prints the results of the respective function applications:

[depfuntype.scala]: https://github.com/lampepfl/dotty/blob/master/tests/pos/depfuntype.scala

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait C { type M; val m: M }
</span><span id="1" class="" >
</span><span id="2" class="" >type DF = (x: C) =&gt; x.M
</span><span id="3" class="" >
</span><span id="4" class="" >type IDF = (x: C) ?=&gt; x.M
</span><span id="5" class="" >
</span><span id="6" class="" >@main def test =
</span><span id="7" class="" >  val c = new C { type M = Int; val m = 3 }
</span><span id="8" class="" >
</span><span id="9" class="" >  val depfun: DF = (x: C) =&gt; x.m
</span><span id="10" class="" >  val t = depfun(c)
</span><span id="11" class="" >  println(s&quot;t=$t&quot;)   // prints &quot;t=3&quot;
</span><span id="12" class="" >
</span><span id="13" class="" >  val idepfun: IDF = summon[C].m
</span><span id="14" class="" >  val u = idepfun(using c)
</span><span id="15" class="" >  println(s&quot;u=$u&quot;)   // prints &quot;u=3&quot;
</span></code></pre></div>

In the following example the depend type `f.Eff` refers to the effect type `CanThrow`:

[eff-dependent.scala]: https://github.com/lampepfl/dotty/blob/master/tests/run/eff-dependent.scala

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Effect
</span><span id="1" class="" >
</span><span id="2" class="" >// Type X =&gt; Y
</span><span id="3" class="" >abstract class Fun[-X, +Y]:
</span><span id="4" class="" >  type Eff &lt;: Effect
</span><span id="5" class="" >  def apply(x: X): Eff ?=&gt; Y
</span><span id="6" class="" >
</span><span id="7" class="" >class CanThrow extends Effect
</span><span id="8" class="" >class CanIO extends Effect
</span><span id="9" class="" >
</span><span id="10" class="" >given ct: CanThrow = new CanThrow
</span><span id="11" class="" >given ci: CanIO = new CanIO
</span><span id="12" class="" >
</span><span id="13" class="" >class I2S extends Fun[Int, String]:
</span><span id="14" class="" >  type Eff = CanThrow
</span><span id="15" class="" >  def apply(x: Int) = x.toString
</span><span id="16" class="" >
</span><span id="17" class="" >class S2I extends Fun[String, Int]:
</span><span id="18" class="" >  type Eff = CanIO
</span><span id="19" class="" >  def apply(x: String) = x.length
</span><span id="20" class="" >
</span><span id="21" class="" >// def map(f: A =&gt; B)(xs: List[A]): List[B]
</span><span id="22" class="" >def map[A, B](f: Fun[A, B])(xs: List[A]): f.Eff ?=&gt; List[B] =
</span><span id="23" class="" >  xs.map(f.apply)
</span><span id="24" class="" >
</span><span id="25" class="" >// def mapFn[A, B]: (A =&gt; B) -&gt; List[A] -&gt; List[B]
</span><span id="26" class="" >def mapFn[A, B]: (f: Fun[A, B]) =&gt; List[A] =&gt; f.Eff ?=&gt; List[B] =
</span><span id="27" class="" >  f =&gt; xs =&gt; map(f)(xs)
</span><span id="28" class="" >
</span><span id="29" class="" >// def compose(f: A =&gt; B)(g: B =&gt; C)(x: A): C
</span><span id="30" class="" >def compose[A, B, C](f: Fun[A, B])(g: Fun[B, C])(x: A):
</span><span id="31" class="" >  f.Eff ?=&gt; g.Eff ?=&gt; C =
</span><span id="32" class="" >  g(f(x))
</span><span id="33" class="" >
</span><span id="34" class="" >// def composeFn: (A =&gt; B) -&gt; (B =&gt; C) -&gt; A -&gt; C
</span><span id="35" class="" >def composeFn[A, B, C]:
</span><span id="36" class="" >  (f: Fun[A, B]) =&gt; (g: Fun[B, C]) =&gt; A =&gt; f.Eff ?=&gt; g.Eff ?=&gt; C =
</span><span id="37" class="" >  f =&gt; g =&gt; x =&gt; compose(f)(g)(x)
</span><span id="38" class="" >
</span><span id="39" class="" >@main def test =
</span><span id="40" class="" >  val i2s = new I2S
</span><span id="41" class="" >  val s2i = new S2I
</span><span id="42" class="" >
</span><span id="43" class="" >  assert(mapFn(i2s)(List(1, 2, 3)).mkString == &quot;123&quot;)
</span><span id="44" class="" >  assert(composeFn(i2s)(s2i)(22) == 2)
</span></code></pre></div>

### Type Checking

After desugaring no additional typing rules are required for dependent function types.
