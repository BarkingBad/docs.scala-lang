---
layout: singlepage-overview
title: "Numeric Literals"
scala3: true
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/experimental/numeric-literals.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

**Note**: This feature is not yet part of the Scala 3 language definition. It can be made available by a language import:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.language.experimental.genericNumberLiterals
</span></code></pre></div>

In Scala 2, numeric literals were confined to the primitive numeric types `Int`, `Long`, `Float`, and `Double`. Scala 3 allows to write numeric literals also for user-defined types. Example:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val x: Long = -10_000_000_000
</span><span id="1" class="" >val y: BigInt = 0x123_abc_789_def_345_678_901
</span><span id="2" class="" >val z: BigDecimal = 110_222_799_799.99
</span><span id="3" class="" >
</span><span id="4" class="" >(y: BigInt) match
</span><span id="5" class="" >  case 123_456_789_012_345_678_901 =&gt;
</span></code></pre></div>

The syntax of numeric literals is the same as before, except there are no pre-set limits
how large they can be.

### Meaning of Numeric Literals

The meaning of a numeric literal is determined as follows:

- If the literal ends with `l` or `L`, it is a `Long` integer (and must fit in its legal range).
- If the literal ends with `f` or `F`, it is a single precision floating point number of type `Float`.
- If the literal ends with `d` or `D`, it is a double precision floating point number of type `Double`.

In each of these cases the conversion to a number is exactly as in Scala 2 or in Java. If a numeric literal does _not_ end in one of these suffixes, its meaning is determined by the expected type:

1. If the expected type is `Int`, `Long`, `Float`, or `Double`, the literal is
   treated as a standard literal of that type.
2. If the expected type is a fully defined type `T` that has a given instance of type
   `scala.util.FromDigits[T]`, the literal is converted to a value of type `T` by passing it as an argument to
   the `fromDigits` method of that instance (more details below).
3. Otherwise, the literal is treated as a `Double` literal (if it has a decimal point or an
   exponent), or as an `Int` literal (if not). (This last possibility is again as in Scala 2 or Java.)

With these rules, the definition

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val x: Long = -10_000_000_000
</span></code></pre></div>

is legal by rule (1), since the expected type is `Long`. The definitions

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val y: BigInt = 0x123_abc_789_def_345_678_901
</span><span id="1" class="" >val z: BigDecimal = 111222333444.55
</span></code></pre></div>

are legal by rule (2), since both `BigInt` and `BigDecimal` have `FromDigits` instances
(which implement the `FromDigits` subclasses `FromDigits.WithRadix` and `FromDigits.Decimal`, respectively).
On the other hand,

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val x = -10_000_000_000
</span></code></pre></div>

gives a type error, since without an expected type `-10_000_000_000` is treated by rule (3) as an `Int` literal, but it is too large for that type.

### The FromDigits Trait

To allow numeric literals, a type simply has to define a `given` instance of the
`scala.util.FromDigits` type class, or one of its subclasses. `FromDigits` is defined
as follows:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait FromDigits[T]:
</span><span id="1" class="" >  def fromDigits(digits: String): T
</span></code></pre></div>

Implementations of the `fromDigits` convert strings of digits to the values of the
implementation type `T`.
The `digits` string consists of digits between `0` and `9`, possibly preceded by a
sign ("+" or "-"). Number separator characters `_` are filtered out before
the string is passed to `fromDigits`.

The companion object `FromDigits` also defines subclasses of `FromDigits` for
whole numbers with a given radix, for numbers with a decimal point, and for
numbers that can have both a decimal point and an exponent:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object FromDigits:
</span><span id="1" class="" >
</span><span id="2" class="" >  /** A subclass of `FromDigits` that also allows to convert whole
</span><span id="3" class="" >   *  number literals with a radix other than 10
</span><span id="4" class="" >   */
</span><span id="5" class="" >  trait WithRadix[T] extends FromDigits[T]:
</span><span id="6" class="" >    def fromDigits(digits: String): T = fromDigits(digits, 10)
</span><span id="7" class="" >    def fromDigits(digits: String, radix: Int): T
</span><span id="8" class="" >
</span><span id="9" class="" >  /** A subclass of `FromDigits` that also allows to convert number
</span><span id="10" class="" >   *  literals containing a decimal point &quot;.&quot;.
</span><span id="11" class="" >   */
</span><span id="12" class="" >  trait Decimal[T] extends FromDigits[T]
</span><span id="13" class="" >
</span><span id="14" class="" >  /** A subclass of `FromDigits`that allows also to convert number
</span><span id="15" class="" >   *  literals containing a decimal point &quot;.&quot; or an
</span><span id="16" class="" >   *  exponent `(&apos;e&apos; | &apos;E&apos;)[&apos;+&apos; | &apos;-&apos;]digit digit*`.
</span><span id="17" class="" >   */
</span><span id="18" class="" >  trait Floating[T] extends Decimal[T]
</span></code></pre></div>

A user-defined number type can implement one of those, which signals to the compiler
that hexadecimal numbers, decimal points, or exponents are also accepted in literals
for this type.

### Error Handling

`FromDigits` implementations can signal errors by throwing exceptions of some subtype
of `FromDigitsException`. `FromDigitsException` is defined with three subclasses in the
`FromDigits` object as follows:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >abstract class FromDigitsException(msg: String) extends NumberFormatException(msg)
</span><span id="1" class="" >
</span><span id="2" class="" >class NumberTooLarge (msg: String = &quot;number too large&quot;)         extends FromDigitsException(msg)
</span><span id="3" class="" >class NumberTooSmall (msg: String = &quot;number too small&quot;)         extends FromDigitsException(msg)
</span><span id="4" class="" >class MalformedNumber(msg: String = &quot;malformed number literal&quot;) extends FromDigitsException(msg)
</span></code></pre></div>

### Example

As a fully worked out example, here is an implementation of a new numeric class, `BigFloat`, that accepts numeric literals. `BigFloat` is defined in terms of a `BigInt` mantissa and an `Int` exponent:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case class BigFloat(mantissa: BigInt, exponent: Int):
</span><span id="1" class="" >  override def toString = s&quot;${mantissa}e${exponent}&quot;
</span></code></pre></div>

`BigFloat` literals can have a decimal point as well as an exponent. E.g. the following expression
should produce the `BigFloat` number `BigFloat(-123, 997)`:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >-0.123E+1000: BigFloat
</span></code></pre></div>

The companion object of `BigFloat` defines an `apply` constructor method to construct a `BigFloat`
from a `digits` string. Here is a possible implementation:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object BigFloat:
</span><span id="1" class="" >  import scala.util.FromDigits
</span><span id="2" class="" >
</span><span id="3" class="" >  def apply(digits: String): BigFloat =
</span><span id="4" class="" >    val (mantissaDigits, givenExponent) =
</span><span id="5" class="" >      digits.toUpperCase.split(&apos;E&apos;) match
</span><span id="6" class="" >        case Array(mantissaDigits, edigits) =&gt;
</span><span id="7" class="" >          val expo =
</span><span id="8" class="" >            try FromDigits.intFromDigits(edigits)
</span><span id="9" class="" >            catch case ex: FromDigits.NumberTooLarge =&gt;
</span><span id="10" class="" >              throw FromDigits.NumberTooLarge(s&quot;exponent too large: $edigits&quot;)
</span><span id="11" class="" >          (mantissaDigits, expo)
</span><span id="12" class="" >        case Array(mantissaDigits) =&gt;
</span><span id="13" class="" >          (mantissaDigits, 0)
</span><span id="14" class="" >    val (intPart, exponent) =
</span><span id="15" class="" >      mantissaDigits.split(&apos;.&apos;) match
</span><span id="16" class="" >        case Array(intPart, decimalPart) =&gt;
</span><span id="17" class="" >          (intPart ++ decimalPart, givenExponent - decimalPart.length)
</span><span id="18" class="" >        case Array(intPart) =&gt;
</span><span id="19" class="" >          (intPart, givenExponent)
</span><span id="20" class="" >    BigFloat(BigInt(intPart), exponent)
</span></code></pre></div>

To accept `BigFloat` literals, all that's needed in addition is a `given` instance of type
`FromDigits.Floating[BigFloat]`:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >given FromDigits: FromDigits.Floating[BigFloat] with
</span><span id="1" class="" >    def fromDigits(digits: String) = apply(digits)
</span><span id="2" class="" >end BigFloat
</span></code></pre></div>

Note that the `apply` method does not check the format of the `digits` argument. It is
assumed that only valid arguments are passed. For calls coming from the compiler
that assumption is valid, since the compiler will first check whether a numeric
literal has the correct format before it gets passed on to a conversion method.

### Compile-Time Errors

With the setup of the previous section, a literal like

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >1e10_0000_000_000: BigFloat
</span></code></pre></div>

would be expanded by the compiler to

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >BigFloat.FromDigits.fromDigits(&quot;1e100000000000&quot;)
</span></code></pre></div>

Evaluating this expression throws a `NumberTooLarge` exception at run time. We would like it to
produce a compile-time error instead. We can achieve this by tweaking the `BigFloat` class
with a small dose of metaprogramming. The idea is to turn the `fromDigits` method
into a macro, i.e. make it an inline method with a splice as right-hand side.
To do this, replace the `FromDigits` instance in the `BigFloat` object by the following two definitions:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object BigFloat:
</span><span id="1" class="" >  ...
</span><span id="2" class="" >
</span><span id="3" class="" >  class FromDigits extends FromDigits.Floating[BigFloat]:
</span><span id="4" class="" >    def fromDigits(digits: String) = apply(digits)
</span><span id="5" class="" >
</span><span id="6" class="" >  given FromDigits with
</span><span id="7" class="" >    override inline def fromDigits(digits: String) = ${
</span><span id="8" class="" >      fromDigitsImpl(&apos;digits)
</span><span id="9" class="" >    }
</span></code></pre></div>

Note that an inline method cannot directly fill in for an abstract method, since it produces
no code that can be executed at runtime. That is why we define an intermediary class
`FromDigits` that contains a fallback implementation which is then overridden by the inline
method in the `FromDigits` given instance. That method is defined in terms of a macro
implementation method `fromDigitsImpl`. Here is its definition:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >private def fromDigitsImpl(digits: Expr[String])(using ctx: Quotes): Expr[BigFloat] =
</span><span id="1" class="" >    digits.value match
</span><span id="2" class="" >      case Some(ds) =&gt;
</span><span id="3" class="" >        try
</span><span id="4" class="" >          val BigFloat(m, e) = apply(ds)
</span><span id="5" class="" >          &apos;{BigFloat(${Expr(m)}, ${Expr(e)})}
</span><span id="6" class="" >        catch case ex: FromDigits.FromDigitsException =&gt;
</span><span id="7" class="" >          ctx.error(ex.getMessage)
</span><span id="8" class="" >          &apos;{BigFloat(0, 0)}
</span><span id="9" class="" >      case None =&gt;
</span><span id="10" class="" >        &apos;{apply($digits)}
</span><span id="11" class="" >end BigFloat
</span></code></pre></div>

The macro implementation takes an argument of type `Expr[String]` and yields
a result of type `Expr[BigFloat]`. It tests whether its argument is a constant
string. If that is the case, it converts the string using the `apply` method
and lifts the resulting `BigFloat` back to `Expr` level. For non-constant
strings `fromDigitsImpl(digits)` is simply `apply(digits)`, i.e. everything is
evaluated at runtime in this case.

The interesting part is the `catch` part of the case where `digits` is constant.
If the `apply` method throws a `FromDigitsException`, the exception's message is issued as a compile time error in the `ctx.error(ex.getMessage)` call.

With this new implementation, a definition like

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val x: BigFloat = 1234.45e3333333333
</span></code></pre></div>

would give a compile time error message:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >3 |  val x: BigFloat = 1234.45e3333333333
</span><span id="1" class="" >  |                    ^^^^^^^^^^^^^^^^^^
</span><span id="2" class="" >  |                    exponent too large: 3333333333
</span></code></pre></div>
