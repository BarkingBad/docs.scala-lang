---
layout: singlepage-overview
title: "Erased Definitions"
scala3: true
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/experimental/erased-defs.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

`erased` is a modifier that expresses that some definition or expression is erased by the compiler instead of being represented in the compiled output. It is not yet part of the Scala language standard. To enable `erased`, turn on the language feature
`experimental.erasedDefinitions`. This can be done with a language import

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.language.experimental.erasedDefinitions
</span></code></pre></div>

or by setting the command line option `-language:experimental.erasedDefinitions`.
Erased definitions must be in an experimental scope (see [../other-new-features/experimental-defs.md]).

## Why erased terms?

Let's describe the motivation behind erased terms with an example. In the
following we show a simple state machine which can be in a state `On` or `Off`.
The machine can change state from `Off` to `On` with `turnedOn` only if it is
currently `Off`. This last constraint is captured with the `IsOff[S]` contextual
evidence which only exists for `IsOff[Off]`. For example, not allowing calling
`turnedOn` on in an `On` state as we would require an evidence of type
`IsOff[On]` that will not be found.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >sealed trait State
</span><span id="1" class="" >final class On extends State
</span><span id="2" class="" >final class Off extends State
</span><span id="3" class="" >
</span><span id="4" class="" >@implicitNotFound(&quot;State must be Off&quot;)
</span><span id="5" class="" >class IsOff[S &lt;: State]
</span><span id="6" class="" >object IsOff:
</span><span id="7" class="" >  given isOff: IsOff[Off] = new IsOff[Off]
</span><span id="8" class="" >
</span><span id="9" class="" >class Machine[S &lt;: State]:
</span><span id="10" class="" >  def turnedOn(using IsOff[S]): Machine[On] = new Machine[On]
</span><span id="11" class="" >
</span><span id="12" class="" >val m = new Machine[Off]
</span><span id="13" class="" >m.turnedOn
</span><span id="14" class="" >m.turnedOn.turnedOn // ERROR
</span><span id="15" class="" >//                 ^
</span><span id="16" class="" >//                  State must be Off
</span></code></pre></div>

Note that in the code above the actual context arguments for `IsOff` are never
used at runtime; they serve only to establish the right constraints at compile
time. As these terms are never used at runtime there is not real need to have
them around, but they still need to be present in some form in the generated
code to be able to do separate compilation and retain binary compatibility. We
introduce _erased terms_ to overcome this limitation: we are able to enforce the
right constrains on terms at compile time. These terms have no run time
semantics and they are completely erased.

## How to define erased terms?

Parameters of methods and functions can be declared as erased, placing `erased`
in front of a parameter list (like `given`).

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def methodWithErasedEv(erased ev: Ev): Int = 42
</span><span id="1" class="" >
</span><span id="2" class="" >val lambdaWithErasedEv: erased Ev =&gt; Int =
</span><span id="3" class="" >  (erased ev: Ev) =&gt; 42
</span></code></pre></div>

`erased` parameters will not be usable for computations, though they can be used
as arguments to other `erased` parameters.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def methodWithErasedInt1(erased i: Int): Int =
</span><span id="1" class="" >  i + 42 // ERROR: can not use i
</span><span id="2" class="" >
</span><span id="3" class="" >def methodWithErasedInt2(erased i: Int): Int =
</span><span id="4" class="" >  methodWithErasedInt1(i) // OK
</span></code></pre></div>

Not only parameters can be marked as erased, `val` and `def` can also be marked
with `erased`. These will also only be usable as arguments to `erased`
parameters.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >erased val erasedEvidence: Ev = ...
</span><span id="1" class="" >methodWithErasedEv(erasedEvidence)
</span></code></pre></div>

## What happens with erased values at runtime?

As `erased` are guaranteed not to be used in computations, they can and will be
erased.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >// becomes def methodWithErasedEv(): Int at runtime
</span><span id="1" class="" >def methodWithErasedEv(erased ev: Ev): Int = ...
</span><span id="2" class="" >
</span><span id="3" class="" >def evidence1: Ev = ...
</span><span id="4" class="" >erased def erasedEvidence2: Ev = ... // does not exist at runtime
</span><span id="5" class="" >erased val erasedEvidence3: Ev = ... // does not exist at runtime
</span><span id="6" class="" >
</span><span id="7" class="" >// evidence1 is not evaluated and no value is passed to methodWithErasedEv
</span><span id="8" class="" >methodWithErasedEv(evidence1)
</span></code></pre></div>

## State machine with erased evidence example

The following example is an extended implementation of a simple state machine
which can be in a state `On` or `Off`. The machine can change state from `Off`
to `On` with `turnedOn` only if it is currently `Off`, conversely from `On` to
`Off` with `turnedOff` only if it is currently `On`. These last constraint are
captured with the `IsOff[S]` and `IsOn[S]` given evidence only exist for
`IsOff[Off]` and `IsOn[On]`. For example, not allowing calling `turnedOff` on in
an `Off` state as we would require an evidence `IsOn[Off]` that will not be
found.

As the given evidences of `turnedOn` and `turnedOff` are not used in the
bodies of those functions we can mark them as `erased`. This will remove the
evidence parameters at runtime, but we would still evaluate the `isOn` and
`isOff` givens that were found as arguments. As `isOn` and `isOff` are not
used except as `erased` arguments, we can mark them as `erased`, hence removing
the evaluation of the `isOn` and `isOff` evidences.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.annotation.implicitNotFound
</span><span id="1" class="" >
</span><span id="2" class="" >sealed trait State
</span><span id="3" class="" >final class On extends State
</span><span id="4" class="" >final class Off extends State
</span><span id="5" class="" >
</span><span id="6" class="" >@implicitNotFound(&quot;State must be Off&quot;)
</span><span id="7" class="" >class IsOff[S &lt;: State]
</span><span id="8" class="" >object IsOff:
</span><span id="9" class="" >  // will not be called at runtime for turnedOn, the
</span><span id="10" class="" >  // compiler will only require that this evidence exists
</span><span id="11" class="" >  given IsOff[Off] = new IsOff[Off]
</span><span id="12" class="" >
</span><span id="13" class="" >@implicitNotFound(&quot;State must be On&quot;)
</span><span id="14" class="" >class IsOn[S &lt;: State]
</span><span id="15" class="" >object IsOn:
</span><span id="16" class="" >  // will not exist at runtime, the compiler will only
</span><span id="17" class="" >  // require that this evidence exists at compile time
</span><span id="18" class="" >  erased given IsOn[On] = new IsOn[On]
</span><span id="19" class="" >
</span><span id="20" class="" >class Machine[S &lt;: State] private ():
</span><span id="21" class="" >  // ev will disappear from both functions
</span><span id="22" class="" >  def turnedOn(using erased ev: IsOff[S]): Machine[On] = new Machine[On]
</span><span id="23" class="" >  def turnedOff(using erased ev: IsOn[S]): Machine[Off] = new Machine[Off]
</span><span id="24" class="" >
</span><span id="25" class="" >object Machine:
</span><span id="26" class="" >  def newMachine(): Machine[Off] = new Machine[Off]
</span><span id="27" class="" >
</span><span id="28" class="" >@main def test =
</span><span id="29" class="" >  val m = Machine.newMachine()
</span><span id="30" class="" >  m.turnedOn
</span><span id="31" class="" >  m.turnedOn.turnedOff
</span><span id="32" class="" >
</span><span id="33" class="" >  // m.turnedOff
</span><span id="34" class="" >  //            ^
</span><span id="35" class="" >  //            State must be On
</span><span id="36" class="" >
</span><span id="37" class="" >  // m.turnedOn.turnedOn
</span><span id="38" class="" >  //                    ^
</span><span id="39" class="" >  //                    State must be Off
</span></code></pre></div>

Note that in [Inline](../metaprogramming/inline.html) we discussed `erasedValue` and inline
matches. `erasedValue` is implemented with `erased`, so the state machine above
can be encoded as follows:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.compiletime.*
</span><span id="1" class="" >
</span><span id="2" class="" >sealed trait State
</span><span id="3" class="" >final class On extends State
</span><span id="4" class="" >final class Off extends State
</span><span id="5" class="" >
</span><span id="6" class="" >class Machine[S &lt;: State]:
</span><span id="7" class="" >  transparent inline def turnOn(): Machine[On] =
</span><span id="8" class="" >    inline erasedValue[S] match
</span><span id="9" class="" >      case _: Off =&gt; new Machine[On]
</span><span id="10" class="" >      case _: On  =&gt; error(&quot;Turning on an already turned on machine&quot;)
</span><span id="11" class="" >
</span><span id="12" class="" >  transparent inline def turnOff(): Machine[Off] =
</span><span id="13" class="" >    inline erasedValue[S] match
</span><span id="14" class="" >      case _: On  =&gt; new Machine[Off]
</span><span id="15" class="" >      case _: Off =&gt; error(&quot;Turning off an already turned off machine&quot;)
</span><span id="16" class="" >
</span><span id="17" class="" >object Machine:
</span><span id="18" class="" >  def newMachine(): Machine[Off] =
</span><span id="19" class="" >    println(&quot;newMachine&quot;)
</span><span id="20" class="" >    new Machine[Off]
</span><span id="21" class="" >end Machine
</span><span id="22" class="" >
</span><span id="23" class="" >@main def test =
</span><span id="24" class="" >  val m = Machine.newMachine()
</span><span id="25" class="" >  m.turnOn()
</span><span id="26" class="" >  m.turnOn().turnOff()
</span><span id="27" class="" >  m.turnOn().turnOn() // error: Turning on an already turned on machine
</span></code></pre></div>

## Erased Classes

`erased` can also be used as a modifier for a class. An erased class is intended to be used only in erased definitions. If the type of a val definition or parameter is
a (possibly aliased, refined, or instantiated) erased class, the definition is assumed to be `erased` itself. Likewise, a method with an erased class return type is assumed to be `erased` itself. Since given instances expand to vals and defs, they are also assumed to be erased if the type they produce is an erased class. Finally
function types with erased classes as arguments turn into erased function types.

Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >erased class CanRead
</span><span id="1" class="" >
</span><span id="2" class="" >val x: CanRead = ...        // `x` is turned into an erased val
</span><span id="3" class="" >val y: CanRead =&gt; Int = ... // the function is turned into an erased function
</span><span id="4" class="" >def f(x: CanRead) = ...     // `f` takes an erased parameter
</span><span id="5" class="" >def g(): CanRead = ...      // `g` is turned into an erased def
</span><span id="6" class="" >given CanRead = ...         // the anonymous given is assumed to be erased
</span></code></pre></div>

The code above expands to

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >erased class CanRead
</span><span id="1" class="" >
</span><span id="2" class="" >erased val x: CanRead = ...
</span><span id="3" class="" >val y: (erased CanRead) =&gt; Int = ...
</span><span id="4" class="" >def f(erased x: CanRead) = ...
</span><span id="5" class="" >erased def g(): CanRead = ...
</span><span id="6" class="" >erased given CanRead = ...
</span></code></pre></div>

After erasure, it is checked that no references to values of erased classes remain and that no instances of erased classes are created. So the following would be an error:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val err: Any = CanRead() // error: illegal reference to erased class CanRead
</span></code></pre></div>

Here, the type of `err` is `Any`, so `err` is not considered erased. Yet its initializing value is a reference to the erased class `CanRead`.

[More Details](./erased-defs-spec.html)
