---
layout: singlepage-overview
title: "Named Type Arguments"
scala3: true
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/experimental/named-typeargs.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

**Note:** This feature is implemented in Scala 3, but is not expected to be part of Scala 3.0.

Type arguments of methods can now be specified by name as well as by position. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def construct[Elem, Coll[_]](xs: Elem*): Coll[Elem] = ???
</span><span id="1" class="" >
</span><span id="2" class="" >val xs1 = construct[Coll = List, Elem = Int](1, 2, 3)
</span><span id="3" class="" >val xs2 = construct[Coll = List](1, 2, 3)
</span></code></pre></div>

Similar to a named value argument `(x = e)`, a named type argument
`[X = T]` instantiates the type parameter `X` to the type `T`.
Named type arguments do not have to be in order (see `xs1` above) and
unspecified arguments are inferred by the compiler (see `xs2` above).
Type arguments must be all named or un-named, mixtures of named and
positional type arguments are not supported.

## Motivation

The main benefit of named type arguments is that unlike positional arguments,
you are allowed to omit passing arguments for some parameters, like in the
definition of `xs2` above. A missing type argument is inferred as usual by
local type inference. This is particularly useful in situations where some type
arguments can be easily inferred from others.

[More details](./named-typeargs-spec.md)
