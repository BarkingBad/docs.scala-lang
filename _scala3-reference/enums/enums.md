---
title: "Enumerations"
next-page: /scala3/reference/enums/adts
num: 10
type: section
previous-page: /scala3/reference/enums
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/enums/enums.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

An enumeration is used to define a type consisting of a set of named values.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >enum Color:
</span><span id="1" class="" >  case Red, Green, Blue
</span></code></pre></div>

This defines a new `sealed` class, `Color`, with three values, `Color.Red`,
`Color.Green`, `Color.Blue`.  The color values are members of `Color`s
companion object.

### Parameterized enums

Enums can be parameterized.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >enum Color(val rgb: Int):
</span><span id="1" class="" >  case Red   extends Color(0xFF0000)
</span><span id="2" class="" >  case Green extends Color(0x00FF00)
</span><span id="3" class="" >  case Blue  extends Color(0x0000FF)
</span></code></pre></div>

As the example shows, you can define the parameter value by using an
explicit extends clause.

### Methods defined for enums

The values of an enum correspond to unique integers. The integer
associated with an enum value is returned by its `ordinal` method:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >scala&gt; val red = Color.Red
</span><span id="1" class="" >val red: Color = Red
</span><span id="2" class="" >scala&gt; red.ordinal
</span><span id="3" class="" >val res0: Int = 0
</span></code></pre></div>

The companion object of an enum also defines three utility methods.
The `valueOf` method obtains an enum value
by its name. The `values` method returns all enum values
defined in an enumeration in an `Array`. The `fromOrdinal`
method obtains an enum value from its ordinal (`Int`) value.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >scala&gt; Color.valueOf(&quot;Blue&quot;)
</span><span id="1" class="" >val res0: Color = Blue
</span><span id="2" class="" >scala&gt; Color.values
</span><span id="3" class="" >val res1: Array[Color] = Array(Red, Green, Blue)
</span><span id="4" class="" >scala&gt; Color.fromOrdinal(0)
</span><span id="5" class="" >val res2: Color = Red
</span></code></pre></div>

### User-defined members of enums

It is possible to add your own definitions to an enum. Example:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >enum Planet(mass: Double, radius: Double):
</span><span id="1" class="" >  private final val G = 6.67300E-11
</span><span id="2" class="" >  def surfaceGravity = G * mass / (radius * radius)
</span><span id="3" class="" >  def surfaceWeight(otherMass: Double) = otherMass * surfaceGravity
</span><span id="4" class="" >
</span><span id="5" class="" >  case Mercury extends Planet(3.303e+23, 2.4397e6)
</span><span id="6" class="" >  case Venus   extends Planet(4.869e+24, 6.0518e6)
</span><span id="7" class="" >  case Earth   extends Planet(5.976e+24, 6.37814e6)
</span><span id="8" class="" >  case Mars    extends Planet(6.421e+23, 3.3972e6)
</span><span id="9" class="" >  case Jupiter extends Planet(1.9e+27,   7.1492e7)
</span><span id="10" class="" >  case Saturn  extends Planet(5.688e+26, 6.0268e7)
</span><span id="11" class="" >  case Uranus  extends Planet(8.686e+25, 2.5559e7)
</span><span id="12" class="" >  case Neptune extends Planet(1.024e+26, 2.4746e7)
</span><span id="13" class="" >end Planet
</span></code></pre></div>

It is also possible to define an explicit companion object for an enum:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object Planet:
</span><span id="1" class="" >  def main(args: Array[String]) =
</span><span id="2" class="" >    val earthWeight = args(0).toDouble
</span><span id="3" class="" >    val mass = earthWeight / Earth.surfaceGravity
</span><span id="4" class="" >    for p &lt;- values do
</span><span id="5" class="" >      println(s&quot;Your weight on $p is ${p.surfaceWeight(mass)}&quot;)
</span><span id="6" class="" >end Planet
</span></code></pre></div>

### Deprecation of Enum Cases

As a library author, you may want to signal that an enum case is no longer intended for use. However you could still want to gracefully handle the removal of a case from your public API, such as special casing deprecated cases.

To illustrate, say that the `Planet` enum originally had an additional case:

```diff
 enum Planet(mass: Double, radius: Double):
   ...
   case Neptune extends Planet(1.024e+26, 2.4746e7)
+  case Pluto   extends Planet(1.309e+22, 1.1883e3)
 end Planet
```

We now want to deprecate the `Pluto` case. First we add the `scala.deprecated` annotation to `Pluto`:

```diff
 enum Planet(mass: Double, radius: Double):
   ...
   case Neptune extends Planet(1.024e+26, 2.4746e7)
-  case Pluto   extends Planet(1.309e+22, 1.1883e3)
+
+  @deprecated("refer to IAU definition of planet")
+  case Pluto extends Planet(1.309e+22, 1.1883e3)
 end Planet
```

Outside the lexical scopes of `enum Planet` or `object Planet`, references to `Planet.Pluto` will produce a deprecation warning, but within those scopes we can still reference it to implement introspection over the deprecated cases:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Deprecations[T &lt;: reflect.Enum] {
</span><span id="1" class="" >  extension (t: T) def isDeprecatedCase: Boolean
</span><span id="2" class="" >}
</span><span id="3" class="" >
</span><span id="4" class="" >object Planet {
</span><span id="5" class="" >  given Deprecations[Planet] with {
</span><span id="6" class="" >    extension (p: Planet)
</span><span id="7" class="" >      def isDeprecatedCase = p == Pluto
</span><span id="8" class="" >  }
</span><span id="9" class="" >}
</span></code></pre></div>

We could imagine that a library may use [type class derivation](../contextual/derivation.html) to automatically provide an instance for `Deprecations`.

### Compatibility with Java Enums

If you want to use the Scala-defined enums as [Java enums](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html), you can do so by extending
the class `java.lang.Enum`, which is imported by default, as follows:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >enum Color extends Enum[Color] { case Red, Green, Blue }
</span></code></pre></div>

The type parameter comes from the Java enum [definition](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Enum.html) and should be the same as the type of the enum.
There is no need to provide constructor arguments (as defined in the Java API docs) to `java.lang.Enum` when extending it â€“ the compiler will generate them automatically.

After defining `Color` like that, you can use it like you would a Java enum:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >scala&gt; Color.Red.compareTo(Color.Green)
</span><span id="1" class="" >val res15: Int = -1
</span></code></pre></div>

For a more in-depth example of using Scala 3 enums from Java, see [this test](https://github.com/lampepfl/dotty/tree/master/tests/run/enum-java). In the test, the enums are defined in the `MainScala.scala` file and used from a Java source, `Test.java`.

### Implementation

Enums are represented as `sealed` classes that extend the `scala.reflect.Enum` trait.
This trait defines a single public method, `ordinal`:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >package scala.reflect
</span><span id="1" class="" >
</span><span id="2" class="" >/** A base trait of all Scala enum definitions */
</span><span id="3" class="" >transparent trait Enum extends Any, Product, Serializable:
</span><span id="4" class="" >
</span><span id="5" class="" >  /** A number uniquely identifying a case of an enum */
</span><span id="6" class="" >  def ordinal: Int
</span></code></pre></div>

Enum values with `extends` clauses get expanded to anonymous class instances.
For instance, the `Venus` value above would be defined like this:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val Venus: Planet = new Planet(4.869E24, 6051800.0):
</span><span id="1" class="" >  def ordinal: Int = 1
</span><span id="2" class="" >  override def productPrefix: String = &quot;Venus&quot;
</span><span id="3" class="" >  override def toString: String = &quot;Venus&quot;
</span></code></pre></div>

Enum values without `extends` clauses all share a single implementation
that can be instantiated using a private method that takes a tag and a name as arguments.
For instance, the first
definition of value `Color.Red` above would expand to:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val Red: Color = $new(0, &quot;Red&quot;)
</span></code></pre></div>

### Reference

For more information, see [Issue #1970](https://github.com/lampepfl/dotty/issues/1970) and
[PR #4003](https://github.com/lampepfl/dotty/pull/4003).
