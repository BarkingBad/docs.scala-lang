---
title: "Translation of Enums and ADTs"
next-page: /scala3/reference/contextual
num: 12
type: section
previous-page: /scala3/reference/enums/adts
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/enums/desugarEnums.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

The compiler expands enums and their cases to code that only uses
Scala's other language features. As such, enums in Scala are
convenient _syntactic sugar_, but they are not essential to understand
Scala's core.

We now explain the expansion of enums in detail. First,
some terminology and notational conventions:

- We use `E` as a name of an enum, and `C` as a name of a case that appears in `E`.

- We use `<...>` for syntactic constructs that in some circumstances might be empty. For instance,
  `<value-params>` represents one or more parameter lists `(...)` or nothing at all.

- Enum cases fall into three categories:

  - _Class cases_ are those cases that are parameterized, either with a type parameter section `[...]` or with one or more (possibly empty) parameter sections `(...)`.
  - _Simple cases_ are cases of a non-generic enum that have neither parameters nor an extends clause or body. That is, they consist of a name only.
  - _Value cases_ are all cases that do not have a parameter section but that do have a (possibly generated) `extends` clause and/or a body.

Simple cases and value cases are collectively called _singleton cases_.

The desugaring rules imply that class cases are mapped to case classes, and singleton cases are mapped to `val` definitions.

There are nine desugaring rules. Rule (1) desugars enum definitions. Rules
(2) and (3) desugar simple cases. Rules (4) to (6) define `extends` clauses for cases that
are missing them. Rules (7) to (9) define how such cases with `extends` clauses
map into `case class`es or `val`s.

1. An `enum` definition

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >enum E ... { &lt;defs&gt; &lt;cases&gt; }
   </span></code></pre></div>

   expands to a `sealed abstract` class that extends the `scala.reflect.Enum` trait and
   an associated companion object that contains the defined cases, expanded according
   to rules (2 - 8). The enum class starts with a compiler-generated import that imports
   the names `<caseIds>` of all cases so that they can be used without prefix in the class.

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >sealed abstract class E ... extends &lt;parents&gt; with scala.reflect.Enum {
   </span><span id="1" class="" >  import E.{ &lt;caseIds&gt; }
   </span><span id="2" class="" >  &lt;defs&gt;
   </span><span id="3" class="" >}
   </span><span id="4" class="" >object E { &lt;cases&gt; }
   </span></code></pre></div>2. A simple case consisting of a comma-separated list of enum names

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C_1, ..., C_n
   </span></code></pre></div>

   expands to

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C_1; ...; case C_n
   </span></code></pre></div>

   Any modifiers or annotations on the original case extend to all expanded
   cases.

3. A simple case

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C
   </span></code></pre></div>

   of an enum `E` that does not take type parameters expands to

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val C = $new(n, &quot;C&quot;)
   </span></code></pre></div>

   Here, `$new` is a private method that creates an instance of `E` (see
   below).

4. If `E` is an enum with type parameters

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >V1 T1 &gt;: L1 &lt;: U1 ,   ... ,    Vn Tn &gt;: Ln &lt;: Un      (n &gt; 0)
   </span></code></pre></div>

   where each of the variances `Vi` is either `'+'` or `'-'`, then a simple case

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C
   </span></code></pre></div>

   expands to

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C extends E[B1, ..., Bn]
   </span></code></pre></div>

   where `Bi` is `Li` if `Vi = '+'` and `Ui` if `Vi = '-'`. This result is then further
   rewritten with rule (8). Simple cases of enums with non-variant type
   parameters are not permitted (however value cases with explicit `extends` clause are)

5. A class case without an extends clause

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C &lt;type-params&gt; &lt;value-params&gt;
   </span></code></pre></div>

   of an enum `E` that does not take type parameters expands to

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C &lt;type-params&gt; &lt;value-params&gt; extends E
   </span></code></pre></div>

   This result is then further rewritten with rule (9).

6. If `E` is an enum with type parameters `Ts`, a class case with neither type parameters nor an extends clause

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C &lt;value-params&gt;
   </span></code></pre></div>

   expands to

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C[Ts] &lt;value-params&gt; extends E[Ts]
   </span></code></pre></div>

   This result is then further rewritten with rule (9). For class cases that have type parameters themselves, an extends clause needs to be given explicitly.

7. If `E` is an enum with type parameters `Ts`, a class case without type parameters but with an extends clause

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C &lt;value-params&gt; extends &lt;parents&gt;
   </span></code></pre></div>

   expands to

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C[Ts] &lt;value-params&gt; extends &lt;parents&gt;
   </span></code></pre></div>

   provided at least one of the parameters `Ts` is mentioned in a parameter type in
   `<value-params>` or in a type argument in `<parents>`.

8. A value case

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C extends &lt;parents&gt;
   </span></code></pre></div>

   expands to a value definition in `E`'s companion object:

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val C = new &lt;parents&gt; { &lt;body&gt;; def ordinal = n }
   </span></code></pre></div>

   where `n` is the ordinal number of the case in the companion object,
   starting from 0. The anonymous class also
   implements the abstract `Product` methods that it inherits from `Enum`.

   It is an error if a value case refers to a type parameter of the enclosing `enum`
   in a type argument of `<parents>`.

9. A class case

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C &lt;params&gt; extends &lt;parents&gt;
   </span></code></pre></div>

   expands analogous to a final case class in `E`'s companion object:

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >final case class C &lt;params&gt; extends &lt;parents&gt;
   </span></code></pre></div>

   The enum case defines an `ordinal` method of the form

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def ordinal = n
   </span></code></pre></div>

   where `n` is the ordinal number of the case in the companion object,
   starting from 0.

   It is an error if a value case refers to a type parameter of the enclosing `enum`
   in a parameter type in `<params>` or in a type argument of `<parents>`, unless that parameter is already
   a type parameter of the case, i.e. the parameter name is defined in `<params>`.

   The compiler-generated `apply` and `copy` methods of an enum case

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >case C(ps) extends P1, ..., Pn
   </span></code></pre></div>

   are treated specially. A call `C(ts)` of the apply method is ascribed the underlying type
   `P1 & ... & Pn` (dropping any [transparent traits](../other-new-features/transparent-traits.html))
   as long as that type is still compatible with the expected type at the point of application.
   A call `t.copy(ts)` of `C`'s `copy` method is treated in the same way.

### Translation of Enums with Singleton Cases

An enum `E` (possibly generic) that defines one or more singleton cases
will define the following additional synthetic members in its companion object (where `E'` denotes `E` with
any type parameters replaced by wildcards):

- A method `valueOf(name: String): E'`. It returns the singleton case value whose identifier is `name`.
- A method `values` which returns an `Array[E']` of all singleton case
  values defined by `E`, in the order of their definitions.

If `E` contains at least one simple case, its companion object will define in addition:

- A private method `$new` which defines a new simple case value with given
  ordinal number and name. This method can be thought as being defined as
  follows.

  <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >private def $new(_$ordinal: Int, $name: String) =
  </span><span id="1" class="" >  new E with runtime.EnumValue:
  </span><span id="2" class="" >    def ordinal = _$ordinal
  </span><span id="3" class="" >    override def productPrefix = $name // if not overridden in `E`
  </span><span id="4" class="" >    override def toString = $name      // if not overridden in `E`
  </span></code></pre></div>

The anonymous class also implements the abstract `Product` methods that it inherits from `Enum`.
The `ordinal` method is only generated if the enum does not extend from `java.lang.Enum` (as Scala enums do not extend
`java.lang.Enum`s unless explicitly specified). In case it does, there is no need to generate `ordinal` as
`java.lang.Enum` defines it. Similarly there is no need to override `toString` as that is defined in terms of `name` in
`java.lang.Enum`. Finally, `productPrefix` will call `this.name` when `E` extends `java.lang.Enum`.

### Scopes for Enum Cases

A case in an `enum` is treated similarly to a secondary constructor. It can access neither the enclosing `enum` using `this`, nor its value parameters or instance members using simple
identifiers.

Even though translated enum cases are located in the enum's companion object, referencing
this object or its members via `this` or a simple identifier is also illegal. The compiler typechecks enum cases in the scope of the enclosing companion object but flags any such illegal accesses as errors.

### Translation of Java-compatible enums

A Java-compatible enum is an enum that extends `java.lang.Enum`. The translation rules are the same as above, with the reservations defined in this section.

It is a compile-time error for a Java-compatible enum to have class cases.

Cases such as `case C` expand to a `@static val` as opposed to a `val`. This allows them to be generated as static fields of the enum type, thus ensuring they are represented the same way as Java enums.

### Other Rules

- A normal case class which is not produced from an enum case is not allowed to extend
  `scala.reflect.Enum`. This ensures that the only cases of an enum are the ones that are
  explicitly declared in it.

- If an enum case has an `extends` clause, the enum class must be one of the
  classes that's extended.

