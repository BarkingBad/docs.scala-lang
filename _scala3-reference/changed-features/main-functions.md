---
title: "Main Methods"
next-page: /scala3/reference/dropped-features
num: 70
type: section
previous-page: /scala3/reference/changed-features/lazy-vals-init
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/changed-features/main-functions.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

Scala 3 offers a new way to define programs that can be invoked from the command line:
A `@main` annotation on a method turns this method into an executable program.
Example:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >@main def happyBirthday(age: Int, name: String, others: String*) =
</span><span id="1" class="" >  val suffix =
</span><span id="2" class="" >    age % 100 match
</span><span id="3" class="" >    case 11 | 12 | 13 =&gt; &quot;th&quot;
</span><span id="4" class="" >    case _ =&gt;
</span><span id="5" class="" >      age % 10 match
</span><span id="6" class="" >        case 1 =&gt; &quot;st&quot;
</span><span id="7" class="" >        case 2 =&gt; &quot;nd&quot;
</span><span id="8" class="" >        case 3 =&gt; &quot;rd&quot;
</span><span id="9" class="" >        case _ =&gt; &quot;th&quot;
</span><span id="10" class="" >  val bldr = new StringBuilder(s&quot;Happy $age$suffix birthday, $name&quot;)
</span><span id="11" class="" >  for other &lt;- others do bldr.append(&quot; and &quot;).append(other)
</span><span id="12" class="" >  bldr.toString
</span></code></pre></div>

This would generate a main program `happyBirthday` that could be called like this

```
> scala happyBirthday 23 Lisa Peter
Happy 23rd birthday, Lisa and Peter
```

A `@main` annotated method can be written either at the top-level or in a statically accessible object. The name of the program is in each case the name of the method, without any object prefixes. The `@main` method can have an arbitrary number of parameters.
For each parameter type there must be an instance of the `scala.util.CommandLineParser.FromString` type class
that is used to convert an argument string to the required parameter type.
The parameter list of a main method can end in a repeated parameter that then
takes all remaining arguments given on the command line.

The program implemented from a `@main` method checks that there are enough arguments on
the command line to fill in all parameters, and that argument strings are convertible to
the required types. If a check fails, the program is terminated with an error message.

Examples:

```
> scala happyBirthday 22
Illegal command line after first argument: more arguments expected

> scala happyBirthday sixty Fred
Illegal command line: java.lang.NumberFormatException: For input string: "sixty"
```

The Scala compiler generates a program from a `@main` method `f` as follows:

- It creates a class named `f` in the package where the `@main` method was found
- The class has a static method `main` with the usual signature. It takes an `Array[String]`
  as argument and returns `Unit`.
- The generated `main` method calls method `f` with arguments converted using
  methods in the [`scala.util.CommandLineParser`](https://scala-lang.org/api/3.x/scala/util/CommandLineParser$.html) object.

For instance, the `happyBirthDay` method above would generate additional code equivalent to the following class:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >final class happyBirthday:
</span><span id="1" class="" >  import scala.util.CommandLineParser as CLP
</span><span id="2" class="" >  &lt;static&gt; def main(args: Array[String]): Unit =
</span><span id="3" class="" >    try
</span><span id="4" class="" >      happyBirthday(
</span><span id="5" class="" >        CLP.parseArgument[Int](args, 0),
</span><span id="6" class="" >        CLP.parseArgument[String](args, 1),
</span><span id="7" class="" >        CLP.parseRemainingArguments[String](args, 2))
</span><span id="8" class="" >    catch
</span><span id="9" class="" >      case error: CLP.ParseError =&gt; CLP.showError(error)
</span></code></pre></div>

**Note**: The `<static>` modifier above expresses that the `main` method is generated
as a static method of class `happyBirthDay`. It is not available for user programs in Scala. Regular "static" members are generated in Scala using objects instead.

`@main` methods are the recommended scheme to generate programs that can be invoked from the command line in Scala 3. They replace the previous scheme to write program as objects with a special `App` parent class. In Scala 2, `happyBirthday` could be written also like this:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object happyBirthday extends App:
</span><span id="1" class="" >  // needs by-hand parsing of arguments vector
</span><span id="2" class="" >  ...
</span></code></pre></div>The previous functionality of `App`, which relied on the "magic" [`DelayedInit`]({% link _scala3-reference/dropped-features/delayed-init.md %}) trait, is no longer available. [`App`](https://scala-lang.org/api/3.x/scala/App.html) still exists in limited form for now, but it does not support command line arguments and will be deprecated in the future. If programs need to cross-build
between Scala 2 and Scala 3, it is recommended to use an explicit `main` method with an `Array[String]` argument instead.
