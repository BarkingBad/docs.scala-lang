---
layout: singlepage-overview
title: "Implicit Conversions - More Details"
scala3: true
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/changed-features/implicit-conversions-spec.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

## Implementation

An implicit conversion, or _view_, from type `S` to type `T` is
defined by either:

- An `implicit def` which has type `S => T` or `(=> S) => T`
- An implicit value which has type `Conversion[S, T]`

The standard library defines an abstract class `Conversion`:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >package scala
</span><span id="1" class="" >@java.lang.FunctionalInterface
</span><span id="2" class="" >abstract class Conversion[-T, +U] extends Function1[T, U]:
</span><span id="3" class="" >  def apply(x: T): U
</span></code></pre></div>

Function literals are automatically converted to `Conversion` values.

Views are applied in three situations:

1. If an expression `e` is of type `T`, and `T` does not conform to
   the expression's expected type `pt`. In this case, an implicit `v`
   which is applicable to `e` and whose result type conforms to `pt`
   is searched. The search proceeds as in the case of implicit
   parameters, where the implicit scope is the one of `T => pt`. If
   such a view is found, the expression `e` is converted to `v(e)`.
2. In a selection `e.m` with `e` of type `T`, if the selector `m` does
   not denote an accessible member of `T`. In this case, a view `v`
   which is applicable to `e` and whose result contains an accessible
   member named `m` is searched. The search proceeds as in the case of
   implicit parameters, where the implicit scope is the one of `T`. If
   such a view is found, the selection `e.m` is converted to `v(e).m`.
3. In an application `e.m(args)` with `e` of type `T`, if the selector
   `m` denotes some accessible member(s) of `T`, but none of these
   members is applicable to the arguments `args`. In this case, a view
   `v` which is applicable to `e` and whose result contains a method
   `m` which is applicable to `args` is searched. The search proceeds
   as in the case of implicit parameters, where the implicit scope is
   the one of `T`. If such a view is found, the application
   `e.m(args)` is converted to `v(e).m(args)`.

# Differences with Scala 2 implicit conversions

In Scala 2, views whose parameters are passed by-value take precedence
over views whose parameters are passed by-name. This is no longer the
case in Scala 3. A type error reporting the ambiguous conversions will
be emitted in cases where this rule would be applied in Scala 2:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >implicit def conv1(x: Int): String = x.toString
</span><span id="1" class="" >implicit def conv2(x: =&gt; Int): String = x.toString
</span><span id="2" class="" >
</span><span id="3" class="" >val x: String = 0 // Compiles in Scala2 (uses `conv1`),
</span><span id="4" class="" >                  // type error in Scala 3 because of ambiguity.
</span></code></pre></div>

In Scala 2, implicit values of a function type would be considered as
potential views. In Scala 3, these implicit value need to have type
`Conversion`:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >// Scala 2:
</span><span id="1" class="" >def foo(x: Int)(implicit conv: Int =&gt; String): String = x
</span><span id="2" class="" >
</span><span id="3" class="" >// Becomes with Scala 3:
</span><span id="4" class="" >def foo(x: Int)(implicit conv: Conversion[Int, String]): String = x
</span><span id="5" class="" >
</span><span id="6" class="" >// Call site is unchanged:
</span><span id="7" class="" >foo(4)(_.toString)
</span><span id="8" class="" >
</span><span id="9" class="" >// Scala 2:
</span><span id="10" class="" >implicit val myConverter: Int =&gt; String = _.toString
</span><span id="11" class="" >
</span><span id="12" class="" >// Becomes with Scala 3:
</span><span id="13" class="" >implicit val myConverter: Conversion[Int, String] = _.toString
</span></code></pre></div>

Note that implicit conversions are also affected by the [changes to implicit resolution](implicit-resolution.html) between Scala 2 and Scala 3.

## Motivation for the changes

The introduction of [`scala.Conversion`](https://github.com/lampepfl/dotty/blob/master/library/src/scala/Conversion.scala)
in Scala 3 and the decision to restrict implicit values of this type to be
considered as potential views comes from the desire to remove surprising
behavior from the language:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >implicit val m: Map[Int, String] = Map(1 -&gt; &quot;abc&quot;)
</span><span id="1" class="" >
</span><span id="2" class="" >val x: String = 1  // Scala 2: assigns &quot;abc&quot; to x
</span><span id="3" class="" >                   // Scala 3: type error
</span></code></pre></div>

This snippet contains a type error. The right-hand side of `val x`
does not conform to type `String`. In Scala 2, the compiler will use
`m` as an implicit conversion from `Int` to `String`, whereas Scala 3
will report a type error, because `Map` isn't an instance of
`Conversion`.

## Migration path

Implicit values that are used as views should see their type changed to `Conversion`.

For the migration of implicit conversions that are affected by the
changes to implicit resolution, refer to the [Changes in Implicit Resolution](implicit-resolution.html) for more information.

## Reference

For more information about implicit resolution, see [Changes in Implicit Resolution](implicit-resolution.html).
Other details are available in [PR #2065](https://github.com/lampepfl/dotty/pull/2065).
