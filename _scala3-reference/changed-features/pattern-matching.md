---
title: "Option-less pattern matching"
next-page: /scala3/reference/changed-features/eta-expansion
num: 66
type: section
previous-page: /scala3/reference/changed-features/pattern-bindings
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/changed-features/pattern-matching.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

The implementation of pattern matching in Scala 3 was greatly simplified compared to Scala 2. From a user perspective, this means that Scala 3 generated patterns are a *lot* easier to debug, as variables all show up in debug modes and positions are correctly preserved.

Scala 3 supports a superset of Scala 2 [extractors](https://www.scala-lang.org/files/archive/spec/2.13/08-pattern-matching.html#extractor-patterns).

## Extractors

Extractors are objects that expose a method `unapply` or `unapplySeq`:

```Scala
def unapply[A](x: T)(implicit x: B): U
def unapplySeq[A](x: T)(implicit x: B): U
```

Extractors that expose the method `unapply` are called fixed-arity extractors, which
work with patterns of fixed arity. Extractors that expose the method `unapplySeq` are
called variadic extractors, which enables variadic patterns.

### Fixed-Arity Extractors

Fixed-arity extractors expose the following signature:

```Scala
def unapply[A](x: T)(implicit x: B): U
```

The type `U` conforms to one of the following matches:

- Boolean match
- Product match

Or `U` conforms to the type `R`:

```Scala
type R = {
  def isEmpty: Boolean
  def get: S
}
```

and `S` conforms to one of the following matches:

- single match
- name-based match

The former form of `unapply` has higher precedence, and _single match_ has higher
precedence over _name-based match_.

A usage of a fixed-arity extractor is irrefutable if one of the following condition holds:

- `U = true`
- the extractor is used as a product match
- `U = Some[T]` (for Scala 2 compatibility)
- `U <: R` and `U <: { def isEmpty: false }`

### Variadic Extractors

Variadic extractors expose the following signature:

```Scala
def unapplySeq[A](x: T)(implicit x: B): U
```

The type `U` conforms to one of the following matches:

- sequence match
- product-sequence match

Or `U` conforms to the type `R`:

```Scala
type R = {
  def isEmpty: Boolean
  def get: S
}
```

and `S` conforms to one of the two matches above.

The former form of `unapplySeq` has higher priority, and _sequence match_ has higher
precedence over _product-sequence match_.

A usage of a variadic extractor is irrefutable if one of the following conditions holds:

- the extractor is used directly as a sequence match or product-sequence match
- `U = Some[T]` (for Scala 2 compatibility)
- `U <: R` and `U <: { def isEmpty: false }`

## Boolean Match

- `U =:= Boolean`
- Pattern-matching on exactly `0` pattern

For example:

<!-- To be kept in sync with tests/new/patmat-spec.scala --><div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object Even:
</span><span id="1" class="" >  def unapply(s: String): Boolean = s.size % 2 == 0
</span><span id="2" class="" >
</span><span id="3" class="" >&quot;even&quot; match
</span><span id="4" class="" >  case s @ Even() =&gt; println(s&quot;$s has an even number of characters&quot;)
</span><span id="5" class="" >  case s          =&gt; println(s&quot;$s has an odd number of characters&quot;)
</span><span id="6" class="" >
</span><span id="7" class="" >// even has an even number of characters
</span></code></pre></div>

## Product Match

- `U <: Product`
- `N > 0` is the maximum number of consecutive (parameterless `def` or `val`) `_1: P1` ... `_N: PN` members in `U`
- Pattern-matching on exactly `N` patterns with types `P1, P2, ..., PN`

For example:

<!-- To be kept in sync with tests/new/patmat-spec.scala --><div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class FirstChars(s: String) extends Product:
</span><span id="1" class="" >  def _1 = s.charAt(0)
</span><span id="2" class="" >  def _2 = s.charAt(1)
</span><span id="3" class="" >
</span><span id="4" class="" >   // Not used by pattern matching: Product is only used as a marker trait.
</span><span id="5" class="" >  def canEqual(that: Any): Boolean = ???
</span><span id="6" class="" >  def productArity: Int = ???
</span><span id="7" class="" >  def productElement(n: Int): Any = ???
</span><span id="8" class="" >
</span><span id="9" class="" >object FirstChars:
</span><span id="10" class="" >  def unapply(s: String): FirstChars = new FirstChars(s)
</span><span id="11" class="" >
</span><span id="12" class="" >&quot;Hi!&quot; match
</span><span id="13" class="" >  case FirstChars(char1, char2) =&gt;
</span><span id="14" class="" >    println(s&quot;First: $char1; Second: $char2&quot;)
</span><span id="15" class="" >
</span><span id="16" class="" >// First: H; Second: i
</span></code></pre></div>

## Single Match

- If there is exactly `1` pattern, pattern-matching on `1` pattern with type `U`

<!-- To be kept in sync with tests/new/patmat-spec.scala --><div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class Nat(val x: Int):
</span><span id="1" class="" >  def get: Int = x
</span><span id="2" class="" >  def isEmpty = x &lt; 0
</span><span id="3" class="" >
</span><span id="4" class="" >object Nat:
</span><span id="5" class="" >  def unapply(x: Int): Nat = new Nat(x)
</span><span id="6" class="" >
</span><span id="7" class="" >5 match
</span><span id="8" class="" >  case Nat(n) =&gt; println(s&quot;$n is a natural number&quot;)
</span><span id="9" class="" >  case _      =&gt; ()
</span><span id="10" class="" >
</span><span id="11" class="" >// 5 is a natural number
</span></code></pre></div>

## Name-based Match

- `N > 1` is the maximum number of consecutive (parameterless `def` or `val`) `_1: P1 ... _N: PN` members in `U`
- Pattern-matching on exactly `N` patterns with types `P1, P2, ..., PN`

```Scala
object ProdEmpty:
  def _1: Int = ???
  def _2: String = ???
  def isEmpty = true
  def unapply(s: String): this.type = this
  def get = this

"" match
  case ProdEmpty(_, _) => ???
  case _ => ()
```

## Sequence Match

- `U <: X`, `T2` and `T3` conform to `T1`

```Scala
type X = {
  def lengthCompare(len: Int): Int // or, `def length: Int`
  def apply(i: Int): T1
  def drop(n: Int): scala.Seq[T2]
  def toSeq: scala.Seq[T3]
}
```

- Pattern-matching on _exactly_ `N` simple patterns with types `T1, T1, ..., T1`, where `N` is the runtime size of the sequence, or
- Pattern-matching on `>= N` simple patterns and _a vararg pattern_ (e.g., `xs: _*`) with types `T1, T1, ..., T1, Seq[T1]`, where `N` is the minimum size of the sequence.

<!-- To be kept in sync with tests/new/patmat-spec.scala --><div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object CharList:
</span><span id="1" class="" >  def unapplySeq(s: String): Option[Seq[Char]] = Some(s.toList)
</span><span id="2" class="" >
</span><span id="3" class="" >&quot;example&quot; match
</span><span id="4" class="" >  case CharList(c1, c2, c3, c4, _, _, _) =&gt;
</span><span id="5" class="" >    println(s&quot;$c1,$c2,$c3,$c4&quot;)
</span><span id="6" class="" >  case _ =&gt;
</span><span id="7" class="" >    println(&quot;Expected *exactly* 7 characters!&quot;)
</span><span id="8" class="" >
</span><span id="9" class="" >// e,x,a,m
</span></code></pre></div>

## Product-Sequence Match

- `U <: Product`
- `N > 0` is the maximum number of consecutive (parameterless `def` or `val`) `_1: P1` ... `_N: PN` members in `U`
- `PN` conforms to the signature `X` defined in Seq Pattern
- Pattern-matching on exactly `>= N` patterns, the first `N - 1` patterns have types `P1, P2, ... P(N-1)`,
  the type of the remaining patterns are determined as in Seq Pattern.

```Scala
class Foo(val name: String, val children: Int *)
object Foo:
  def unapplySeq(f: Foo): Option[(String, Seq[Int])] =
    Some((f.name, f.children))

def foo(f: Foo) = f match
  case Foo(name, ns : _*) =>
  case Foo(name, x, y, ns : _*) =>
```

There are plans for further simplification, in particular to factor out *product
match* and *name-based match* into a single type of extractor.

## Type testing

Abstract type testing with `ClassTag` is replaced with `TypeTest` or the alias `Typeable`.

- pattern `_: X` for an abstract type requires a `TypeTest` in scope
- pattern `x @ X()` for an unapply that takes an abstract type requires a `TypeTest` in scope

[More details on `TypeTest`](../other-new-features/type-test.html)
