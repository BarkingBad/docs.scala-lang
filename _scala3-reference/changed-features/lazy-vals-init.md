---
title: Lazy Vals Initialization
next-page: /scala3/reference/changed-features/main-functions
num: 69
type: section
previous-page: /scala3/reference/changed-features/compiler-plugins
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/changed-features/lazy-vals-init.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

Scala 3 implements [Version 6](https://docs.scala-lang.org/sips/improved-lazy-val-initialization.html#version-6---no-synchronization-on-this-and-concurrent-initialization-of-fields)
of the [SIP-20] improved lazy vals initialization proposal.

## Motivation

The newly proposed lazy val initialization mechanism aims to eliminate the acquisition of resources
during the execution of the lazy val initializer block, thus reducing the possibility of a deadlock.
The concrete deadlock scenarios that the new lazy val initialization scheme eliminates are
summarized in the [SIP-20] document.

## Implementation

Given a lazy field of the form:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class Foo {
</span><span id="1" class="" >  lazy val bar = &lt;RHS&gt;
</span><span id="2" class="" >}
</span></code></pre></div>

The Scala 3 compiler will generate code equivalent to:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class Foo {
</span><span id="1" class="" >  import scala.runtime.LazyVals
</span><span id="2" class="" >  var value_0: Int = _
</span><span id="3" class="" >  var bitmap: Long = 0L
</span><span id="4" class="" >  val bitmap_offset: Long = LazyVals.getOffset(classOf[LazyCell], &quot;bitmap&quot;)
</span><span id="5" class="" >
</span><span id="6" class="" >  def bar(): Int = {
</span><span id="7" class="" >    while (true) {
</span><span id="8" class="" >      val flag = LazyVals.get(this, bitmap_offset)
</span><span id="9" class="" >      val state = LazyVals.STATE(flag, &lt;field-id&gt;)
</span><span id="10" class="" >
</span><span id="11" class="" >      if (state == &lt;state-3&gt;) {
</span><span id="12" class="" >        return value_0
</span><span id="13" class="" >      } else if (state == &lt;state-0&gt;) {
</span><span id="14" class="" >        if (LazyVals.CAS(this, bitmap_offset, flag, &lt;state-1&gt;, &lt;field-id&gt;)) {
</span><span id="15" class="" >          try {
</span><span id="16" class="" >            val result = &lt;RHS&gt;
</span><span id="17" class="" >            value_0 = result
</span><span id="18" class="" >            LazyVals.setFlag(this, bitmap_offset, &lt;state-3&gt;, &lt;field-id&gt;)
</span><span id="19" class="" >            return result
</span><span id="20" class="" >          }
</span><span id="21" class="" >          catch {
</span><span id="22" class="" >            case ex =&gt;
</span><span id="23" class="" >              LazyVals.setFlag(this, bitmap_offset, &lt;state-0&gt;, &lt;field-id&gt;)
</span><span id="24" class="" >              throw ex
</span><span id="25" class="" >          }
</span><span id="26" class="" >        }
</span><span id="27" class="" >      } else /* if (state == &lt;state-1&gt; || state == &lt;state-2&gt;) */ {
</span><span id="28" class="" >        LazyVals.wait4Notification(this, bitmap_offset, flag, &lt;field-id&gt;)
</span><span id="29" class="" >      }
</span><span id="30" class="" >    }
</span><span id="31" class="" >  }
</span><span id="32" class="" >}
</span></code></pre></div>

The state of the lazy val `<state-i>` is represented with 4 values: 0, 1, 2 and 3. The state 0
represents a non-initialized lazy val. The state 1 represents a lazy val that is currently being
initialized by some thread. The state 2 denotes that there are concurrent readers of the lazy val.
The state 3 represents a lazy val that has been initialized. `<field-id>` is the id of the lazy
val. This id grows with the number of volatile lazy vals defined in the class.

## Note on recursive lazy vals

Ideally recursive lazy vals should be flagged as an error. The current behavior for
recursive lazy vals is undefined (initialization may result in a deadlock).

## Reference

* [SIP-20]

[SIP-20]: https://docs.scala-lang.org/sips/improved-lazy-val-initialization.html

