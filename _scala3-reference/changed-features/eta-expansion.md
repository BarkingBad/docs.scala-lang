---
title: "Automatic Eta Expansion"
next-page: /scala3/reference/changed-features/compiler-plugins
num: 66
type: section
previous-page: /scala3/reference/changed-features/pattern-matching
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

The conversion of _methods_ into _functions_ has been improved and happens automatically for methods with one or more parameters.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def m(x: Boolean, y: String)(z: Int): List[Int]
</span><span id="1" class="" >val f1 = m
</span><span id="2" class="" >val f2 = m(true, &quot;abc&quot;)
</span></code></pre></div>

This creates two function values:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >f1: (Boolean, String) =&gt; Int =&gt; List[Int]
</span><span id="1" class="" >f2: Int =&gt; List[Int]
</span></code></pre></div>

The syntax `m _` is no longer needed and will be deprecated in the future.

## Automatic eta-expansion and nullary methods

Automatic eta expansion does not apply to "nullary" methods that take an empty parameter list.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def next(): T
</span></code></pre></div>

Given a simple reference to `next` does not auto-convert to a function.
One has to write explicitly `() => next()` to achieve that.
Once again since the `_` is going to be deprecated it's better to write it this way
rather than `next _`.

The reason for excluding nullary methods from automatic eta expansion
is that Scala implicitly inserts the `()` argument, which would
conflict with eta expansion. Automatic `()` insertion is
[limited](../dropped-features/auto-apply.html) in Scala 3, but the fundamental ambiguity
remains.

[More details](eta-expansion-spec.html)
