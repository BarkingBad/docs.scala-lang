---
title: "Changes in Overload Resolution"
next-page: /scala3/reference/changed-features/match-syntax
num: 61
type: section
previous-page: /scala3/reference/changed-features/implicit-conversions
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

Overload resolution in Scala 3 improves on Scala 2 in two ways.
First, it takes all argument lists into account instead of
just the first argument list.
Second, it can infer parameter types of function values even if they
are in the first argument list.

## Looking Beyond the First Argument List

Overloading resolution now can take argument lists into account when
choosing among a set of overloaded alternatives.
For example, the following code compiles in Scala 3, while it results in an
ambiguous overload error in Scala 2:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def f(x: Int)(y: String): Int = 0
</span><span id="1" class="" >def f(x: Int)(y: Int): Int = 0
</span><span id="2" class="" >
</span><span id="3" class="" >f(3)(&quot;&quot;)     // ok
</span></code></pre></div>

The following code compiles as well:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def g(x: Int)(y: Int)(z: Int): Int = 0
</span><span id="1" class="" >def g(x: Int)(y: Int)(z: String): Int = 0
</span><span id="2" class="" >
</span><span id="3" class="" >g(2)(3)(4)     // ok
</span><span id="4" class="" >g(2)(3)(&quot;&quot;)    // ok
</span></code></pre></div>

To make this work, the rules for overloading resolution in [SLS §6.26.3](https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#overloading-resolution) are augmented
as follows:

> In a situation where a function is applied to more than one argument list, if overloading
> resolution yields several competing alternatives when `n >= 1` parameter lists are taken
> into account, then resolution re-tried using `n + 1` argument lists.

This change is motivated by the new language feature
[extension methods](../contextual/extension-methods.html), where emerges the need to do
overload resolution based on additional argument blocks.

## Parameter Types of Function Values

The handling of function values with missing parameter types has been improved. We can now
pass such values in the first argument list of an overloaded application, provided
that the remaining parameters suffice for picking a variant of the overloaded function.
For example, the following code compiles in Scala 3, while it results in a
missing parameter type error in Scala2:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def f(x: Int, f2: Int =&gt; Int) = f2(x)
</span><span id="1" class="" >def f(x: String, f2: String =&gt; String) = f2(x)
</span><span id="2" class="" >f(&quot;a&quot;, _.toUpperCase)
</span><span id="3" class="" >f(2, _ * 2)
</span></code></pre></div>

To make this work, the rules for overloading resolution in [SLS §6.26.3](https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#overloading-resolution) are modified
as follows:

Replace the sentence

> Otherwise, let `S1,…,Sm` be the vector of types obtained by typing each argument with an undefined expected type.

with the following paragraph:

> Otherwise, let `S1,…,Sm` be the vector of known types of all argument types, where the _known type_ of an argument `E`
> is determined as followed:

- If `E` is a function value `(p_1, ..., p_n) => B` that misses some parameter types, the known type
  of `E` is `(S_1, ..., S_n) => ?`, where each `S_i` is the type of parameter `p_i` if it is given, or `?`
  otherwise. Here `?` stands for a _wildcard type_ that is compatible with every other type.
- Otherwise the known type of `E` is the result of typing `E` with an undefined expected type.

A pattern matching closure

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >{ case P1 =&gt; B1 ... case P_n =&gt; B_n }
</span></code></pre></div>

is treated as if it was expanded to the function value

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >x =&gt; x match { case P1 =&gt; B1 ... case P_n =&gt; B_n }
</span></code></pre></div>and is therefore also approximated with a `? => ?` type.
