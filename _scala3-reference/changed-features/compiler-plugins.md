---
title: "Changes in Compiler Plugins"
next-page: /scala3/reference/changed-features/lazy-vals-init
num: 67
type: section
previous-page: /scala3/reference/changed-features/eta-expansion
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

Compiler plugins are supported by Dotty (and Scala 3) since 0.9. There are two notable changes
compared to `scalac`:

- No support for analyzer plugins
- Added support for research plugins

[Analyzer plugins][1] in `scalac` run during type checking and may influence
normal type checking. This is a very powerful feature but for production usages,
a predictable and consistent type checker is more important.

For experimentation and research, Scala 3 introduces _research plugin_. Research plugins
are more powerful than `scalac` analyzer plugins as they let plugin authors customize
the whole compiler pipeline. One can easily replace the standard typer by a custom one or
create a parser for a domain-specific language. However, research plugins are only
enabled for nightly or snaphot releases of Scala 3.

Common plugins that add new phases to the compiler pipeline are called
_standard plugins_ in Scala 3. In terms of features, they are similar to
`scalac` plugins, despite minor changes in the API.

## Using Compiler Plugins

Both standard and research plugins can be used with `scalac` by adding the `-Xplugin:` option:

```shell
scalac -Xplugin:pluginA.jar -Xplugin:pluginB.jar Test.scala
```

The compiler will examine the jar provided, and look for a property file named
`plugin.properties` in the root directory of the jar. The property file specifies
the fully qualified plugin class name. The format of a property file is as follows:

```properties
pluginClass=dividezero.DivideZero
```

This is different from `scalac` plugins that required a `scalac-plugin.xml` file.

Starting from 1.1.5, `sbt` also supports Scala 3 compiler plugins. Please refer to the
[`sbt` documentation][2] for more information.

## Writing a Standard Compiler Plugin

Here is the source code for a simple compiler plugin that reports integer divisions by
zero as errors.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >package dividezero
</span><span id="1" class="" >
</span><span id="2" class="" >import dotty.tools.dotc.ast.Trees.*
</span><span id="3" class="" >import dotty.tools.dotc.ast.tpd
</span><span id="4" class="" >import dotty.tools.dotc.core.Constants.Constant
</span><span id="5" class="" >import dotty.tools.dotc.core.Contexts.Context
</span><span id="6" class="" >import dotty.tools.dotc.core.Decorators.*
</span><span id="7" class="" >import dotty.tools.dotc.core.StdNames.*
</span><span id="8" class="" >import dotty.tools.dotc.core.Symbols.*
</span><span id="9" class="" >import dotty.tools.dotc.plugins.{PluginPhase, StandardPlugin}
</span><span id="10" class="" >import dotty.tools.dotc.transform.{Pickler, Staging}
</span><span id="11" class="" >
</span><span id="12" class="" >class DivideZero extends StandardPlugin:
</span><span id="13" class="" >  val name: String = &quot;divideZero&quot;
</span><span id="14" class="" >  override val description: String = &quot;divide zero check&quot;
</span><span id="15" class="" >
</span><span id="16" class="" >  def init(options: List[String]): List[PluginPhase] =
</span><span id="17" class="" >    (new DivideZeroPhase) :: Nil
</span><span id="18" class="" >
</span><span id="19" class="" >class DivideZeroPhase extends PluginPhase:
</span><span id="20" class="" >  import tpd.*
</span><span id="21" class="" >
</span><span id="22" class="" >  val phaseName = &quot;divideZero&quot;
</span><span id="23" class="" >
</span><span id="24" class="" >  override val runsAfter = Set(Pickler.name)
</span><span id="25" class="" >  override val runsBefore = Set(Staging.name)
</span><span id="26" class="" >
</span><span id="27" class="" >  override def transformApply(tree: Apply)(implicit ctx: Context): Tree =
</span><span id="28" class="" >    tree match
</span><span id="29" class="" >      case Apply(Select(rcvr, nme.DIV), List(Literal(Constant(0))))
</span><span id="30" class="" >      if rcvr.tpe &lt;:&lt; defn.IntType =&gt;
</span><span id="31" class="" >        report.error(&quot;dividing by zero&quot;, tree.pos)
</span><span id="32" class="" >      case _ =&gt;
</span><span id="33" class="" >        ()
</span><span id="34" class="" >    tree
</span><span id="35" class="" >end DivideZeroPhase
</span></code></pre></div>

The plugin main class (`DivideZero`) must extend the trait `StandardPlugin`
and implement the method `init` that takes the plugin's options as argument
and returns a list of `PluginPhase`s to be inserted into the compilation pipeline.

Our plugin adds one compiler phase to the pipeline. A compiler phase must extend
the `PluginPhase` trait. In order to specify when the phase is executed, we also
need to specify a `runsBefore` and `runsAfter` constraints that are list of phase
names.

We can now transform trees by overriding methods like `transformXXX`.

## Writing a Research Compiler Plugin

Here is a template for research plugins.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import dotty.tools.dotc.core.Contexts.Context
</span><span id="1" class="" >import dotty.tools.dotc.core.Phases.Phase
</span><span id="2" class="" >import dotty.tools.dotc.plugins.ResearchPlugin
</span><span id="3" class="" >
</span><span id="4" class="" >class DummyResearchPlugin extends ResearchPlugin:
</span><span id="5" class="" >  val name: String = &quot;dummy&quot;
</span><span id="6" class="" >  override val description: String = &quot;dummy research plugin&quot;
</span><span id="7" class="" >
</span><span id="8" class="" >  def init(options: List[String], phases: List[List[Phase]])(implicit ctx: Context): List[List[Phase]] =
</span><span id="9" class="" >    phases
</span><span id="10" class="" >end DummyResearchPlugin
</span></code></pre></div>

A research plugin must extend the trait `ResearchPlugin`  and implement the
method `init` that takes the plugin's options as argument as well as the compiler
pipeline in the form of a list of compiler phases. The method can replace, remove
or add any phases to the pipeline and return the updated pipeline.

[1]: https://github.com/scala/scala/blob/2.13.x/src/compiler/scala/tools/nsc/typechecker/AnalyzerPlugins.scala
[2]: https://www.scala-sbt.org/1.x/docs/Compiler-Plugins.html

