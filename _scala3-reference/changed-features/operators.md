---
title: "Rules for Operators"
next-page: /scala3/reference/changed-features/wildcards
num: 55
type: section
previous-page: /scala3/reference/changed-features/structural-types
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/changed-features/operators.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

The rules for infix operators have changed in some parts:

First, an alphanumeric method can be used as an infix operator only if its definition carries an `infix` modifier. Second, it is recommended (but not enforced) to
augment definitions of symbolic operators with [`@targetName` annotations](../other-new-features/targetName.html). Finally,
a syntax change allows infix operators to be written on the left in a multi-line expression.

## The `infix` Modifier

An `infix` modifier on a method definition allows using the method as an infix operation. Example:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.annotation.targetName
</span><span id="1" class="" >
</span><span id="2" class="" >trait MultiSet[T]:
</span><span id="3" class="" >
</span><span id="4" class="" >  infix def union(other: MultiSet[T]): MultiSet[T]
</span><span id="5" class="" >
</span><span id="6" class="" >  def difference(other: MultiSet[T]): MultiSet[T]
</span><span id="7" class="" >
</span><span id="8" class="" >  @targetName(&quot;intersection&quot;)
</span><span id="9" class="" >  def *(other: MultiSet[T]): MultiSet[T]
</span><span id="10" class="" >
</span><span id="11" class="" >end MultiSet
</span><span id="12" class="" >
</span><span id="13" class="" >val s1, s2: MultiSet[Int]
</span><span id="14" class="" >
</span><span id="15" class="" >s1 union s2         // OK
</span><span id="16" class="" >s1 `union` s2       // also OK but unusual
</span><span id="17" class="" >s1.union(s2)        // also OK
</span><span id="18" class="" >
</span><span id="19" class="" >s1.difference(s2)   // OK
</span><span id="20" class="" >s1 `difference` s2  // OK
</span><span id="21" class="" >s1 difference s2    // gives a deprecation warning
</span><span id="22" class="" >
</span><span id="23" class="" >s1 * s2             // OK
</span><span id="24" class="" >s1 `*` s2           // also OK, but unusual
</span><span id="25" class="" >s1.*(s2)            // also OK, but unusual
</span></code></pre></div>

Infix operations involving alphanumeric operators are deprecated, unless
one of the following conditions holds:

- the operator definition carries an `infix` modifier, or
- the operator was compiled with Scala 2, or
- the operator is followed by an opening brace.

An alphanumeric operator is an operator consisting entirely of letters, digits, the `$` and `_` characters, or
any Unicode character `c` for which `java.lang.Character.isIdentifierPart(c)` returns `true`.

Infix operations involving symbolic operators are always allowed, so `infix` is redundant for methods with symbolic names.

The `infix` modifier can also be given to a type:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >infix type or[X, Y]
</span><span id="1" class="" >val x: String or Int = ...
</span></code></pre></div>

### Motivation

The purpose of the `infix` modifier is to achieve consistency across a code base in how a method or type is applied. The idea is that the author of a method decides whether that method should be applied as an infix operator or in a regular application. Use sites then implement that decision consistently.

### Details

1. `infix` is a soft modifier. It is treated as a normal identifier except when in modifier position.

2. If a method overrides another, their infix annotations must agree. Either both are annotated with `infix`, or none of them are.

3. `infix` modifiers can be given to method definitions. The first non-receiver parameter list of an `infix` method must define exactly one parameter. Examples:

   <div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >infix def op1(x: S): R             // ok
   </span><span id="1" class="" >infix def op2[T](x: T)(y: S): R    // ok
   </span><span id="2" class="" >infix def op3[T](x: T, y: S): R    // error: two parameters
   </span><span id="3" class="" >
   </span><span id="4" class="" >extension (x: A)
   </span><span id="5" class="" >  infix def op4(y: B): R          // ok
   </span><span id="6" class="" >  infix def op5(y1: B, y2: B): R  // error: two parameters
   </span></code></pre></div>4. `infix` modifiers can also be given to type, trait or class definitions that have exactly two type parameters. An infix type like

   <div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >infix type op[X, Y]
   </span></code></pre></div>

   can be applied using infix syntax, i.e. `A op B`.

5. To smooth migration to Scala 3.0, alphanumeric operators will only be deprecated from Scala 3.1 onwards,
   or if the `-source future` option is given in Dotty/Scala 3.

## The `@targetName` Annotation

It is recommended that definitions of symbolic operators carry a [`@targetName` annotation](../other-new-features/targetName.html) that provides an encoding of the operator with an alphanumeric name. This has several benefits:

- It helps interoperability between Scala and other languages. One can call
  a Scala-defined symbolic operator from another language using its target name,
  which avoids having to remember the low-level encoding of the symbolic name.
- It helps legibility of stacktraces and other runtime diagnostics, where the
  user-defined alphanumeric name will be shown instead of the low-level encoding.
- It serves as a documentation tool by providing an alternative regular name
  as an alias of a symbolic operator. This makes the definition also easier
  to find in a search.

## Syntax Change

Infix operators can now appear at the start of lines in a multi-line expression. Examples:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val str = &quot;hello&quot;
</span><span id="1" class="" >  ++ &quot; world&quot;
</span><span id="2" class="" >  ++ &quot;!&quot;
</span><span id="3" class="" >
</span><span id="4" class="" >def condition =
</span><span id="5" class="" >  x &gt; 0
</span><span id="6" class="" >  ||
</span><span id="7" class="" >  xs.exists(_ &gt; 0)
</span><span id="8" class="" >  || xs.isEmpty
</span></code></pre></div>

Previously, those expressions would have been rejected, since the compiler's semicolon inference
would have treated the continuations `++ " world"` or `|| xs.isEmpty` as separate statements.

To make this syntax work, the rules are modified to not infer semicolons in front of leading infix operators.
A _leading infix operator_ is
- a symbolic identifier such as `+`, or `approx_==`, or an identifier in backticks that
- starts a new line, and
- is not following a blank line, and
- is followed by at least one whitespace character and a token that can start an expression.
- Furthermore, if the operator appears on its own line, the next line must have at least
  the same indentation width as the operator.

Example:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >freezing
</span><span id="1" class="" >  | boiling
</span></code></pre></div>

This is recognized as a single infix operation. Compare with:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >freezing
</span><span id="1" class="" >  !boiling
</span></code></pre></div>

This is seen as two statements, `freezing` and `!boiling`. The difference is that only the operator in the first example
is followed by a space.

Another example:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >println(&quot;hello&quot;)
</span><span id="1" class="" >  ???
</span><span id="2" class="" >  ??? match { case 0 =&gt; 1 }
</span></code></pre></div>This code is recognized as three different statements. `???` is syntactically a symbolic identifier, but
neither of its occurrences is followed by a space and a token that can start an expression.
