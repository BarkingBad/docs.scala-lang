---
title: "Implicit Conversions"
next-page: /scala3/reference/changed-features/overload-resolution
num: 60
type: section
previous-page: /scala3/reference/changed-features/implicit-resolution
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

An _implicit conversion_, also called _view_, is a conversion that
is applied by the compiler in several situations:

1. When an expression `e` of type `T` is encountered, but the compiler
   needs an expression of type `S`.
2. When an expression `e.m` where `e` has type `T` but `T` defines no
   member `m` is encountered.

In those cases, the compiler looks in the implicit scope for a
conversion that can convert an expression of type `T` to an expression
of type `S` (or to a type that defines a member `m` in the second
case).

This conversion can be either:

1. An `implicit def` of type `T => S` or `(=> T) => S`
2. An implicit value of type `scala.Conversion[T, S]`

Defining an implicit conversion will emit a warning unless the import
`scala.language.implicitConversions` is in scope, or the flag
`-language:implicitConversions` is given to the compiler.

## Examples

The first example is taken from `scala.Predef`. Thanks to this
implicit conversion, it is possible to pass a `scala.Int` to a Java
method that expects a `java.lang.Integer`

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.language.implicitConversions
</span><span id="1" class="" >implicit def int2Integer(x: Int): java.lang.Integer =
</span><span id="2" class="" >  x.asInstanceOf[java.lang.Integer]
</span></code></pre></div>

The second example shows how to use `Conversion` to define an
`Ordering` for an arbitrary type, given existing `Ordering`s for other
types:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.language.implicitConversions
</span><span id="1" class="" >implicit def ordT[T, S](
</span><span id="2" class="" >    implicit conv: Conversion[T, S],
</span><span id="3" class="" >             ordS: Ordering[S]
</span><span id="4" class="" >   ): Ordering[T] =
</span><span id="5" class="" >   // `ordS` compares values of type `S`, but we can convert from `T` to `S`
</span><span id="6" class="" >  (x: T, y: T) =&gt; ordS.compare(x, y)
</span><span id="7" class="" >
</span><span id="8" class="" >class A(val x: Int) // The type for which we want an `Ordering`
</span><span id="9" class="" >
</span><span id="10" class="" >// Convert `A` to a type for which an `Ordering` is available:
</span><span id="11" class="" >implicit val AToInt: Conversion[A, Int] = _.x
</span><span id="12" class="" >
</span><span id="13" class="" >implicitly[Ordering[Int]] // Ok, exists in the standard library
</span><span id="14" class="" >implicitly[Ordering[A]] // Ok, will use the implicit conversion from
</span><span id="15" class="" >                        // `A` to `Int` and the `Ordering` for `Int`.
</span></code></pre></div>[More details](implicit-conversions-spec.html)
