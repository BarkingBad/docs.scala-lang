---
title: "Compile-time operations"
next-page: /scala3/reference/metaprogramming/macros
num: 29
type: section
previous-page: /scala3/reference/metaprogramming/inline
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR.
    The whole process of generation the docs can be found under this README: https://github.com/lampepfl/dotty/blob/master/docs/README.md
    The source file can be found here https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/metaprogramming/compiletime-ops.md
    NOTE THAT ANY CHANGES TO THIS FILE WILL BE OVERRIDEN BY PREPROCESSOR.
-->

## The `scala.compiletime` Package

The [`scala.compiletime`](https://scala-lang.org/api/3.x/scala/compiletime.html) package contains helper definitions that provide support for compile-time operations over values. They are described in the following.

### `constValue` and `constValueOpt`

`constValue` is a function that produces the constant value represented by a
type.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.compiletime.constValue
</span><span id="1" class="" >import scala.compiletime.ops.int.S
</span><span id="2" class="" >
</span><span id="3" class="" >transparent inline def toIntC[N]: Int =
</span><span id="4" class="" >  inline constValue[N] match
</span><span id="5" class="" >    case 0        =&gt; 0
</span><span id="6" class="" >    case _: S[n1] =&gt; 1 + toIntC[n1]
</span><span id="7" class="" >
</span><span id="8" class="" >inline val ctwo = toIntC[2]
</span></code></pre></div>

`constValueOpt` is the same as `constValue`, however returning an `Option[T]`
enabling us to handle situations where a value is not present. Note that `S` is
the type of the successor of some singleton type. For example the type `S[1]` is
the singleton type `2`.

### `erasedValue`

So far we have seen inline methods that take terms (tuples and integers) as
parameters. What if we want to base case distinctions on types instead? For
instance, one would like to be able to write a function `defaultValue`, that,
given a type `T`, returns optionally the default value of `T`, if it exists.
We can already express this using rewrite match expressions and a simple
helper function, `scala.compiletime.erasedValue`, which is defined as follows:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def erasedValue[T]: T
</span></code></pre></div>

The `erasedValue` function _pretends_ to return a value of its type argument `T`.
Calling this function will always result in a compile-time error unless the call
is removed from the code while inlining.

Using `erasedValue`, we can then define `defaultValue` as follows:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.compiletime.erasedValue
</span><span id="1" class="" >
</span><span id="2" class="" >transparent inline def defaultValue[T] =
</span><span id="3" class="" >  inline erasedValue[T] match
</span><span id="4" class="" >    case _: Byte    =&gt; Some(0: Byte)
</span><span id="5" class="" >    case _: Char    =&gt; Some(0: Char)
</span><span id="6" class="" >    case _: Short   =&gt; Some(0: Short)
</span><span id="7" class="" >    case _: Int     =&gt; Some(0)
</span><span id="8" class="" >    case _: Long    =&gt; Some(0L)
</span><span id="9" class="" >    case _: Float   =&gt; Some(0.0f)
</span><span id="10" class="" >    case _: Double  =&gt; Some(0.0d)
</span><span id="11" class="" >    case _: Boolean =&gt; Some(false)
</span><span id="12" class="" >    case _: Unit    =&gt; Some(())
</span><span id="13" class="" >    case _          =&gt; None
</span></code></pre></div>

Then:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >val dInt: Some[Int] = defaultValue[Int]
</span><span id="1" class="" >val dDouble: Some[Double] = defaultValue[Double]
</span><span id="2" class="" >val dBoolean: Some[Boolean] = defaultValue[Boolean]
</span><span id="3" class="" >val dAny: None.type = defaultValue[Any]
</span></code></pre></div>

As another example, consider the type-level version of `toInt` below:
given a _type_ representing a Peano number,
return the integer _value_ corresponding to it.
Consider the definitions of numbers as in the _Inline
Match_ section above. Here is how `toIntT` can be defined:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >transparent inline def toIntT[N &lt;: Nat]: Int =
</span><span id="1" class="" >  inline scala.compiletime.erasedValue[N] match
</span><span id="2" class="" >    case _: Zero.type =&gt; 0
</span><span id="3" class="" >    case _: Succ[n] =&gt; toIntT[n] + 1
</span><span id="4" class="" >
</span><span id="5" class="" >inline val two = toIntT[Succ[Succ[Zero.type]]]
</span></code></pre></div>

`erasedValue` is an `erased` method so it cannot be used and has no runtime
behavior. Since `toIntT` performs static checks over the static type of `N` we
can safely use it to scrutinize its return type (`S[S[Z]]` in this case).

### `error`

The `error` method is used to produce user-defined compile errors during inline expansion.
It has the following signature:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >inline def error(inline msg: String): Nothing
</span></code></pre></div>

If an inline expansion results in a call `error(msgStr)` the compiler
produces an error message containing the given `msgStr`.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.compiletime.{error, code}
</span><span id="1" class="" >
</span><span id="2" class="" >inline def fail() =
</span><span id="3" class="" >  error(&quot;failed for a reason&quot;)
</span><span id="4" class="" >
</span><span id="5" class="" >fail() // error: failed for a reason
</span></code></pre></div>

or

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >inline def fail(p1: =&gt; Any) =
</span><span id="1" class="" >  error(code&quot;failed on: $p1&quot;)
</span><span id="2" class="" >
</span><span id="3" class="" >fail(identity(&quot;foo&quot;)) // error: failed on: identity(&quot;foo&quot;)
</span></code></pre></div>

### The `scala.compiletime.ops` package

The [`scala.compiletime.ops`](https://scala-lang.org/api/3.x/scala/compiletime/ops.html) package contains types that provide support for
primitive operations on singleton types. For example,
`scala.compiletime.ops.int.*` provides support for multiplying two singleton
`Int` types, and `scala.compiletime.ops.boolean.&&` for the conjunction of two
`Boolean` types. When all arguments to a type in `scala.compiletime.ops` are
singleton types, the compiler can evaluate the result of the operation.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.compiletime.ops.int.*
</span><span id="1" class="" >import scala.compiletime.ops.boolean.*
</span><span id="2" class="" >
</span><span id="3" class="" >val conjunction: true &amp;&amp; true = true
</span><span id="4" class="" >val multiplication: 3 * 5 = 15
</span></code></pre></div>

Many of these singleton operation types are meant to be used infix (as in [SLS ยง3.2.10](https://www.scala-lang.org/files/archive/spec/2.13/03-types.html#infix-types)).

Since type aliases have the same precedence rules as their term-level
equivalents, the operations compose with the expected precedence rules:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.compiletime.ops.int.*
</span><span id="1" class="" >val x: 1 + 2 * 3 = 7
</span></code></pre></div>

The operation types are located in packages named after the type of the
left-hand side parameter: for instance, `scala.compiletime.ops.int.+` represents
addition of two numbers, while `scala.compiletime.ops.string.+` represents string
concatenation. To use both and distinguish the two types from each other, a
match type can dispatch to the correct implementation:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.compiletime.ops.*
</span><span id="1" class="" >
</span><span id="2" class="" >import scala.annotation.infix
</span><span id="3" class="" >
</span><span id="4" class="" >type +[X &lt;: Int | String, Y &lt;: Int | String] = (X, Y) match
</span><span id="5" class="" >  case (Int, Int) =&gt; int.+[X, Y]
</span><span id="6" class="" >  case (String, String) =&gt; string.+[X, Y]
</span><span id="7" class="" >
</span><span id="8" class="" >val concat: &quot;a&quot; + &quot;b&quot; = &quot;ab&quot;
</span><span id="9" class="" >val addition: 1 + 1 = 2
</span></code></pre></div>

## Summoning Implicits Selectively

It is foreseen that many areas of typelevel programming can be done with rewrite
methods instead of implicits. But sometimes implicits are unavoidable. The
problem so far was that the Prolog-like programming style of implicit search
becomes viral: Once some construct depends on implicit search it has to be
written as a logic program itself. Consider for instance the problem of creating
a `TreeSet[T]` or a `HashSet[T]` depending on whether `T` has an `Ordering` or
not. We can create a set of implicit definitions like this:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait SetFor[T, S &lt;: Set[T]]
</span><span id="1" class="" >
</span><span id="2" class="" >class LowPriority:
</span><span id="3" class="" >  implicit def hashSetFor[T]: SetFor[T, HashSet[T]] = ...
</span><span id="4" class="" >
</span><span id="5" class="" >object SetsFor extends LowPriority:
</span><span id="6" class="" >  implicit def treeSetFor[T: Ordering]: SetFor[T, TreeSet[T]] = ...
</span></code></pre></div>

Clearly, this is not pretty. Besides all the usual indirection of implicit
search, we face the problem of rule prioritization where we have to ensure that
`treeSetFor` takes priority over `hashSetFor` if the element type has an
ordering. This is solved (clumsily) by putting `hashSetFor` in a superclass
`LowPriority` of the object `SetsFor` where `treeSetFor` is defined. Maybe the
boilerplate would still be acceptable if the crufty code could be contained.
However, this is not the case. Every user of the abstraction has to be
parameterized itself with a `SetFor` implicit. Considering the simple task _"I
want a `TreeSet[T]` if `T` has an ordering and a `HashSet[T]` otherwise"_, this
seems like a lot of ceremony.

There are some proposals to improve the situation in specific areas, for
instance by allowing more elaborate schemes to specify priorities. But they all
keep the viral nature of implicit search programs based on logic programming.

By contrast, the new `summonFrom` construct makes implicit search available
in a functional context. To solve the problem of creating the right set, one
would use it as follows:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.compiletime.summonFrom
</span><span id="1" class="" >
</span><span id="2" class="" >inline def setFor[T]: Set[T] = summonFrom {
</span><span id="3" class="" >  case ord: Ordering[T] =&gt; new TreeSet[T]()(using ord)
</span><span id="4" class="" >  case _                =&gt; new HashSet[T]
</span><span id="5" class="" >}
</span></code></pre></div>

A `summonFrom` call takes a pattern matching closure as argument. All patterns
in the closure are type ascriptions of the form `identifier : Type`.

Patterns are tried in sequence. The first case with a pattern `x: T` such that an implicit value of type `T` can be summoned is chosen.

Alternatively, one can also use a pattern-bound given instance, which avoids the explicit using clause. For instance, `setFor` could also be formulated as follows:

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.compiletime.summonFrom
</span><span id="1" class="" >
</span><span id="2" class="" >inline def setFor[T]: Set[T] = summonFrom {
</span><span id="3" class="" >  case given Ordering[T] =&gt; new TreeSet[T]
</span><span id="4" class="" >  case _                 =&gt; new HashSet[T]
</span><span id="5" class="" >}
</span></code></pre></div>

`summonFrom` applications must be reduced at compile time.

Consequently, if we summon an `Ordering[String]` the code above will return a
new instance of `TreeSet[String]`.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >summon[Ordering[String]]
</span><span id="1" class="" >
</span><span id="2" class="" >println(setFor[String].getClass) // prints class scala.collection.immutable.TreeSet
</span></code></pre></div>

**Note** `summonFrom` applications can raise ambiguity errors. Consider the following
code with two givens in scope of type `A`. The pattern match in `f` will raise
an ambiguity error of `f` is applied.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class A
</span><span id="1" class="" >given a1: A = new A
</span><span id="2" class="" >given a2: A = new A
</span><span id="3" class="" >
</span><span id="4" class="" >inline def f: Any = summonFrom {
</span><span id="5" class="" >  case given _: A =&gt; ???  // error: ambiguous givens
</span><span id="6" class="" >}
</span></code></pre></div>

## `summonInline`

The shorthand `summonInline` provides a simple way to write a `summon` that is delayed until the call is inlined.
Unlike `summonFrom`, `summonInline` also yields the implicit-not-found error, if a given instance of the summoned
type is not found.

<div class="snippet" scala-snippet ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.compiletime.summonInline
</span><span id="1" class="" >import scala.annotation.implicitNotFound
</span><span id="2" class="" >
</span><span id="3" class="" >@implicitNotFound(&quot;Missing One&quot;)
</span><span id="4" class="" >trait Missing1
</span><span id="5" class="" >
</span><span id="6" class="" >@implicitNotFound(&quot;Missing Two&quot;)
</span><span id="7" class="" >trait Missing2
</span><span id="8" class="" >
</span><span id="9" class="" >trait NotMissing
</span><span id="10" class="" >given NotMissing = ???
</span><span id="11" class="" >
</span><span id="12" class="" >transparent inline def summonInlineCheck[T &lt;: Int](inline t : T) : Any =
</span><span id="13" class="" >  inline t match
</span><span id="14" class="" >    case 1 =&gt; summonInline[Missing1]
</span><span id="15" class="" >    case 2 =&gt; summonInline[Missing2]
</span><span id="16" class="" >    case _ =&gt; summonInline[NotMissing]
</span><span id="17" class="" >
</span><span id="18" class="" >val missing1 = summonInlineCheck(1) // error: Missing One
</span><span id="19" class="" >val missing2 = summonInlineCheck(2) // error: Missing Two
</span><span id="20" class="" >val notMissing : NotMissing = summonInlineCheck(3)
</span></code></pre></div>

## Reference

For more information about compile-time operations, see [PR #4768](https://github.com/lampepfl/dotty/pull/4768),
which explains how `summonFrom`'s predecessor (implicit matches) can be used for typelevel programming and code specialization and [PR #7201](https://github.com/lampepfl/dotty/pull/7201) which explains the new `summonFrom` syntax.
