---
title: "Reflection"
next-page: /scala3/reference/metaprogramming/tasty-inspect
num: 32
type: section
previous-page: /scala3/reference/metaprogramming/staging
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

Reflection enables inspection and construction of Typed Abstract Syntax Trees
(Typed-AST). It may be used on quoted expressions (`quoted.Expr`) and quoted
types (`quoted.Type`) from [Macros](./macros.html) or on full TASTy files.

If you are writing macros, please first read [Macros](./macros.html).
You may find all you need without using quote reflection.

## API: From quotes and splices to TASTy reflect trees and back

With `quoted.Expr` and `quoted.Type` we can compute code but also analyze code
by inspecting the ASTs. [Macros](./macros.html) provide the guarantee that the
generation of code will be type-correct. Using quote reflection will break these
guarantees and may fail at macro expansion time, hence additional explicit
checks must be done.

To provide reflection capabilities in macros we need to add an implicit parameter
of type `scala.quoted.Quotes` and import `quotes.reflect.*` from it in the scope
where it is used.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >import scala.quoted.*
</span><span id="1" class="" >
</span><span id="2" class="" >inline def natConst(inline x: Int): Int = ${natConstImpl(&apos;{x})}
</span><span id="3" class="" >
</span><span id="4" class="" >def natConstImpl(x: Expr[Int])(using Quotes): Expr[Int] =
</span><span id="5" class="" >  import quotes.reflect.*
</span><span id="6" class="" >  ...
</span></code></pre></div>

### Extractors

`import quotes.reflect.*` will provide all extractors and methods on `quotes.reflect.Tree`s.
For example the `Literal(_)` extractor used below.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def natConstImpl(x: Expr[Int])(using Quotes): Expr[Int] =
</span><span id="1" class="" >  import quotes.reflect.*
</span><span id="2" class="" >  val tree: Term = x.asTerm
</span><span id="3" class="" >  tree match
</span><span id="4" class="" >    case Inlined(_, _, Literal(IntConstant(n))) =&gt;
</span><span id="5" class="" >      if n &lt;= 0 then
</span><span id="6" class="" >        report.error(&quot;Parameter must be natural number&quot;)
</span><span id="7" class="" >        &apos;{0}
</span><span id="8" class="" >      else
</span><span id="9" class="" >        tree.asExprOf[Int]
</span><span id="10" class="" >    case _ =&gt;
</span><span id="11" class="" >      report.error(&quot;Parameter must be a known constant&quot;)
</span><span id="12" class="" >      &apos;{0}
</span></code></pre></div>

We can easily know which extractors are needed using `Printer.TreeStructure.show`,
which returns the string representation the structure of the tree. Other printers
can also be found in the `Printer` module.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >tree.show(using Printer.TreeStructure)
</span><span id="1" class="" >// or
</span><span id="2" class="" >Printer.TreeStructure.show(tree)
</span></code></pre></div>

The methods `quotes.reflect.Term.{asExpr, asExprOf}` provide a way to go back to
a `quoted.Expr`. Note that `asExpr` returns a `Expr[Any]`. On the other hand
`asExprOf[T]` returns a `Expr[T]`, if the type does not conform to it an exception
will be thrown at runtime.

### Positions

The `Position` in the context provides an `ofMacroExpansion` value. It corresponds
to the expansion site for macros. The macro authors can obtain various information
about that expansion site. The example below shows how we can obtain position
information such as the start line, the end line or even the source code at the
expansion point.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def macroImpl()(quotes: Quotes): Expr[Unit] =
</span><span id="1" class="" >  import quotes.reflect.*
</span><span id="2" class="" >  val pos = Position.ofMacroExpansion
</span><span id="3" class="" >
</span><span id="4" class="" >  val path = pos.sourceFile.jpath.toString
</span><span id="5" class="" >  val start = pos.start
</span><span id="6" class="" >  val end = pos.end
</span><span id="7" class="" >  val startLine = pos.startLine
</span><span id="8" class="" >  val endLine = pos.endLine
</span><span id="9" class="" >  val startColumn = pos.startColumn
</span><span id="10" class="" >  val endColumn = pos.endColumn
</span><span id="11" class="" >  val sourceCode = pos.sourceCode
</span><span id="12" class="" >  ...
</span></code></pre></div>

### Tree Utilities

`quotes.reflect` contains three facilities for tree traversal and
transformation.

`TreeAccumulator` ties the knot of a traversal. By calling `foldOver(x, tree)(owner)`
we can dive into the `tree` node and start accumulating values of type `X` (e.g.,
of type `List[Symbol]` if we want to collect symbols). The code below, for
example, collects the `val` definitions in the tree.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def collectPatternVariables(tree: Tree)(using ctx: Context): List[Symbol] =
</span><span id="1" class="" >  val acc = new TreeAccumulator[List[Symbol]]:
</span><span id="2" class="" >    def foldTree(syms: List[Symbol], tree: Tree)(owner: Symbol): List[Symbol] = tree match
</span><span id="3" class="" >      case ValDef(_, _, rhs) =&gt;
</span><span id="4" class="" >        val newSyms = tree.symbol :: syms
</span><span id="5" class="" >        foldTree(newSyms, body)(tree.symbol)
</span><span id="6" class="" >      case _ =&gt;
</span><span id="7" class="" >        foldOverTree(syms, tree)(owner)
</span><span id="8" class="" >  acc(Nil, tree)
</span></code></pre></div>

A `TreeTraverser` extends a `TreeAccumulator` and performs the same traversal
but without returning any value. Finally, a `TreeMap` performs a transformation.

#### ValDef.let

`quotes.reflect.ValDef` also offers a method `let` that allows us to bind the `rhs` (right-hand side) to a `val` and use it in `body`.
Additionally, `lets` binds the given `terms` to names and allows to use them in the `body`.
Their type definitions are shown below:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def let(rhs: Term)(body: Ident =&gt; Term): Term = ...
</span><span id="1" class="" >
</span><span id="2" class="" >def lets(terms: List[Term])(body: List[Term] =&gt; Term): Term = ...
</span></code></pre></div>
