---
title: Inline
next-page: /scala3/reference/metaprogramming/compiletime-ops
num: 28
type: section
previous-page: /scala3/reference/metaprogramming
---

<!-- THIS FILE HAS BEEN GENERATED BY SCALADOC PREPROCESSOR. NOTE THAT ANY CHANGES TO THIS FILE CAN BE OVERRIDEN IN THE FUTURE -->

## Inline Definitions

`inline` is a new [soft modifier](../soft-modifier.html) that guarantees that a
definition will be inlined at the point of use. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >object Config:
</span><span id="1" class="" >  inline val logging = false
</span><span id="2" class="" >
</span><span id="3" class="" >object Logger:
</span><span id="4" class="" >
</span><span id="5" class="" >  private var indent = 0
</span><span id="6" class="" >
</span><span id="7" class="" >  inline def log[T](msg: String, indentMargin: =&gt;Int)(op: =&gt; T): T =
</span><span id="8" class="" >    if Config.logging then
</span><span id="9" class="" >      println(s&quot;${&quot;  &quot; * indent}start $msg&quot;)
</span><span id="10" class="" >      indent += indentMargin
</span><span id="11" class="" >      val result = op
</span><span id="12" class="" >      indent -= indentMargin
</span><span id="13" class="" >      println(s&quot;${&quot;  &quot; * indent}$msg = $result&quot;)
</span><span id="14" class="" >      result
</span><span id="15" class="" >    else op
</span><span id="16" class="" >end Logger
</span></code></pre></div>

The `Config` object contains a definition of the **inline value** `logging`.
This means that `logging` is treated as a _constant value_, equivalent to its
right-hand side `false`. The right-hand side of such an `inline val` must itself
be a [constant expression](https://scala-lang.org/files/archive/spec/2.13/06-expressions.html#constant-expressions).
Used in this way, `inline` is equivalent to Java and Scala 2's `final`. Note that `final`, meaning
_inlined constant_, is still supported in Scala 3, but will be phased out.

The `Logger` object contains a definition of the **inline method** `log`. This
method will always be inlined at the point of call.

In the inlined code, an `if-then-else` with a constant condition will be rewritten
to its `then`- or `else`-part. Consequently, in the `log` method above the
`if Config.logging` with `Config.logging == true` will get rewritten into its
`then`-part.

Here's an example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >var indentSetting = 2
</span><span id="1" class="" >
</span><span id="2" class="" >def factorial(n: BigInt): BigInt =
</span><span id="3" class="" >  log(s&quot;factorial($n)&quot;, indentSetting) {
</span><span id="4" class="" >    if n == 0 then 1
</span><span id="5" class="" >    else n * factorial(n - 1)
</span><span id="6" class="" >  }
</span></code></pre></div>

If `Config.logging == false`, this will be rewritten (simplified) to:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def factorial(n: BigInt): BigInt =
</span><span id="1" class="" >  if n == 0 then 1
</span><span id="2" class="" >  else n * factorial(n - 1)
</span></code></pre></div>

As you notice, since neither `msg` or `indentMargin` were used, they do not
appear in the generated code for `factorial`. Also note the body of our `log`
method: the `else-` part reduces to just an `op`. In the generated code we do
not generate any closures because we only refer to a by-name parameter *once*.
Consequently, the code was inlined directly and the call was beta-reduced.

In the `true` case the code will be rewritten to:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >def factorial(n: BigInt): BigInt =
</span><span id="1" class="" >  val msg = s&quot;factorial($n)&quot;
</span><span id="2" class="" >  println(s&quot;${&quot;  &quot; * indent}start $msg&quot;)
</span><span id="3" class="" >  Logger.inline$indent_=(indent.+(indentSetting))
</span><span id="4" class="" >  val result =
</span><span id="5" class="" >    if n == 0 then 1
</span><span id="6" class="" >    else n * factorial(n - 1)
</span><span id="7" class="" >  Logger.inline$indent_=(indent.-(indentSetting))
</span><span id="8" class="" >  println(s&quot;${&quot;  &quot; * indent}$msg = $result&quot;)
</span><span id="9" class="" >  result
</span></code></pre></div>

Note that the by-value parameter `msg` is evaluated only once, per the usual Scala
semantics, by binding the value and reusing the `msg` through the body of
`factorial`. Also, note the special handling of the assignment to the private var
`indent`. It is achieved by generating a setter method `def inline$indent_=` and calling it instead.

### Recursive Inline Methods

Inline methods can be recursive. For instance, when called with a constant
exponent `n`, the following method for `power` will be implemented by
straight inline code without any loop or recursion.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >inline def power(x: Double, n: Int): Double =
</span><span id="1" class="" >  if n == 0 then 1.0
</span><span id="2" class="" >  else if n == 1 then x
</span><span id="3" class="" >  else
</span><span id="4" class="" >    val y = power(x, n / 2)
</span><span id="5" class="" >    if n % 2 == 0 then y * y else y * y * x
</span><span id="6" class="" >
</span><span id="7" class="" >power(expr, 10)
</span><span id="8" class="" >// translates to
</span><span id="9" class="" >//
</span><span id="10" class="" >//   val x = expr
</span><span id="11" class="" >//   val y1 = x * x   // ^2
</span><span id="12" class="" >//   val y2 = y1 * y1 // ^4
</span><span id="13" class="" >//   val y3 = y2 * x  // ^5
</span><span id="14" class="" >//   y3 * y3          // ^10
</span></code></pre></div>

Parameters of inline methods can have an `inline` modifier as well. This means
that actual arguments to these parameters will be inlined in the body of the
`inline def`. `inline` parameters have call semantics equivalent to by-name parameters
but allow for duplication of the code in the argument. It is usually useful when constant
values need to be propagated to allow further optimizations/reductions.

The following example shows the difference in translation between by-value, by-name and `inline`
parameters:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >inline def funkyAssertEquals(actual: Double, expected: =&gt;Double, inline delta: Double): Unit =
</span><span id="1" class="" >  if (actual - expected).abs &gt; delta then
</span><span id="2" class="" >    throw new AssertionError(s&quot;difference between ${expected} and ${actual} was larger than ${delta}&quot;)
</span><span id="3" class="" >
</span><span id="4" class="" >funkyAssertEquals(computeActual(), computeExpected(), computeDelta())
</span><span id="5" class="" >// translates to
</span><span id="6" class="" >//
</span><span id="7" class="" >//   val actual = computeActual()
</span><span id="8" class="" >//   def expected = computeExpected()
</span><span id="9" class="" >//   if (actual - expected).abs &gt; computeDelta() then
</span><span id="10" class="" >//     throw new AssertionError(s&quot;difference between ${expected} and ${actual} was larger than ${computeDelta()}&quot;)
</span></code></pre></div>

### Rules for Overriding

Inline methods can override other non-inline methods. The rules are as follows:

1. If an inline method `f` implements or overrides another, non-inline method, the inline method can also be invoked at runtime. For instance, consider the scenario:

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >abstract class A:
   </span><span id="1" class="" >  def f: Int
   </span><span id="2" class="" >  def g: Int = f
   </span><span id="3" class="" >
   </span><span id="4" class="" >class B extends A:
   </span><span id="5" class="" >  inline def f = 22
   </span><span id="6" class="" >  override inline def g = f + 11
   </span><span id="7" class="" >
   </span><span id="8" class="" >val b = new B
   </span><span id="9" class="" >val a: A = b
   </span><span id="10" class="" >// inlined invocatons
   </span><span id="11" class="" >assert(b.f == 22)
   </span><span id="12" class="" >assert(b.g == 33)
   </span><span id="13" class="" >// dynamic invocations
   </span><span id="14" class="" >assert(a.f == 22)
   </span><span id="15" class="" >assert(a.g == 33)
   </span></code></pre></div>

   The inlined invocations and the dynamically dispatched invocations give the same results.

2. Inline methods are effectively final.

3. Inline methods can also be abstract. An abstract inline method can be implemented only by other inline methods. It cannot be invoked directly:

   <div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >abstract class A:
   </span><span id="1" class="" >  inline def f: Int
   </span><span id="2" class="" >
   </span><span id="3" class="" >object B extends A:
   </span><span id="4" class="" >  inline def f: Int = 22
   </span><span id="5" class="" >
   </span><span id="6" class="" >B.f         // OK
   </span><span id="7" class="" >val a: A = B
   </span><span id="8" class="" >a.f         // error: cannot inline f in A.
   </span></code></pre></div>

### Relationship to `@inline`

Scala 2 also defines a `@inline` annotation which is used as a hint for the
backend to inline code. The `inline` modifier is a more powerful option:

- expansion is guaranteed instead of best effort,
- expansion happens in the frontend instead of in the backend and
- expansion also applies to recursive methods.

<!--- (Commented out since the docs and implementation differ)
### Evaluation Rules
As you noticed by the examples above a lambda of the form
`((x_1, ..., x_n) => B)(E_1, ..., E_n)` is rewritten to:
```
{ val/def x_1 = E_1
...
val/def x_n = E_n
B
}
```
where vals are used for value parameter bindings and defs are used for by-name
parameter bindings. If an argument `E_i` is a simple variable reference `y`, the
corresponding binding is omitted and `y` is used instead of `x_i` in `B`.
If a `inline` modifier is given for parameters, corresponding arguments must be
pure expressions of constant type.
-->

#### The definition of constant expression

Right-hand sides of inline values and of arguments for inline parameters must be
constant expressions in the sense defined by the [SLS §6.24](https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#constant-expressions),
including _platform-specific_ extensions such as constant folding of pure
numeric computations.

An inline value must have a literal type such as `1` or `true`.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >inline val four = 4
</span><span id="1" class="" >// equivalent to
</span><span id="2" class="" >inline val four: 4 = 4
</span></code></pre></div>

It is also possible to have inline vals of types that do not have a syntax, such as `Short(4)`.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait InlineConstants:
</span><span id="1" class="" >  inline val myShort: Short
</span><span id="2" class="" >
</span><span id="3" class="" >object Constants extends InlineConstants:
</span><span id="4" class="" >  inline val myShort/*: Short(4)*/ = 4
</span></code></pre></div>

## Transparent Inline Methods

Inline methods can additionally be declared `transparent`.
This means that the return type of the inline method can be
specialized to a more precise type upon expansion. Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >class A
</span><span id="1" class="" >class B extends A:
</span><span id="2" class="" >  def m = true
</span><span id="3" class="" >
</span><span id="4" class="" >transparent inline def choose(b: Boolean): A =
</span><span id="5" class="" >  if b then new A else new B
</span><span id="6" class="" >
</span><span id="7" class="" >val obj1 = choose(true)  // static type is A
</span><span id="8" class="" >val obj2 = choose(false) // static type is B
</span><span id="9" class="" >
</span><span id="10" class="" >// obj1.m // compile-time error: `m` is not defined on `A`
</span><span id="11" class="" >obj2.m    // OK
</span></code></pre></div>

Here, the inline method `choose` returns an instance of either of the two types `A` or `B`.
If `choose` had not been declared to be `transparent`, the result
of its expansion would always be of type `A`, even though the computed value might be of the subtype `B`.
The inline method is a "blackbox" in the sense that details of its implementation do not leak out.
But if a `transparent` modifier is given, the expansion is the type of the expanded body. If the argument `b`
is `true`, that type is `A`, otherwise it is `B`. Consequently, calling `m` on `obj2`
type-checks since `obj2` has the same type as the expansion of `choose(false)`, which is `B`.
Transparent inline methods are "whitebox" in the sense that the type
of an application of such a method can be more specialized than its declared
return type, depending on how the method expands.

In the following example, we see how the return type of `zero` is specialized to
the singleton type `0` permitting the addition to be ascribed with the correct
type `1`.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >transparent inline def zero: Int = 0
</span><span id="1" class="" >
</span><span id="2" class="" >val one: 1 = zero + 1
</span></code></pre></div>

### Transparent vs. non-transparent inline

As we already discussed, transparent inline methods may influence type checking at call site.
Technically this implies that transparent inline methods must be expanded during type checking of the program.
Other inline methods are inlined later after the program is fully typed.

For example, the following two functions will be typed the same way but will be inlined at different times.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >inline def f1: T = ...
</span><span id="1" class="" >transparent inline def f2: T = (...): T
</span></code></pre></div>

A noteworthy difference is the behavior of `transparent inline given`.
If there is an error reported when inlining that definition, it will be considered as an implicit search mismatch and the search will continue.
A `transparent inline given` can add a type ascription in its RHS (as in `f2` from the previous example) to avoid the precise type but keep the search behavior.
On the other hand, an `inline given` is taken as an implicit and then inlined after typing.
Any error will be emitted as usual.

## Inline Conditionals

An if-then-else expression whose condition is a constant expression can be simplified to
the selected branch. Prefixing an if-then-else expression with `inline` enforces that
the condition has to be a constant expression, and thus guarantees that the conditional will always
simplify.

Example:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >inline def update(delta: Int) =
</span><span id="1" class="" >  inline if delta &gt;= 0 then increaseBy(delta)
</span><span id="2" class="" >  else decreaseBy(-delta)
</span></code></pre></div>

A call `update(22)` would rewrite to `increaseBy(22)`. But if `update` was called with
a value that was not a compile-time constant, we would get a compile time error like the one
below:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >|  inline if delta &gt;= 0 then ???
</span><span id="1" class="" >  |  ^
</span><span id="2" class="" >  |  cannot reduce inline if
</span><span id="3" class="" >  |   its condition
</span><span id="4" class="" >  |     delta &gt;= 0
</span><span id="5" class="" >  |   is not a constant value
</span><span id="6" class="" >  | This location is in code that was inlined at ...
</span></code></pre></div>

In a transparent inline, an `inline if` will force the inlining of any inline definition in its condition during type checking.

## Inline Matches

A `match` expression in the body of an `inline` method definition may be
prefixed by the `inline` modifier. If there is enough static information to
unambiguously take a branch, the expression is reduced to that branch and the
type of the result is taken. If not, a compile-time error is raised that
reports that the match cannot be reduced.

The example below defines an inline method with a
single inline match expression that picks a case based on its static type:

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >transparent inline def g(x: Any): Any =
</span><span id="1" class="" >  inline x match
</span><span id="2" class="" >    case x: String =&gt; (x, x) // Tuple2[String, String](x, x)
</span><span id="3" class="" >    case x: Double =&gt; x
</span><span id="4" class="" >
</span><span id="5" class="" >g(1.0d) // Has type 1.0d which is a subtype of Double
</span><span id="6" class="" >g(&quot;test&quot;) // Has type (String, String)
</span></code></pre></div>

The scrutinee `x` is examined statically and the inline match is reduced
accordingly returning the corresponding value (with the type specialized because `g` is declared `transparent`). This example performs a simple type test over the
scrutinee. The type can have a richer structure like the simple ADT below.
`toInt` matches the structure of a number in [Church-encoding](https://en.wikipedia.org/wiki/Church_encoding)
and _computes_ the corresponding integer.

<div class="snippet" ><div class="buttons"></div><pre><code class="language-scala"><span id="0" class="" >trait Nat
</span><span id="1" class="" >case object Zero extends Nat
</span><span id="2" class="" >case class Succ[N &lt;: Nat](n: N) extends Nat
</span><span id="3" class="" >
</span><span id="4" class="" >transparent inline def toInt(n: Nat): Int =
</span><span id="5" class="" >  inline n match
</span><span id="6" class="" >    case Zero     =&gt; 0
</span><span id="7" class="" >    case Succ(n1) =&gt; toInt(n1) + 1
</span><span id="8" class="" >
</span><span id="9" class="" >inline val natTwo = toInt(Succ(Succ(Zero)))
</span><span id="10" class="" >val intTwo: 2 = natTwo
</span></code></pre></div>

`natTwo` is inferred to have the singleton type 2.

### Reference

For more information about the semantics of `inline`, see the [Scala 2020: Semantics-preserving inlining for metaprogramming](https://dl.acm.org/doi/10.1145/3426426.3428486) paper.
