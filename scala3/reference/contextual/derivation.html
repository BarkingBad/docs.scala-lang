<!DOCTYPE html>

<html class="scala3">

  <head>
    <title>
      Type Class Derivation | 
      Scala 3 Language Reference | 
      Scala Documentation
    </title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta property="og:site_name" content="Scala Documentation"/>
    <meta property="og:type" content="article"/>
    <meta property="og:url" content="http://0.0.0.0:4000/scala3/reference/contextual/derivation.html"/>
    <meta property="og:image" content="http://0.0.0.0:4000/resources/img/scala-spiral-3d-2-toned-down.png"/>
    <meta property="og:title" content="Type Class Derivation"/>
    

    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@scala_lang"/>
    <meta name="twitter:creator" content="@scala_lang"/>
    <meta name="twitter:title" content="Type Class Derivation"/>
    

    <link rel="icon" type="image/png" href="docs.scala-lang//resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="docs.scala-lang//resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="docs.scala-lang//resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="docs.scala-lang//resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="docs.scala-lang//resources/favicon-16x16.png">
    <link rel="manifest" href="docs.scala-lang//resources/site.webmanifest">
    <link rel="mask-icon" href="docs.scala-lang//resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="docs.scala-lang//resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="docs.scala-lang//resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="docs.scala-lang//resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="docs.scala-lang//resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="docs.scala-lang//resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>





<div class="navigation-fade-screen"></div>



<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="docs.scala-lang//resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="docs.scala-lang//" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>



<header id="doc-header" class="scala3">

  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      
      <div class="navigation-bdand">
      <a href="docs.scala-lang//">
        <img src="docs.scala-lang//resources/img/documentation-logo@2x.png" alt="docs">
      </a>
      <span class="doc-language-version">
        â€” Scala  3 
      </span>
      </div>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              
              
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    
                    
                    <a href="docs.scala-lang//scala3/new-in-scala3.html">New in Scala 3</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="docs.scala-lang//scala3/getting-started.html">Getting Started</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="docs.scala-lang//scala3/book/introduction.html">Scala 3 Book</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="docs.scala-lang//scala3/guides/macros/index.html">Macro Tutorial</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              
              
              <a href="docs.scala-lang//scala3/guides/migration/compatibility-intro.html" id="migrate" >Migrate</a>
                
            </li>
        
            <li class="navigation-menu-item">
              
              
              <a href="docs.scala-lang//scala3/reference/overview.html" id="reference" >Reference</a>
                
            </li>
        
            <li class="navigation-menu-item">
              
              
              <a href="https://dotty.epfl.ch/api/index.html" id="api" >API</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="docs.scala-lang//scala3/new-in-scala3.html">New in Scala 3</a>
              </li>
            
              <li>
                <a href="docs.scala-lang//scala3/getting-started.html">Getting Started</a>
              </li>
            
              <li>
                <a href="docs.scala-lang//scala3/book/introduction.html">Scala 3 Book</a>
              </li>
            
              <li>
                <a href="docs.scala-lang//scala3/guides/macros/index.html">Macro Tutorial</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="https://dotty.epfl.ch/api/index.html">API</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">
  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        
          <div class="wip-notice">
            <h4>Work in Progress</h4>
            <p>
              We are still in the process of writing the documentation for Scala 3.
              You can <a  href="/scala3/contribute-to-docs.html">help us</a> to improve the documentation.
            </p>
            <p>Are you searching for the <a href="/">Scala 2 documentation</a>?</p>
          </div>
        

        <div class="titles">
          
            <div class="supertitle">Scala 3 Language Reference</div>
          
          <h1>Type Class Derivation</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation">
			<div class="inner-box">
				<div class="toc-context">
					<p>Type class derivation is a way to automatically generate given instances for type classes which satisfy some simple
conditions. A type class in this sense is any trait or class with a type parameter determining the type being operated
on. Common examples are <code class="language-plaintext highlighter-rouge">Eq</code>, <code class="language-plaintext highlighter-rouge">Ordering</code>, or <code class="language-plaintext highlighter-rouge">Show</code>. For example, given the following <code class="language-plaintext highlighter-rouge">Tree</code> algebraic data type
(ADT),</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enum</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="n">derives</span> <span class="nc">Eq</span><span class="o">,</span> <span class="nc">Ordering</span><span class="o">,</span> <span class="nc">Show</span><span class="k">:</span>
  <span class="kt">case</span> <span class="kt">Branch</span><span class="o">(</span><span class="kt">left:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
  <span class="k">case</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">derives</code> clause generates the following given instances for the <code class="language-plaintext highlighter-rouge">Eq</code>, <code class="language-plaintext highlighter-rouge">Ordering</code> and <code class="language-plaintext highlighter-rouge">Show</code> type classes in the
companion object of <code class="language-plaintext highlighter-rouge">Tree</code>,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">given</span> <span class="o">[</span><span class="kt">T:</span> <span class="kt">Eq</span><span class="o">]</span>       <span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span>    <span class="k">=</span> <span class="nv">Eq</span><span class="o">.</span><span class="py">derived</span>
<span class="n">given</span> <span class="o">[</span><span class="kt">T:</span> <span class="kt">Ordering</span><span class="o">]</span> <span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Tree</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Ordering</span><span class="o">.</span><span class="py">derived</span>
<span class="n">given</span> <span class="o">[</span><span class="kt">T:</span> <span class="kt">Show</span><span class="o">]</span>     <span class="k">:</span> <span class="kt">Show</span><span class="o">[</span><span class="kt">Tree</span><span class="o">]</span>     <span class="k">=</span> <span class="nv">Show</span><span class="o">.</span><span class="py">derived</span>
</code></pre></div></div>

<p>We say that <code class="language-plaintext highlighter-rouge">Tree</code> is the <em>deriving type</em> and that the <code class="language-plaintext highlighter-rouge">Eq</code>, <code class="language-plaintext highlighter-rouge">Ordering</code> and <code class="language-plaintext highlighter-rouge">Show</code> instances are <em>derived instances</em>.</p>

<h3 id="types-supporting-derives-clauses">Types supporting <code class="language-plaintext highlighter-rouge">derives</code> clauses</h3>

<p>All data types can have a <code class="language-plaintext highlighter-rouge">derives</code> clause. This document focuses primarily on data types which also have a given instance
of the <code class="language-plaintext highlighter-rouge">Mirror</code> type class available. Instances of the <code class="language-plaintext highlighter-rouge">Mirror</code> type class are generated automatically by the compiler
for,</p>

<ul>
  <li>enums and enum cases</li>
  <li>case classes and case objects</li>
  <li>sealed classes or traits that have only case classes and case objects as children</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Mirror</code> type class instances provide information at the type level about the components and labelling of the type.
They also provide minimal term level infrastructure to allow higher level libraries to provide comprehensive
derivation support.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Mirror</span><span class="k">:</span>

  <span class="kt">/**</span> <span class="kt">the</span> <span class="k">type</span> <span class="kt">being</span> <span class="kt">mirrored</span> <span class="kt">*/</span>
  <span class="k">type</span> <span class="kt">MirroredType</span>

  <span class="cm">/** the type of the elements of the mirrored type */</span>
  <span class="k">type</span> <span class="kt">MirroredElemTypes</span>

  <span class="cm">/** The mirrored *-type */</span>
  <span class="k">type</span> <span class="kt">MirroredMonoType</span>

  <span class="cm">/** The name of the type */</span>
  <span class="k">type</span> <span class="kt">MirroredLabel</span> <span class="k">&lt;:</span> <span class="kt">String</span>

  <span class="cm">/** The names of the elements of the type */</span>
  <span class="k">type</span> <span class="kt">MirroredElemLabels</span> <span class="k">&lt;:</span> <span class="kt">Tuple</span>

<span class="k">object</span> <span class="nc">Mirror</span><span class="k">:</span>

  <span class="kt">/**</span> <span class="kt">The</span> <span class="kt">Mirror</span> <span class="kt">for</span> <span class="kt">a</span> <span class="kt">product</span> <span class="k">type</span> <span class="kt">*/</span>
  <span class="kt">trait</span> <span class="kt">Product</span> <span class="kt">extends</span> <span class="kt">Mirror:</span>

    <span class="kt">/**</span> <span class="kt">Create</span> <span class="kt">a</span> <span class="kt">new</span> <span class="kt">instance</span> <span class="kt">of</span> <span class="k">type</span> <span class="kt">`T`</span> <span class="kt">with</span> <span class="kt">elements</span>
     <span class="o">*</span>  <span class="n">taken</span> <span class="n">from</span> <span class="n">product</span> <span class="n">`p`</span><span class="o">.</span>
     <span class="o">*/</span>
    <span class="k">def</span> <span class="nf">fromProduct</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">scala.Product</span><span class="o">)</span><span class="k">:</span> <span class="kt">MirroredMonoType</span>

  <span class="k">trait</span> <span class="nc">Sum</span> <span class="k">extends</span> <span class="nc">Mirror</span><span class="k">:</span>

    <span class="kt">/**</span> <span class="kt">The</span> <span class="kt">ordinal</span> <span class="kt">number</span> <span class="kt">of</span> <span class="kt">the</span> <span class="kt">case</span> <span class="kt">class</span> <span class="kt">of</span> <span class="kt">`x`.</span>
     <span class="kt">*</span>  <span class="kt">For</span> <span class="kt">enums</span><span class="o">,</span> <span class="n">`ordinal(x) == x.ordinal`</span>
     <span class="o">*/</span>
    <span class="k">def</span> <span class="nf">ordinal</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">MirroredMonoType</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>

<span class="n">end</span> <span class="nc">Mirror</span>
</code></pre></div></div>

<p>Product types (i.e. case classes and objects, and enum cases) have mirrors which are subtypes of <code class="language-plaintext highlighter-rouge">Mirror.Product</code>. Sum
types (i.e. sealed class or traits with product children, and enums) have mirrors which are subtypes of <code class="language-plaintext highlighter-rouge">Mirror.Sum</code>.</p>

<p>For the <code class="language-plaintext highlighter-rouge">Tree</code> ADT from above the following <code class="language-plaintext highlighter-rouge">Mirror</code> instances will be automatically provided by the compiler,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Mirror for Tree</span>
<span class="k">new</span> <span class="nv">Mirror</span><span class="o">.</span><span class="py">Sum</span><span class="k">:</span>
  <span class="k">type</span> <span class="kt">MirroredType</span> <span class="o">=</span> <span class="nc">Tree</span>
  <span class="k">type</span> <span class="kt">MirroredElemTypes</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Branch</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="nc">Leaf</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
  <span class="k">type</span> <span class="kt">MirroredMonoType</span> <span class="o">=</span> <span class="nc">Tree</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">MirroredLabel</span> <span class="o">=</span> <span class="s">"Tree"</span>
  <span class="k">type</span> <span class="kt">MirroredElemLabels</span> <span class="o">=</span> <span class="o">(</span><span class="s">"Branch"</span><span class="o">,</span> <span class="s">"Leaf"</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">ordinal</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">MirroredMonoType</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">Leaf</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="mi">1</span>

<span class="c1">// Mirror for Branch</span>
<span class="k">new</span> <span class="nv">Mirror</span><span class="o">.</span><span class="py">Product</span><span class="k">:</span>
  <span class="k">type</span> <span class="kt">MirroredType</span> <span class="o">=</span> <span class="nc">Branch</span>
  <span class="k">type</span> <span class="kt">MirroredElemTypes</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
  <span class="k">type</span> <span class="kt">MirroredMonoType</span> <span class="o">=</span> <span class="nc">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">MirroredLabel</span> <span class="o">=</span> <span class="s">"Branch"</span>
  <span class="k">type</span> <span class="kt">MirroredElemLabels</span> <span class="o">=</span> <span class="o">(</span><span class="s">"left"</span><span class="o">,</span> <span class="s">"right"</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">fromProduct</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Product</span><span class="o">)</span><span class="k">:</span> <span class="kt">MirroredMonoType</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Branch</span><span class="o">(...)</span>

<span class="c1">// Mirror for Leaf</span>
<span class="k">new</span> <span class="nv">Mirror</span><span class="o">.</span><span class="py">Product</span><span class="k">:</span>
  <span class="k">type</span> <span class="kt">MirroredType</span> <span class="o">=</span> <span class="nc">Leaf</span>
  <span class="k">type</span> <span class="kt">MirroredElemTypes</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Tuple1</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">MirroredMonoType</span> <span class="o">=</span> <span class="nc">Leaf</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">MirroredLabel</span> <span class="o">=</span> <span class="s">"Leaf"</span>
  <span class="k">type</span> <span class="kt">MirroredElemLabels</span> <span class="o">=</span> <span class="nc">Tuple1</span><span class="o">[</span><span class="err">"</span><span class="kt">elem</span><span class="err">"</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">fromProduct</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Product</span><span class="o">)</span><span class="k">:</span> <span class="kt">MirroredMonoType</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Leaf</span><span class="o">(...)</span>
</code></pre></div></div>

<p>Note the following properties of <code class="language-plaintext highlighter-rouge">Mirror</code> types,</p>

<ul>
  <li>Properties are encoded using types rather than terms. This means that they have no runtime footprint unless used and
also that they are a compile time feature for use with Scala 3â€™s metaprogramming facilities.</li>
  <li>The kinds of <code class="language-plaintext highlighter-rouge">MirroredType</code> and <code class="language-plaintext highlighter-rouge">MirroredElemTypes</code> match the kind of the data type the mirror is an instance for.
This allows <code class="language-plaintext highlighter-rouge">Mirror</code>s to support ADTs of all kinds.</li>
  <li>There is no distinct representation type for sums or products (ie. there is no <code class="language-plaintext highlighter-rouge">HList</code> or <code class="language-plaintext highlighter-rouge">Coproduct</code> type as in
Scala 2 versions of Shapeless). Instead the collection of child types of a data type is represented by an ordinary,
possibly parameterized, tuple type. Scala 3â€™s metaprogramming facilities can be used to work with these tuple types
as-is, and higher level libraries can be built on top of them.</li>
  <li>For both product and sum types, the elements of <code class="language-plaintext highlighter-rouge">MirroredElemTypes</code> are arranged in definition order (i.e. <code class="language-plaintext highlighter-rouge">Branch[T]</code>
precedes <code class="language-plaintext highlighter-rouge">Leaf[T]</code> in <code class="language-plaintext highlighter-rouge">MirroredElemTypes</code> for <code class="language-plaintext highlighter-rouge">Tree</code> because <code class="language-plaintext highlighter-rouge">Branch</code> is defined before <code class="language-plaintext highlighter-rouge">Leaf</code> in the source file).
This means that <code class="language-plaintext highlighter-rouge">Mirror.Sum</code> differs in this respect from Shapelessâ€™s generic representation for ADTs in Scala 2,
where the constructors are ordered alphabetically by name.</li>
  <li>The methods <code class="language-plaintext highlighter-rouge">ordinal</code> and <code class="language-plaintext highlighter-rouge">fromProduct</code> are defined in terms of <code class="language-plaintext highlighter-rouge">MirroredMonoType</code> which is the type of kind-<code class="language-plaintext highlighter-rouge">*</code>
which is obtained from <code class="language-plaintext highlighter-rouge">MirroredType</code> by wildcarding its type parameters.</li>
</ul>

<h3 id="type-classes-supporting-automatic-deriving">Type classes supporting automatic deriving</h3>

<p>A trait or class can appear in a <code class="language-plaintext highlighter-rouge">derives</code> clause if its companion object defines a method named <code class="language-plaintext highlighter-rouge">derived</code>. The
signature and implementation of a <code class="language-plaintext highlighter-rouge">derived</code> method for a type class <code class="language-plaintext highlighter-rouge">TC[_]</code> are arbitrary but it is typically of the
following form,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.deriving.Mirror</span>

<span class="k">def</span> <span class="nf">derived</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">using</span> <span class="nv">Mirror</span><span class="o">.</span><span class="py">Of</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">TC</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</code></pre></div></div>

<p>That is, the <code class="language-plaintext highlighter-rouge">derived</code> method takes a context parameter of (some subtype of) type <code class="language-plaintext highlighter-rouge">Mirror</code> which defines the shape of
the deriving type <code class="language-plaintext highlighter-rouge">T</code>, and computes the type class implementation according to that shape. This is all that the
provider of an ADT with a <code class="language-plaintext highlighter-rouge">derives</code> clause has to know about the derivation of a type class instance.</p>

<p>Note that <code class="language-plaintext highlighter-rouge">derived</code> methods may have context <code class="language-plaintext highlighter-rouge">Mirror</code> parameters indirectly (e.g. by having a context argument which in turn
has a context <code class="language-plaintext highlighter-rouge">Mirror</code> parameter, or not at all (e.g. they might use some completely different user-provided mechanism, for
instance using Scala 3 macros or runtime reflection). We expect that (direct or indirect) <code class="language-plaintext highlighter-rouge">Mirror</code> based implementations
will be the most common and that is what this document emphasises.</p>

<p>Type class authors will most likely use higher level derivation or generic programming libraries to implement
<code class="language-plaintext highlighter-rouge">derived</code> methods. An example of how a <code class="language-plaintext highlighter-rouge">derived</code> method might be implemented using <em>only</em> the low level facilities
described above and Scala 3â€™s general metaprogramming features is provided below. It is not anticipated that type class
authors would normally implement a <code class="language-plaintext highlighter-rouge">derived</code> method in this way, however this walkthrough can be taken as a guide for
authors of the higher level derivation libraries that we expect typical type class authors will use (for a fully
worked out example of such a library, see <a href="https://github.com/milessabin/shapeless/tree/shapeless-3">Shapeless 3</a>).</p>

<h4 id="how-to-write-a-type-class-derived-method-using-low-level-mechanisms">How to write a type class <code class="language-plaintext highlighter-rouge">derived</code> method using low level mechanisms</h4>

<p>The low-level method we will use to implement a type class <code class="language-plaintext highlighter-rouge">derived</code> method in this example exploits three new
type-level constructs in Scala 3: inline methods, inline matches, and implicit searches via  <code class="language-plaintext highlighter-rouge">summonInline</code> or <code class="language-plaintext highlighter-rouge">summonFrom</code>. Given this definition of the
<code class="language-plaintext highlighter-rouge">Eq</code> type class,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="nc">:</span>
  <span class="k">def</span> <span class="nf">eqv</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
</code></pre></div></div>

<p>we need to implement a method <code class="language-plaintext highlighter-rouge">Eq.derived</code> on the companion object of <code class="language-plaintext highlighter-rouge">Eq</code> that produces a given instance for <code class="language-plaintext highlighter-rouge">Eq[T]</code> given
a <code class="language-plaintext highlighter-rouge">Mirror[T]</code>. Here is a possible implementation,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.deriving.Mirror</span>

<span class="n">inline</span> <span class="n">given</span> <span class="n">derived</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">using</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Mirror.Of</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">val</span> <span class="nv">elemInstances</span> <span class="k">=</span> <span class="n">summonAll</span><span class="o">[</span><span class="kt">m.MirroredElemTypes</span><span class="o">]</span>           <span class="c1">// (1)</span>
  <span class="n">inline</span> <span class="n">m</span> <span class="k">match</span>                                               <span class="c1">// (2)</span>
    <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Mirror.SumOf</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>     <span class="k">=&gt;</span> <span class="nf">eqSum</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">elemInstances</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Mirror.ProductOf</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nf">eqProduct</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">elemInstances</span><span class="o">)</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">derived</code> is defined as an <code class="language-plaintext highlighter-rouge">inline</code> given. This means that the method will be expanded at
call sites (for instance the compiler generated instance definitions in the companion objects of ADTs which have a
<code class="language-plaintext highlighter-rouge">derived Eq</code> clause), and also that it can be used recursively if necessary, to compute instances for children.</p>

<p>The body of this method (1) first materializes the <code class="language-plaintext highlighter-rouge">Eq</code> instances for all the child types of type the instance is
being derived for. This is either all the branches of a sum type or all the fields of a product type. The
implementation of <code class="language-plaintext highlighter-rouge">summonAll</code> is <code class="language-plaintext highlighter-rouge">inline</code> and uses Scala 3â€™s <code class="language-plaintext highlighter-rouge">summonInline</code> construct to collect the instances as a
<code class="language-plaintext highlighter-rouge">List</code>,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inline</span> <span class="k">def</span> <span class="nf">summonAll</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Tuple</span><span class="o">]</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Eq</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">inline</span> <span class="n">erasedValue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">match</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">EmptyTuple</span> <span class="o">=&gt;</span> <span class="nc">Nil</span>
    <span class="k">case</span> <span class="nf">_:</span> <span class="o">(</span><span class="n">t</span> <span class="o">*:</span> <span class="n">ts</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">summonInline</span><span class="o">[</span><span class="kt">Eq</span><span class="o">[</span><span class="kt">t</span><span class="o">]]</span> <span class="o">::</span> <span class="n">summonAll</span><span class="o">[</span><span class="kt">ts</span><span class="o">]</span>
</code></pre></div></div>

<p>with the instances for children in hand the <code class="language-plaintext highlighter-rouge">derived</code> method uses an <code class="language-plaintext highlighter-rouge">inline match</code> to dispatch to methods which can
construct instances for either sums or products (2). Note that because <code class="language-plaintext highlighter-rouge">derived</code> is <code class="language-plaintext highlighter-rouge">inline</code> the match will be
resolved at compile-time and only the left-hand side of the matching case will be inlined into the generated code with
types refined as revealed by the match.</p>

<p>In the sum case, <code class="language-plaintext highlighter-rouge">eqSum</code>, we use the runtime <code class="language-plaintext highlighter-rouge">ordinal</code> values of the arguments to <code class="language-plaintext highlighter-rouge">eqv</code> to first check if the two
values are of the same subtype of the ADT (3) and then, if they are, to further test for equality based on the <code class="language-plaintext highlighter-rouge">Eq</code>
instance for the appropriate ADT subtype using the auxiliary method <code class="language-plaintext highlighter-rouge">check</code> (4).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.deriving.Mirror</span>

<span class="k">def</span> <span class="nf">eqSum</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">Mirror.SumOf</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Eq</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="k">:</span>
    <span class="kt">def</span> <span class="kt">eqv</span><span class="o">(</span><span class="kt">x:</span> <span class="kt">T</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
      <span class="k">val</span> <span class="nv">ordx</span> <span class="k">=</span> <span class="nv">s</span><span class="o">.</span><span class="py">ordinal</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>                            <span class="c1">// (3)</span>
      <span class="o">(</span><span class="nv">s</span><span class="o">.</span><span class="py">ordinal</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">==</span> <span class="n">ordx</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="o">(</span><span class="nf">elems</span><span class="o">(</span><span class="n">ordx</span><span class="o">))(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="c1">// (4)</span>
</code></pre></div></div>

<p>In the product case, <code class="language-plaintext highlighter-rouge">eqProduct</code> we test the runtime values of the arguments to <code class="language-plaintext highlighter-rouge">eqv</code> for equality as products based
on the <code class="language-plaintext highlighter-rouge">Eq</code> instances for the fields of the data type (5),</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.deriving.Mirror</span>

<span class="k">def</span> <span class="nf">eqProduct</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">Mirror.ProductOf</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Eq</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="k">:</span>
    <span class="kt">def</span> <span class="kt">eqv</span><span class="o">(</span><span class="kt">x:</span> <span class="kt">T</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
      <span class="nf">iterator</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="py">zip</span><span class="o">(</span><span class="nf">iterator</span><span class="o">(</span><span class="n">y</span><span class="o">)).</span><span class="py">zip</span><span class="o">(</span><span class="nv">elems</span><span class="o">.</span><span class="py">iterator</span><span class="o">).</span><span class="py">forall</span> <span class="o">{</span>  <span class="c1">// (5)</span>
        <span class="nf">case</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">),</span> <span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">check</span><span class="o">(</span><span class="n">elem</span><span class="o">)(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
      <span class="o">}</span>
</code></pre></div></div>

<p>Pulling this all together we have the following complete implementation,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.deriving.</span><span class="o">*</span>
<span class="k">import</span> <span class="nn">scala.compiletime.</span><span class="o">{</span><span class="n">erasedValue</span><span class="o">,</span> <span class="n">summonInline</span><span class="o">}</span>

<span class="n">inline</span> <span class="k">def</span> <span class="nf">summonAll</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Tuple</span><span class="o">]</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Eq</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">inline</span> <span class="n">erasedValue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">match</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">EmptyTuple</span> <span class="o">=&gt;</span> <span class="nc">Nil</span>
    <span class="k">case</span> <span class="nf">_:</span> <span class="o">(</span><span class="n">t</span> <span class="o">*:</span> <span class="n">ts</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">summonInline</span><span class="o">[</span><span class="kt">Eq</span><span class="o">[</span><span class="kt">t</span><span class="o">]]</span> <span class="o">::</span> <span class="n">summonAll</span><span class="o">[</span><span class="kt">ts</span><span class="o">]</span>

<span class="k">trait</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="nc">:</span>
  <span class="k">def</span> <span class="nf">eqv</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>

<span class="k">object</span> <span class="nc">Eq</span><span class="k">:</span>
  <span class="kt">given</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">with</span>
    <span class="k">def</span> <span class="nf">eqv</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>

  <span class="k">def</span> <span class="nf">check</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="k">_</span><span class="o">])(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="nv">elem</span><span class="o">.</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">Eq</span><span class="o">[</span><span class="kt">Any</span><span class="o">]].</span><span class="py">eqv</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">iterator</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="nv">p</span><span class="o">.</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">Product</span><span class="o">].</span><span class="py">productIterator</span>

  <span class="k">def</span> <span class="nf">eqSum</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">Mirror.SumOf</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">elems</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Eq</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="k">:</span>
      <span class="kt">def</span> <span class="kt">eqv</span><span class="o">(</span><span class="kt">x:</span> <span class="kt">T</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
        <span class="k">val</span> <span class="nv">ordx</span> <span class="k">=</span> <span class="nv">s</span><span class="o">.</span><span class="py">ordinal</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
        <span class="o">(</span><span class="nv">s</span><span class="o">.</span><span class="py">ordinal</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">==</span> <span class="n">ordx</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="o">(</span><span class="nf">elems</span><span class="o">(</span><span class="n">ordx</span><span class="o">))(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">eqProduct</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">Mirror.ProductOf</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">elems</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Eq</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="k">:</span>
      <span class="kt">def</span> <span class="kt">eqv</span><span class="o">(</span><span class="kt">x:</span> <span class="kt">T</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
        <span class="nf">iterator</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="py">zip</span><span class="o">(</span><span class="nf">iterator</span><span class="o">(</span><span class="n">y</span><span class="o">)).</span><span class="py">zip</span><span class="o">(</span><span class="nv">elems</span><span class="o">.</span><span class="py">iterator</span><span class="o">).</span><span class="py">forall</span> <span class="o">{</span>
          <span class="nf">case</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">),</span> <span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">check</span><span class="o">(</span><span class="n">elem</span><span class="o">)(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
        <span class="o">}</span>

  <span class="n">inline</span> <span class="n">given</span> <span class="n">derived</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">using</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Mirror.Of</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">lazy</span> <span class="k">val</span> <span class="nv">elemInstances</span> <span class="k">=</span> <span class="n">summonAll</span><span class="o">[</span><span class="kt">m.MirroredElemTypes</span><span class="o">]</span>
    <span class="n">inline</span> <span class="n">m</span> <span class="k">match</span>
      <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Mirror.SumOf</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>     <span class="k">=&gt;</span> <span class="nf">eqSum</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">elemInstances</span><span class="o">)</span>
      <span class="k">case</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Mirror.ProductOf</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nf">eqProduct</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">elemInstances</span><span class="o">)</span>
<span class="n">end</span> <span class="nc">Eq</span>
</code></pre></div></div>

<p>we can test this relative to a simple ADT like so,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enum</span> <span class="nc">Opt</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="n">derives</span> <span class="nc">Eq</span><span class="k">:</span>
  <span class="kt">case</span> <span class="kt">Sm</span><span class="o">(</span><span class="kt">t:</span> <span class="kt">T</span><span class="o">)</span>
  <span class="kt">case</span> <span class="kt">Nn</span>

<span class="nd">@main</span> <span class="k">def</span> <span class="nf">test</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="k">import</span> <span class="nn">Opt.</span><span class="o">*</span>
  <span class="k">val</span> <span class="nv">eqoi</span> <span class="k">=</span> <span class="n">summon</span><span class="o">[</span><span class="kt">Eq</span><span class="o">[</span><span class="kt">Opt</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span>
  <span class="nf">assert</span><span class="o">(</span><span class="nv">eqoi</span><span class="o">.</span><span class="py">eqv</span><span class="o">(</span><span class="nc">Sm</span><span class="o">(</span><span class="mi">23</span><span class="o">),</span> <span class="nc">Sm</span><span class="o">(</span><span class="mi">23</span><span class="o">)))</span>
  <span class="nf">assert</span><span class="o">(!</span><span class="nv">eqoi</span><span class="o">.</span><span class="py">eqv</span><span class="o">(</span><span class="nc">Sm</span><span class="o">(</span><span class="mi">23</span><span class="o">),</span> <span class="nc">Sm</span><span class="o">(</span><span class="mi">13</span><span class="o">)))</span>
  <span class="nf">assert</span><span class="o">(!</span><span class="nv">eqoi</span><span class="o">.</span><span class="py">eqv</span><span class="o">(</span><span class="nc">Sm</span><span class="o">(</span><span class="mi">23</span><span class="o">),</span> <span class="nc">Nn</span><span class="o">))</span>
</code></pre></div></div>

<p>In this case the code that is generated by the inline expansion for the derived <code class="language-plaintext highlighter-rouge">Eq</code> instance for <code class="language-plaintext highlighter-rouge">Opt</code> looks like the
following, after a little polishing,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">given</span> <span class="n">derived$Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">using</span> <span class="n">eqT</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">Opt</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nf">eqSum</span><span class="o">(</span>
    <span class="n">summon</span><span class="o">[</span><span class="kt">Mirror</span><span class="o">[</span><span class="kt">Opt</span><span class="o">[</span><span class="kt">T</span><span class="o">]]],</span>
    <span class="nc">List</span><span class="o">(</span>
      <span class="nf">eqProduct</span><span class="o">(</span><span class="n">summon</span><span class="o">[</span><span class="kt">Mirror</span><span class="o">[</span><span class="kt">Sm</span><span class="o">[</span><span class="kt">T</span><span class="o">]]],</span> <span class="nc">List</span><span class="o">(</span><span class="n">summon</span><span class="o">[</span><span class="kt">Eq</span><span class="o">[</span><span class="kt">T</span><span class="o">]])),</span>
      <span class="nf">eqProduct</span><span class="o">(</span><span class="n">summon</span><span class="o">[</span><span class="kt">Mirror</span><span class="o">[</span><span class="kt">Nn.</span><span class="k">type</span><span class="o">]],</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="o">)</span>
  <span class="o">)</span>
</code></pre></div></div>

<p>Alternative approaches can be taken to the way that <code class="language-plaintext highlighter-rouge">derived</code> methods can be defined. For example, more aggressively
inlined variants using Scala 3 macros, whilst being more involved for type class authors to write than the example
above, can produce code for type classes like <code class="language-plaintext highlighter-rouge">Eq</code> which eliminate all the abstraction artefacts (eg. the <code class="language-plaintext highlighter-rouge">Lists</code> of
child instances in the above) and generate code which is indistinguishable from what a programmer might write by hand.
As a third example, using a higher level library such as Shapeless the type class author could define an equivalent
<code class="language-plaintext highlighter-rouge">derived</code> method as,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">given</span> <span class="n">eqSum</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">using</span> <span class="n">inst</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nv">K0</span><span class="o">.</span><span class="py">CoproductInstances</span><span class="o">[</span><span class="kt">Eq</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span>
  <span class="k">def</span> <span class="nf">eqv</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nv">inst</span><span class="o">.</span><span class="py">fold2</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)(</span><span class="kc">false</span><span class="o">)(</span>
    <span class="o">[</span><span class="kt">t</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">eqt</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">t</span><span class="o">],</span> <span class="n">t0</span><span class="k">:</span> <span class="kt">t</span><span class="o">,</span> <span class="n">t1</span><span class="k">:</span> <span class="kt">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">eqt</span><span class="o">.</span><span class="py">eqv</span><span class="o">(</span><span class="n">t0</span><span class="o">,</span> <span class="n">t1</span><span class="o">)</span>
  <span class="o">)</span>

<span class="n">given</span> <span class="n">eqProduct</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">using</span> <span class="n">inst</span><span class="k">:</span> <span class="kt">K0.ProductInstances</span><span class="o">[</span><span class="kt">Eq</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span>
  <span class="k">def</span> <span class="nf">eqv</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nv">inst</span><span class="o">.</span><span class="py">foldLeft2</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)(</span><span class="kc">true</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)(</span>
    <span class="o">[</span><span class="kt">t</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">acc</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">eqt</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">t</span><span class="o">],</span> <span class="n">t0</span><span class="k">:</span> <span class="kt">t</span><span class="o">,</span> <span class="n">t1</span><span class="k">:</span> <span class="kt">t</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">Complete</span><span class="o">(!</span><span class="nv">eqt</span><span class="o">.</span><span class="py">eqv</span><span class="o">(</span><span class="n">t0</span><span class="o">,</span> <span class="n">t1</span><span class="o">))(</span><span class="kc">false</span><span class="o">)(</span><span class="kc">true</span><span class="o">)</span>
  <span class="o">)</span>

<span class="n">inline</span> <span class="k">def</span> <span class="nf">derived</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">using</span> <span class="n">gen</span><span class="k">:</span> <span class="kt">K0.Generic</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">gen</span><span class="o">.</span><span class="py">derive</span><span class="o">(</span><span class="n">eqSum</span><span class="o">,</span> <span class="n">eqProduct</span><span class="o">)</span>
</code></pre></div></div>

<p>The framework described here enables all three of these approaches without mandating any of them.</p>

<p>For a brief discussion on how to use macros to write a type class <code class="language-plaintext highlighter-rouge">derived</code>
method please read more at <a href="./derivation-macro.html">How to write a type class <code class="language-plaintext highlighter-rouge">derived</code> method using macros</a>.</p>

<h3 id="deriving-instances-elsewhere">Deriving instances elsewhere</h3>

<p>Sometimes one would like to derive a type class instance for an ADT after the ADT is defined, without being able to
change the code of the ADT itself.  To do this, simply define an instance using the <code class="language-plaintext highlighter-rouge">derived</code> method of the type class
as right-hand side. E.g, to implement <code class="language-plaintext highlighter-rouge">Ordering</code> for <code class="language-plaintext highlighter-rouge">Option</code> define,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">given</span> <span class="o">[</span><span class="kt">T:</span> <span class="kt">Ordering</span><span class="o">]</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">Ordering</span><span class="o">.</span><span class="py">derived</span>
</code></pre></div></div>

<p>Assuming the <code class="language-plaintext highlighter-rouge">Ordering.derived</code> method has a context parameter of type <code class="language-plaintext highlighter-rouge">Mirror[T]</code> it will be satisfied by the
compiler generated <code class="language-plaintext highlighter-rouge">Mirror</code> instance for <code class="language-plaintext highlighter-rouge">Option</code> and the derivation of the instance will be expanded on the right
hand side of this definition in the same way as an instance defined in ADT companion objects.</p>

<h3 id="syntax">Syntax</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Template          ::=  InheritClauses [TemplateBody]
EnumDef           ::=  id ClassConstr InheritClauses EnumBody
InheritClauses    ::=  [â€˜extendsâ€™ ConstrApps] [â€˜derivesâ€™ QualId {â€˜,â€™ QualId}]
ConstrApps        ::=  ConstrApp {â€˜withâ€™ ConstrApp}
                    |  ConstrApp {â€˜,â€™ ConstrApp}
</code></pre></div></div>

<p><strong>Note:</strong> To align <code class="language-plaintext highlighter-rouge">extends</code> clauses and <code class="language-plaintext highlighter-rouge">derives</code> clauses, Scala 3 also allows multiple
extended types to be separated by commas. So the following is now legal:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="k">extends</span> <span class="n">B</span><span class="o">,</span> <span class="n">C</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>It is equivalent to the old form</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="k">extends</span> <span class="n">B</span> <span class="k">with</span> <span class="n">C</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<h3 id="discussion">Discussion</h3>

<p>This type class derivation framework is intentionally very small and low-level. There are essentially two pieces of
infrastructure in compiler-generated <code class="language-plaintext highlighter-rouge">Mirror</code> instances,</p>

<ul>
  <li>type members encoding properties of the mirrored types.</li>
  <li>a minimal value level mechanism for working generically with terms of the mirrored types.</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">Mirror</code> infrastructure can be seen as an extension of the existing <code class="language-plaintext highlighter-rouge">Product</code> infrastructure for case classes:
typically <code class="language-plaintext highlighter-rouge">Mirror</code> types will be implemented by the ADTs companion object, hence the type members and the <code class="language-plaintext highlighter-rouge">ordinal</code> or
<code class="language-plaintext highlighter-rouge">fromProduct</code> methods will be members of that object. The primary motivation for this design decision, and the
decision to encode properties via types rather than terms was to keep the bytecode and runtime footprint of the
feature small enough to make it possible to provide <code class="language-plaintext highlighter-rouge">Mirror</code> instances <em>unconditionally</em>.</p>

<p>Whilst <code class="language-plaintext highlighter-rouge">Mirrors</code> encode properties precisely via type members, the value level <code class="language-plaintext highlighter-rouge">ordinal</code> and <code class="language-plaintext highlighter-rouge">fromProduct</code> are
somewhat weakly typed (because they are defined in terms of <code class="language-plaintext highlighter-rouge">MirroredMonoType</code>) just like the members of <code class="language-plaintext highlighter-rouge">Product</code>.
This means that code for generic type classes has to ensure that type exploration and value selection proceed in
lockstep and it has to assert this conformance in some places using casts. If generic type classes are correctly
written these casts will never fail.</p>

<p>As mentioned, however, the compiler-provided mechanism is intentionally very low level and it is anticipated that
higher level type class derivation and generic programming libraries will build on this and Scala 3â€™s other
metaprogramming facilities to hide these low-level details from type class authors and general users. Type class
derivation in the style of both Shapeless and Magnolia are possible (a prototype of Shapeless 3, which combines
aspects of both Shapeless 2 and Magnolia has been developed alongside this language feature) as is a more aggressively
inlined style, supported by Scala 3â€™s new quote/splice macro and inlining facilities.</p>

				</div>

				<div class="two-columns">
					
					<a href="/scala3/reference/contextual/type-classes.html">&larr; <strong>previous</strong></a>
					
					
					<a href="/scala3/reference/contextual/multiversal-equality.html"><strong>next</strong> &rarr;</a>
					
				</div>

				<div class="content-contributors">
    <h3>Contributors to this page:</h3>
    <div id="contributors" class="contributors-container"></div>
</div>

			</div>
		</div>

		<!-- TOC -->
		<div class="content-nav">
	<div class="inner-box sidebar-toc-wrapper" style="">
		<h5 class="contents">Contents</h5>
        
        
          <div class="inner-toc book" id="sidebar-toc">
        

      <ul>
        
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang//scala3/reference/overview.html">Overview</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang//scala3/reference/new-types.html">New Types</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/new-types/intersection-types.html">Intersection Types</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/new-types/union-types.html">Union Types</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/new-types/type-lambdas.html">Type Lambdas</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/new-types/match-types.html">Match Types</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/new-types/dependent-function-types.html">Dependent Function Types</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/new-types/polymorphic-function-types.html">Polymorphic Function Types</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang//scala3/reference/enums.html">Enums</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/enums/enums.html">Enumerations</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/enums/adts.html">Algebraic Data Types</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/enums/desugarEnums.html">Translation of Enums and ADTs</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang//scala3/reference/contextual.html">Contextual Abstractions</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/contextual/givens.html">Given Instances</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/contextual/using-clauses.html">Using Clauses</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/contextual/context-bounds.html">Context Bounds</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/contextual/given-imports.html">Importing Givens</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/contextual/extension-methods.html">Extension Methods</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/contextual/type-classes.html">Implementing Type classes</a></li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a class="active" href="docs.scala-lang//scala3/reference/contextual/derivation.html">Type Class Derivation</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/contextual/multiversal-equality.html">Multiversal Equality</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/contextual/context-functions.html">Context Functions</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/contextual/conversions.html">Implicit Conversions</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/contextual/by-name-context-parameters.html">By-Name Context Parameters</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/contextual/relationship-implicits.html">Relationship with Scala 2 Implicits</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang//scala3/reference/metaprogramming.html">Metaprogramming</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/metaprogramming/inline.html">Inline</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/metaprogramming/compiletime-ops.html">Compile-time operations</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/metaprogramming/macros.html">Macros</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/metaprogramming/staging.html">Runtime Multi-Stage Programming</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/metaprogramming/reflection.html">Reflection</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/metaprogramming/tasty-inspect.html">TASTy Inspection</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang//scala3/reference/other-new-features.html">Other New Features</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/trait-parameters.html">Trait Parameters</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/transparent-traits.html">Transparent Traits</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/creator-applications.html">Universal Apply Methods</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/export.html">Export Clauses</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/opaques.html">Opaque Type Aliases</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/open-classes.html">Open Classes</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/parameter-untupling.html">Parameter Untupling</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/kind-polymorphism.html">Kind Polymorphism</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/matchable.html">The Matchable Trait</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/threadUnsafe-annotation.html">The @threadUnsafe annotation</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/targetName.html">The @targetName annotation</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/control-syntax.html">New Control Syntax</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/indentation.html">Optional Braces</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/explicit-nulls.html">Explicit Nulls</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/safe-initialization.html">Safe Initialization</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/other-new-features/type-test.html">TypeTest</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang//scala3/reference/changed-features.html">Other Changed Features</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/numeric-literals.html">Numeric Literals</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/structural-types.html">Programmatic Structural Types</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/operators.html">Rules for Operators</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/wildcards.html">Wildcard Arguments in Types</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/imports.html">Imports</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/type-checking.html">Changes in Type Checking</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/type-inference.html">Changes in Type Inference</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/implicit-resolution.html">Changes in Implicit Resolution</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/implicit-conversions.html">Implicit Conversions</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/overload-resolution.html">Changes in Overload Resolution</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/match-syntax.html">Match Expressions</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/vararg-splices.html">Vararg Splices</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/pattern-bindings.html">Pattern Bindings</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/pattern-matching.html">Option-less pattern matching</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/eta-expansion.html">Automatic Eta Expansion</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/compiler-plugins.html">Changes in Compiler Plugins</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/lazy-vals-init.html">Lazy Vals Initialization</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/changed-features/main-functions.html">Main Methods</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang//scala3/reference/dropped-features.html">Dropped Features</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/delayed-init.html">Dropped: Delayedinit</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/macros.html">Dropped: Scala 2 Macros</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/existential-types.html">Dropped: Existential Types</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/type-projection.html">Dropped: General Type Projection</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/do-while.html">Dropped: Do-While</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/procedure-syntax.html">Dropped: Procedure Syntax</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/package-objects.html">Dropped: Package Objects</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/early-initializers.html">Dropped: Early Initializers</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/class-shadowing.html">Dropped: Class Shadowing</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/limit22.html">Dropped: Limit 22</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/xml.html">Dropped: XML Literals</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/symlits.html">Dropped: Symbol Literals</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/auto-apply.html">Dropped: Auto-Application</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/weak-conformance.html">Dropped: Weak Conformance</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/this-qualifier.html">Dropped: private[this] and protected[this]</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang//scala3/reference/dropped-features/wildcard-init.html">Dropped: Wildcard Initializer</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang//scala3/reference/syntax.html">Scala 3 Syntax Summary</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang//scala3/reference/language-versions.html">Language Versions</a>
						<div id="toc"></div>
						</li>
              
            
          
        
      </ul>

      
		</div>
		<hr>
		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/main/_scala3-reference/contextual/derivation.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
	</div>
</div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="docs.scala-lang//getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="docs.scala-lang//overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.13/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="docs.scala-lang//resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="docs.scala-lang//scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="docs.scala-lang//resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>



<script src="docs.scala-lang//scripts/searchbar.js" type="text/javascript"></script>
<link rel="stylesheet" href="docs.scala-lang//scripts/my.css" type="text/css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">

<!-- moment js -->
<script src="docs.scala-lang//resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="docs.scala-lang//resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="docs.scala-lang//resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="docs.scala-lang//resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="docs.scala-lang//resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="docs.scala-lang//resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="docs.scala-lang//resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="docs.scala-lang//resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="docs.scala-lang//resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom JavaScript -->
<script src="docs.scala-lang//resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
if ($("#doc-search-bar").length) {
  docsearch({
    apiKey: 'fbc439670f5d4e3730cdcb715c359391',
    indexName: 'scala-lang',
    inputSelector: '#doc-search-bar',
    algoliaOptions: { 'facetFilters': ["language:en"] },
    debug: false // Set debug to true if you want to inspect the dropdown
  });
}
</script>
</body>

</html>

