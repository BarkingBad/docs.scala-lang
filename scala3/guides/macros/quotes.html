<!DOCTYPE html>

<html class="scala3">

  <head>
    <title>
      Quoted Code | 
      Macros in Scala 3 | 
      Scala Documentation
    </title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta property="og:site_name" content="Scala Documentation"/>
    <meta property="og:type" content="article"/>
    <meta property="og:url" content="http://0.0.0.0:4000/scala3/guides/macros/quotes.html"/>
    <meta property="og:image" content="http://0.0.0.0:4000/resources/img/scala-spiral-3d-2-toned-down.png"/>
    <meta property="og:title" content="Quoted Code"/>
    

    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@scala_lang"/>
    <meta name="twitter:creator" content="@scala_lang"/>
    <meta name="twitter:title" content="Quoted Code"/>
    

    <link rel="icon" type="image/png" href="docs.scala-lang/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="docs.scala-lang/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="docs.scala-lang/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="docs.scala-lang/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="docs.scala-lang/resources/favicon-16x16.png">
    <link rel="manifest" href="docs.scala-lang/resources/site.webmanifest">
    <link rel="mask-icon" href="docs.scala-lang/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="docs.scala-lang/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="docs.scala-lang/resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="docs.scala-lang/resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="docs.scala-lang/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="docs.scala-lang/resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>





<div class="navigation-fade-screen"></div>



<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="docs.scala-lang/resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="docs.scala-lang/" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>



<header id="doc-header" class="scala3">

  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      
      <div class="navigation-bdand">
      <a href="docs.scala-lang/">
        <img src="docs.scala-lang/resources/img/documentation-logo@2x.png" alt="docs">
      </a>
      <span class="doc-language-version">
        â€” Scala  3 
      </span>
      </div>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              
              
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    
                    
                    <a href="docs.scala-lang/scala3/new-in-scala3.html">New in Scala 3</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="docs.scala-lang/scala3/getting-started.html">Getting Started</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="docs.scala-lang/scala3/book/introduction.html">Scala 3 Book</a>
                  </li>
                
                  <li>
                    
                    
                    <a href="docs.scala-lang/scala3/guides/macros/index.html">Macro Tutorial</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              
              
              <a href="docs.scala-lang/scala3/guides/migration/compatibility-intro.html" id="migrate" >Migrate</a>
                
            </li>
        
            <li class="navigation-menu-item">
              
              
              <a href="docs.scala-lang/scala3/reference/overview.html" id="reference" >Reference</a>
                
            </li>
        
            <li class="navigation-menu-item">
              
              
              <a href="https://dotty.epfl.ch/api/index.html" id="api" >API</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="docs.scala-lang/scala3/new-in-scala3.html">New in Scala 3</a>
              </li>
            
              <li>
                <a href="docs.scala-lang/scala3/getting-started.html">Getting Started</a>
              </li>
            
              <li>
                <a href="docs.scala-lang/scala3/book/introduction.html">Scala 3 Book</a>
              </li>
            
              <li>
                <a href="docs.scala-lang/scala3/guides/macros/index.html">Macro Tutorial</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="https://dotty.epfl.ch/api/index.html">API</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">
  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        
          <div class="wip-notice">
            <h4>Work in Progress</h4>
            <p>
              We are still in the process of writing the documentation for Scala 3.
              You can <a  href="/scala3/contribute-to-docs.html">help us</a> to improve the documentation.
            </p>
            <p>Are you searching for the <a href="/">Scala 2 documentation</a>?</p>
          </div>
        

        <div class="titles">
          
            <div class="supertitle">Macros in Scala 3</div>
          
          <h1>Quoted Code</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation">
			<div class="inner-box">
				<div class="toc-context">
					<h2 id="code-blocks">Code blocks</h2>
<p>A quoted code block <code class="language-plaintext highlighter-rouge">'{ ... }</code> is syntactically similar to a string quote <code class="language-plaintext highlighter-rouge">" ... "</code> with the difference that the first contains typed code.
To insert a code into other code we use the <code class="language-plaintext highlighter-rouge">$expr</code> or <code class="language-plaintext highlighter-rouge">${ expr }</code> where <code class="language-plaintext highlighter-rouge">expr</code> is of type <code class="language-plaintext highlighter-rouge">Expr[T]</code>.
Intuitively, the code directly within the quote is not executed now, while the code within the splices is evaluated and their results are then spliced into the surrounding expression.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">msg</span> <span class="k">=</span> <span class="nc">Expr</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">printHello</span> <span class="k">=</span> <span class="o">'{</span> <span class="nf">print</span><span class="o">(</span><span class="nc">$msg</span><span class="o">)</span> <span class="o">}</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">printHello</span><span class="o">.</span><span class="py">show</span><span class="o">)</span> <span class="c1">// print("Hello")</span>
</code></pre></div></div>

<p>In general, the quote delays the execution while the splice makes it happen before the surrounding code.
This generalisation allows us to also give meaning to a <code class="language-plaintext highlighter-rouge">${ .. }</code> that is not within a quote, this evaluate the code within the splice at compile-time and place the result in the generated code.
Due to some technical considerations we only allow it directly within <code class="language-plaintext highlighter-rouge">inline</code> definitions that we call a <a href="/scala3/guides/macros/macros.html">macro</a>.</p>

<p>It is possible to write a quote within a quote, but usually when we write macros we do not encounter such code.</p>

<h2 id="level-consistency">Level consistency</h2>
<p>One cannot simply write any arbitrary code within quotes and within splices.
A part of the program will live at compile-time and the other will live at runtime.
Consider the following ill-constructed code.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">myBadCounter1</span><span class="o">(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="o">'{</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>The problem with this code is that <code class="language-plaintext highlighter-rouge">x</code> exists during compilation, but then we try to use it after the compiler has finished (maybe even in another machine).
Clearly it would be impossible to access its value and update it.</p>

<p>Now consider the dual version, where we define the variable at runtime and try to access it at compile-time.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">myBadCounter2</span><span class="o">(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">'{</span>
  <span class="k">var</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="n">$</span><span class="o">{</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span> <span class="ss">'x</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Clearly, this should not work as the variable does not exist yet.</p>

<p>To make sure you cannot write programs that contain these kinds of problems, we restrict the kinds of references allowed in quote environments.</p>

<p>We introduce <em>levels</em> as a count of the number of quotes minus the number of splices surrounding an expression or definition.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// level 0</span>
<span class="o">'{</span> <span class="c1">// level 1</span>
  <span class="k">var</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="n">$</span><span class="o">{</span> <span class="c1">// level 0</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="ss">'x</span> <span class="c1">// level 1</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The system will allow at any level references to global definitions such as <code class="language-plaintext highlighter-rouge">println</code>, but will restrict references to local definitions.
A local definition can only be accessed if it is defined at the same level as its reference.
This will catch the errors in <code class="language-plaintext highlighter-rouge">myBadCounter1</code> and <code class="language-plaintext highlighter-rouge">myBadCounter2</code>.</p>

<p>Even though we cannot refer to variable inside of a quote, we can still pass its current value to it by lifting the value to an expression using <code class="language-plaintext highlighter-rouge">Expr.apply</code>.</p>

<h2 id="generics">Generics</h2>

<p>When using type parameters or other kinds of abstract types with quoted code we will need to keep track of some of these types explicitly.
Scala uses erased-types semantics for its generics.
This implies that types are removed from the program when compiling and the runtime does not have to track all types at runtime.</p>

<p>Consider the following code</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">evalAndUse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="o">'{</span>
  <span class="k">val</span> <span class="nv">x2</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">$x</span> <span class="c1">// error</span>
  <span class="o">...</span> <span class="c1">// use x2</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here we will get an error telling us that we are missing a contextual <code class="language-plaintext highlighter-rouge">Type[T]</code>.
Therefore we can easily fix it by writing</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">evalAndUse</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">X</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Type</span><span class="o">[</span><span class="kt">X</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span> <span class="k">=</span> <span class="o">'{</span>
  <span class="k">val</span> <span class="nv">x2</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=</span> <span class="nc">$x</span>
  <span class="o">...</span> <span class="c1">// use x2</span>
<span class="o">}</span>
</code></pre></div></div>
<p>This code will be equivalent to the more verbose</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">evalAndUse</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">X</span><span class="o">])(</span><span class="n">using</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Type</span><span class="o">[</span><span class="kt">X</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span> <span class="k">=</span> <span class="o">'{</span>
  <span class="k">val</span> <span class="nv">x2</span><span class="k">:</span> <span class="kt">t.Underlying</span> <span class="o">=</span> <span class="nc">$x</span>
  <span class="o">...</span> <span class="c1">// use x2</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Note that <code class="language-plaintext highlighter-rouge">Type</code> has a type member called <code class="language-plaintext highlighter-rouge">Underlying</code> that refers to the type held within the <code class="language-plaintext highlighter-rouge">Type</code>, in this case <code class="language-plaintext highlighter-rouge">t.Underlying</code> is <code class="language-plaintext highlighter-rouge">X</code>.
Note that even if we used it implicitly is better to keep it contextual as some changes inside the quote may require it.
The less verbose version is usually the best way to write the types as it is much simpler to read.
In some cases, we will not know statically the type within the <code class="language-plaintext highlighter-rouge">Type</code> and will need to use the <code class="language-plaintext highlighter-rouge">.T</code> to refer to it.</p>

<p>When do we need this extra <code class="language-plaintext highlighter-rouge">Type</code> parameter?</p>
<ul>
  <li>When a type is abstract and it is used in a level that is larger than the current level.</li>
</ul>

<p>When you add a <code class="language-plaintext highlighter-rouge">Type</code> contextual parameter to a method you will either get it from another context parameter or implicitly with a call to <code class="language-plaintext highlighter-rouge">Type.of</code>.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">evalAndUse</span><span class="o">(</span><span class="nc">Expr</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="c1">// is equivalent to</span>
<span class="n">evalAndUse</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">Expr</span><span class="o">(</span><span class="mi">3</span><span class="o">))(</span><span class="n">using</span> <span class="nv">Type</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>
</code></pre></div></div>
<p>As you may have guessed, not every type is can be used in this <code class="language-plaintext highlighter-rouge">Type.of[..]</code> out of the box.
We cannot recover abstract types that have already been erased.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">evalAndUse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">given</span> <span class="nc">Type</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Type</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="c1">// error</span>
  <span class="o">'{</span>
    <span class="k">val</span> <span class="nv">x2</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">$x</span>
    <span class="o">...</span> <span class="c1">// use x2</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>But we can write more complex types that depend on these abstract types.
For example, if we look for or construct explicitly a <code class="language-plaintext highlighter-rouge">Type[List[T]]</code>, then the system will require a <code class="language-plaintext highlighter-rouge">Type[T]</code> in the current context to compile.</p>

<p>Good code should only add <code class="language-plaintext highlighter-rouge">Type</code> to the context parameters and never use them explicitly.
Explicit use is useful while debugging at the cost of conciseness and clarity.</p>

<h2 id="toexpr">ToExpr</h2>
<p>The <code class="language-plaintext highlighter-rouge">Expr.apply</code> method uses intances of <code class="language-plaintext highlighter-rouge">ToExpr</code> to generate an expression that will create a copy of the value.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Expr</span><span class="k">:</span>
  <span class="kt">def</span> <span class="kt">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">,</span> <span class="nc">ToExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">summon</span><span class="o">[</span><span class="kt">ToExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">]].</span><span class="py">apply</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ToExpr</code> is defined as follows:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ToExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="nc">:</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ToExpr.apply</code> method will take a value <code class="language-plaintext highlighter-rouge">T</code> and generate code that will construct a copy of this value at runtime.</p>

<p>We can define our own <code class="language-plaintext highlighter-rouge">ToExpr</code>s like:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">given</span> <span class="nc">ToExpr</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">with</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">if</span> <span class="n">x</span> <span class="n">then</span> <span class="o">'{</span><span class="kc">true</span><span class="o">}</span>
    <span class="k">else</span> <span class="o">'{</span><span class="kc">false</span><span class="o">}</span>
<span class="o">}</span>

<span class="n">given</span> <span class="nc">ToExpr</span><span class="o">[</span><span class="kt">StringContext</span><span class="o">]</span> <span class="k">with</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">StringContext</span><span class="o">)(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">val</span> <span class="nv">parts</span> <span class="k">=</span> <span class="nc">Varargs</span><span class="o">(</span><span class="nv">stringContext</span><span class="o">.</span><span class="py">parts</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">Expr</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span>
    <span class="o">'{</span> <span class="nc">StringContext</span><span class="o">(</span><span class="nc">$parts</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">Varargs</code> constructor just creates an <code class="language-plaintext highlighter-rouge">Expr[Seq[T]]</code> which we can efficiently splice as a varargs.
In general any sequence can be spliced with <code class="language-plaintext highlighter-rouge">$mySeq: _*</code> to splice it a varargs.</p>

<h2 id="quoted-patterns">Quoted patterns</h2>
<p>Quotes can also be used to check if an expression is equivalent to another or deconstruct an expression into it parts.</p>

<h3 id="matching-exact-expression">Matching exact expression</h3>

<p>The simples thing we can do is to check if an expression matches another know expression.
Bellow we show how we can match some expressions using <code class="language-plaintext highlighter-rouge">case '{...} =&gt;</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">valueOfBoolean</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="kc">true</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="kc">false</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>

<span class="k">def</span> <span class="nf">valueOfBooleanOption</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">))</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">None</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</code></pre></div></div>

<h3 id="matching-partial-expression">Matching partial expression</h3>

<p>To make thing more compact, we can also match patially the expression using a <code class="language-plaintext highlighter-rouge">$</code> to match arbitrarry code and extract it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">valueOfBooleanOption</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">$boolExpr</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nf">valueOfBoolean</span><span class="o">(</span><span class="n">boolExpr</span><span class="o">))</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">None</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</code></pre></div></div>

<h3 id="matching-types-of-expression">Matching types of expression</h3>

<p>We can also match agains code of an arbitrary type <code class="language-plaintext highlighter-rouge">T</code>.
Bellow we match agains <code class="language-plaintext highlighter-rouge">$x</code> of type <code class="language-plaintext highlighter-rouge">T</code> and we get out an <code class="language-plaintext highlighter-rouge">x</code> of type <code class="language-plaintext highlighter-rouge">Expr[T]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exprOfOption</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">$x</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// x: Expr[T]</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">None</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</code></pre></div></div>

<p>We can also check for the type of an expression</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">valueOf</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Any</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">$x</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nf">valueOfBoolean</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// x: Expr[Boolean]</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">$x</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="o">}</span>  <span class="k">=&gt;</span> <span class="nf">valueOfBooleanOption</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// x: Expr[Option[Boolean]]</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</code></pre></div></div>
<p>Or similarly for an some subexpression</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">$x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="c1">// x: Expr[Boolean]</span>
</code></pre></div></div>

<h3 id="matching-receiver-of-methods">Matching receiver of methods</h3>

<p>When we want to match the receiver of a method we need to explicitly state its type</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="o">'{</span> <span class="o">(</span><span class="nc">$ls</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]).</span><span class="py">sum</span> <span class="o">}</span> <span class="k">=&gt;</span>
</code></pre></div></div>

<p>If we would have written <code class="language-plaintext highlighter-rouge">$ls.sum</code> we would not have been able to know the type of <code class="language-plaintext highlighter-rouge">ls</code> and which <code class="language-plaintext highlighter-rouge">sum</code> method we are calling.</p>

<p>Another common case where we need type annotations is for infix operations.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="o">'{</span> <span class="o">(</span><span class="nc">$x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="nc">$y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span>
<span class="k">case</span> <span class="o">'{</span> <span class="o">(</span><span class="nc">$x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="nc">$y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span>
<span class="k">case</span> <span class="o">...</span>
</code></pre></div></div>

<h3 id="matching-function-expressions">Matching function expressions</h3>

<p><em>Coming soon</em></p>

<h3 id="matching-types">Matching types</h3>

<p>So far, we assumed that the types within quote patterns would be statically known.
Quote patterns also allow for generic types and existential types, which we will see in this section.</p>

<h4 id="generic-types-in-patterns">Generic types in patterns</h4>

<p>Consider the function <code class="language-plaintext highlighter-rouge">exprOfOption</code> that we have already seen:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exprOfOption</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">$x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// x: Expr[T]</span>
                <span class="c1">// ^^^ type ascription with generic type T</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>Note that this time we have added the <code class="language-plaintext highlighter-rouge">T</code> explicitly in the pattern, even though it could be inferred.
By referring to the generic type <code class="language-plaintext highlighter-rouge">T</code> in the pattern, we are required to have a given <code class="language-plaintext highlighter-rouge">Type[T]</code> in scope.
This implies that <code class="language-plaintext highlighter-rouge">$x: T</code> will only match if <code class="language-plaintext highlighter-rouge">x</code> is of type <code class="language-plaintext highlighter-rouge">Expr[T]</code>.
In this particular case this condition will always be true.</p>

<p>Now consider the following variant where <code class="language-plaintext highlighter-rouge">x</code> is an optional value with a (statically) unknown element type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exprOfOptionOf</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">$x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// x: Expr[T]</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</code></pre></div></div>
<p>This time the pattern ` Some($x: T)<code class="language-plaintext highlighter-rouge"> will only match if the type of the option is </code>Some[T]`.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">exprOfOptionOf</span><span class="o">[</span><span class="kt">Int</span><span class="o">]('{</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span> <span class="o">})</span>   <span class="c1">// Some('{3})</span>
<span class="n">exprOfOptionOf</span><span class="o">[</span><span class="kt">Int</span><span class="o">]('{</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"a"</span><span class="o">)</span> <span class="o">})</span> <span class="c1">// None</span>
</code></pre></div></div>

<h4 id="type-variables-in-quoted-patterns">Type variables in quoted patterns</h4>

<p>Quoted code may contain types that are not known outside of the quote.
We can match on them using pattern type variables.
Just as in a normal pattern, the type variables are written using lower case names.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exprOptionToList</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Expr</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">$x</span><span class="k">:</span> <span class="kt">t</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span>
                <span class="c1">// ^^^ this binds the type `t` in the body of the case</span>
      <span class="nc">Some</span><span class="o">('{</span> <span class="nc">List</span><span class="o">[</span><span class="kt">t</span><span class="o">](</span><span class="nc">$x</span><span class="o">)</span> <span class="o">})</span> <span class="c1">// x: Expr[List[t]]</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">None</span> <span class="o">}</span> <span class="k">=&gt;</span>
      <span class="nc">Some</span><span class="o">('{</span> <span class="nc">Nil</span> <span class="o">})</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</code></pre></div></div>

<p>The pattern <code class="language-plaintext highlighter-rouge">$x: t</code> will match an expression of any type and <code class="language-plaintext highlighter-rouge">t</code> will be bound to the type of the pattern.
This type is only valid in the right-hand side of the <code class="language-plaintext highlighter-rouge">case</code>, in the example we can use it to construct the list <code class="language-plaintext highlighter-rouge">List[t]($x)</code> (<code class="language-plaintext highlighter-rouge">List($x)</code> would also work).
As this is a type that is not statically known we need a given <code class="language-plaintext highlighter-rouge">Type[t]</code> in scope, luckily the quoted pattern will automatically provide this.</p>

<p>The simple <code class="language-plaintext highlighter-rouge">case '{ $expr: tpe } =&gt;</code> pattern is very useful if we want to know the precise type of the expression.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
<span class="n">expr</span> <span class="k">match</span>
  <span class="k">case</span> <span class="o">'{</span> <span class="nc">$expr</span><span class="k">:</span> <span class="kt">tpe</span> <span class="o">}</span> <span class="k">=&gt;</span>
    <span class="nv">Type</span><span class="o">.</span><span class="py">show</span><span class="o">[</span><span class="kt">tpe</span><span class="o">]</span> <span class="c1">// could be: Option[Int], Some[Int], None, Option[1], Option[2], ...</span>
    <span class="o">'{</span> <span class="k">val</span> <span class="nv">x</span><span class="k">:</span> <span class="kt">tpe</span> <span class="o">=</span> <span class="nc">$expr</span><span class="o">;</span> <span class="n">x</span> <span class="o">}</span> <span class="c1">// binds the value without widening the type</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>In some cases we need to define a pattern variable that is referenced several times or has some type bounds.
To achieve this it is possible to create pattern variables at the start of the pattern using <code class="language-plaintext highlighter-rouge">type t</code> with a type pattern variable.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fuseMap</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">'{</span>
    <span class="k">type</span> <span class="kt">u</span>
    <span class="k">type</span> <span class="kt">v</span>
    <span class="o">(</span><span class="nc">$ls</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">`u`</span><span class="o">])</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">$f</span><span class="k">:</span> <span class="kt">`u`</span> <span class="o">=&gt;</span> <span class="n">`v`</span><span class="o">)</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">$g</span><span class="k">:</span> <span class="kt">`v`</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">=&gt;</span>
    <span class="o">'{</span> <span class="nv">$ls</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nc">$g</span><span class="o">(</span><span class="nc">$f</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span> <span class="o">}</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">x</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here we define two type variables <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code> and then refer to them using <code class="language-plaintext highlighter-rouge">`u`</code> and <code class="language-plaintext highlighter-rouge">`v`</code>.
We do not refer to them using <code class="language-plaintext highlighter-rouge">u</code> or <code class="language-plaintext highlighter-rouge">v</code> because those would be interpreted as new type variables and hence duplicates.
This notation follows the normal <a href="https://www.scala-lang.org/files/archive/spec/2.13/08-pattern-matching.html#stable-identifier-patterns">stable identifier patterns</a> syntax.
Furthermore, if the type variable needs to be constrained we can add bounds directly on the type definition <code class="language-plaintext highlighter-rouge">case '{ type u &lt;: AnyRef; ... } =&gt;</code>.</p>

<p>Note that the previous case could also be written as <code class="language-plaintext highlighter-rouge">case '{ ($ls: List[u]).map[v]($f).map[T]($g) =&gt;</code>.</p>

<h4 id="quote-types-patterns">Quote types patterns</h4>

<p>Type represented with <code class="language-plaintext highlighter-rouge">Type[T]</code> can be matched on using the patten <code class="language-plaintext highlighter-rouge">case '[...] =&gt;</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mirrorFields</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Type</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'[</span><span class="kt">field</span> <span class="kt">*:</span> <span class="kt">fields</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="nv">Type</span><span class="o">.</span><span class="py">show</span><span class="o">[</span><span class="kt">field</span><span class="o">]</span> <span class="o">::</span> <span class="n">mirrorFields</span><span class="o">[</span><span class="kt">fields</span><span class="o">]</span>
    <span class="k">case</span> <span class="o">'[</span><span class="kt">EmptyTuple</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="nc">Nil</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="nv">compiletime</span><span class="o">.</span><span class="py">error</span><span class="o">(</span><span class="s">"Expected known tuple but got: "</span> <span class="o">+</span> <span class="nv">Type</span><span class="o">.</span><span class="py">show</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>

<span class="n">mirrorFields</span><span class="o">[</span><span class="kt">EmptyTuple</span><span class="o">]</span>         <span class="c1">// Nil</span>
<span class="n">mirrorFields</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="c1">// List("Int", "String", "Int")</span>
<span class="n">mirrorFields</span><span class="o">[</span><span class="kt">Tuple</span><span class="o">]</span>              <span class="c1">// error: Expected known tuple but got: Tuple</span>
</code></pre></div></div>

<p>As with expression quote patterns type variables are represented using lower case names.</p>

<h2 id="fromexpr">FromExpr</h2>

<p>The <code class="language-plaintext highlighter-rouge">Expr.value</code>, <code class="language-plaintext highlighter-rouge">Expr.valueOrError</code> <code class="language-plaintext highlighter-rouge">Expr.unapply</code> method uses intances of <code class="language-plaintext highlighter-rouge">FromExpr</code> to to extract the value if possible.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">extension</span> <span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span>
  <span class="kt">def</span> <span class="kt">value</span><span class="o">(</span><span class="kt">using</span> <span class="kt">Quotes</span><span class="o">)(</span><span class="kt">using</span> <span class="kt">fromExpr:</span> <span class="kt">FromExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">fromExpr</span><span class="o">.</span><span class="py">unapply</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">valueOrError</span><span class="o">(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)(</span><span class="n">using</span> <span class="n">fromExpr</span><span class="k">:</span> <span class="kt">FromExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
    <span class="nv">fromExpr</span><span class="o">.</span><span class="py">unapply</span><span class="o">(</span><span class="n">expr</span><span class="o">).</span><span class="py">getOrElse</span><span class="o">(</span><span class="nv">eport</span><span class="o">.</span><span class="py">throwError</span><span class="o">(</span><span class="s">"..."</span><span class="o">,</span> <span class="n">expr</span><span class="o">))</span>
<span class="n">end</span> <span class="n">extension</span>

<span class="k">object</span> <span class="nc">Expr</span><span class="k">:</span>
  <span class="kt">def</span> <span class="kt">unapply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)(</span><span class="n">using</span> <span class="n">fromExpr</span><span class="k">:</span> <span class="kt">FromExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">fromExpr</span><span class="o">.</span><span class="py">unapply</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">FromExpr</code> is defined as follows:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">FromExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="nc">:</span>
  <span class="k">def</span> <span class="nf">unapply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">FromExpr.unapply</code> method will take a value <code class="language-plaintext highlighter-rouge">T</code> and generate code that will construct a copy of this value at runtime.</p>

<p>We can define our own <code class="language-plaintext highlighter-rouge">FromExpr</code>s like:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">given</span> <span class="nc">FromExpr</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">with</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">unapply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">x</span> <span class="k">match</span>
      <span class="k">case</span> <span class="o">'{</span> <span class="kc">true</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
      <span class="k">case</span> <span class="o">'{</span> <span class="kc">false</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
<span class="o">}</span>

<span class="n">given</span> <span class="nc">FromExpr</span><span class="o">[</span><span class="kt">StringContext</span><span class="o">]</span> <span class="k">with</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">unapply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">StringContext</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">StringContext</span><span class="o">]</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="k">new</span> <span class="nc">StringContext</span><span class="o">(</span><span class="n">$</span><span class="o">{</span><span class="nc">Varargs</span><span class="o">(</span><span class="nc">Exprs</span><span class="o">(</span><span class="n">args</span><span class="o">))}</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">StringContext</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">))</span>
    <span class="k">case</span> <span class="o">'{</span>     <span class="nc">StringContext</span><span class="o">(</span><span class="n">$</span><span class="o">{</span><span class="nc">Varargs</span><span class="o">(</span><span class="nc">Exprs</span><span class="o">(</span><span class="n">args</span><span class="o">))}</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">StringContext</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">))</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Note that we handled two cases for the <code class="language-plaintext highlighter-rouge">StringContext</code>.
As it is a <code class="language-plaintext highlighter-rouge">case class</code> it can be created with the <code class="language-plaintext highlighter-rouge">new StringContext</code> or with the <code class="language-plaintext highlighter-rouge">StringContext.apply</code> in the companion object.
We also used the <code class="language-plaintext highlighter-rouge">Varargs</code> extractor to match the arguments of type <code class="language-plaintext highlighter-rouge">Expr[Seq[String]]</code> into a <code class="language-plaintext highlighter-rouge">Seq[Expr[String]]</code>.
Then we used the <code class="language-plaintext highlighter-rouge">Exprs</code> to match known constants in the <code class="language-plaintext highlighter-rouge">Seq[Expr[String]]</code> to get a <code class="language-plaintext highlighter-rouge">Seq[String]</code>.</p>

<h2 id="the-quotes">The Quotes</h2>
<p>The <code class="language-plaintext highlighter-rouge">Quotes</code> is the main entry point for the creation of all quotes.
This context is usually just passed around through contextual abstractions (<code class="language-plaintext highlighter-rouge">using</code> and <code class="language-plaintext highlighter-rouge">?=&gt;</code>).
Each quote scope will provide have its own <code class="language-plaintext highlighter-rouge">Quotes</code>.
New scopes are introduced each time a splice is introduced <code class="language-plaintext highlighter-rouge">${...}</code>.
Though it looks like a splice takes an expression as argument, it actually takes a <code class="language-plaintext highlighter-rouge">Quotes ?=&gt; Expr[T]</code>.
Therefore we could actually write it explicitly as <code class="language-plaintext highlighter-rouge">${ (using q) =&gt; ... }</code>, this might be useful when debugging to avoid generated names for these scopes.</p>

<p>The method <code class="language-plaintext highlighter-rouge">scala.quoted.quotes</code> provides a simple way to use the current <code class="language-plaintext highlighter-rouge">Quotes</code> without naming it.
It is usually imported along with the <code class="language-plaintext highlighter-rouge">Quotes</code> using <code class="language-plaintext highlighter-rouge">import scala.quoted.*</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">$</span><span class="o">{</span> <span class="o">(</span><span class="n">using</span> <span class="n">q1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">body</span><span class="o">(</span><span class="n">using</span> <span class="n">q1</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// equivalent to</span>
<span class="n">$</span><span class="o">{</span> <span class="nf">body</span><span class="o">(</span><span class="n">using</span> <span class="n">quotes</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div></div>
<p>If you explicitly name a <code class="language-plaintext highlighter-rouge">Quotes</code> <code class="language-plaintext highlighter-rouge">quotes</code> you will shadow this definition.</p>

<p>When we write a top level splice in a macro we are calling something similar to the following definition.
This splice will provide the initial <code class="language-plaintext highlighter-rouge">Quotes</code> associated with the macro expansion.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">$</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Quotes</span> <span class="kt">?=&gt;</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">...</span>
</code></pre></div></div>

<p>When we have a splice within a quote, the inner quote context will depend on the outer one.
This link is represented using the <code class="language-plaintext highlighter-rouge">Quotes.Nested</code> type.
Users of quotes will almost never need to use <code class="language-plaintext highlighter-rouge">Quotes.Nested</code>.
These details are only useful for advanced macros that will inspect code and may encounter details of quotes and splices.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="o">(</span><span class="n">using</span> <span class="n">q1</span><span class="k">:</span> <span class="kt">Quotes</span><span class="o">)</span> <span class="k">=</span> <span class="o">'{</span>
  <span class="n">$</span><span class="o">{</span> <span class="o">(</span><span class="n">using</span> <span class="n">q2</span><span class="k">:</span> <span class="kt">q1.Nested</span><span class="o">)</span> <span class="o">?=&gt;</span>
      <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can imagine that a nested splice is like the following method, where <code class="language-plaintext highlighter-rouge">ctx</code> is the context received by the surrounding quote.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">$</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">using</span> <span class="n">q</span><span class="k">:</span> <span class="kt">Quotes</span><span class="o">)(</span><span class="n">x</span><span class="k">:</span> <span class="kt">q.Nested</span> <span class="kt">?=&gt;</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">...</span>
</code></pre></div></div>

<h2 id="Î²-reduction">Î²-reduction</h2>
<p>When we have a lambda applied to an argument in a quote <code class="language-plaintext highlighter-rouge">'{ ((x: Int) =&gt; x + x)(y) }</code> we do not reduce it within the quote, the code is kept as is.
There is an optimisation that Î²-reduce all lambdas directly applied to parameters to avoid the creation of the closure.
This will not be visible from the quotes perspective.</p>

<p>Sometime it is useful to perform this Î²-reduction on the quotes directly.
We provide the function <code class="language-plaintext highlighter-rouge">Expr.betaReduce[T]</code> that receives an <code class="language-plaintext highlighter-rouge">Expr[T]</code> and Î²-reduce if it contains a directly applied lambda.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Expr</span><span class="o">.</span><span class="py">betaReduce</span><span class="o">('{</span> <span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">)(</span><span class="n">y</span><span class="o">)</span> <span class="o">})</span> <span class="c1">// returns '{ val x = y; x + x }</span>
</code></pre></div></div>

<h2 id="summon-values">Summon values</h2>
<p>There are two ways to summon values in a macro.
The first is to have a <code class="language-plaintext highlighter-rouge">using</code> parameter in the inline method that is passed explicitly to the macro implementation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inline</span> <span class="k">def</span> <span class="nf">setFor</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">using</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">$</span><span class="o">{</span> <span class="n">setForCode</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="ss">'ord</span><span class="o">)</span> <span class="o">}</span>

<span class="k">def</span> <span class="nf">setForCode</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">ord</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
  <span class="o">'{</span> <span class="nv">TreeSet</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">using</span> <span class="nc">$ord</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div></div>

<p>In this scenario, the context parameter is found before the macro is expanded.
If not found, the macro will not expand.</p>

<p>The second way is using <code class="language-plaintext highlighter-rouge">Expr.summon</code>.
This allows to programatically search for distinct given expressions.
The following example is similar to the previous example.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inline</span> <span class="k">def</span> <span class="nf">setFor</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">$</span><span class="o">{</span> <span class="n">setForCode</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">}</span>

<span class="k">def</span> <span class="nf">setForCode</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">*</span>
  <span class="nv">Expr</span><span class="o">.</span><span class="py">summon</span><span class="o">[</span><span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">match</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">ord</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">'{</span> <span class="nv">TreeSet</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">using</span> <span class="nc">$ord</span><span class="o">)</span> <span class="o">}</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">'{</span> <span class="nv">HashSet</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div></div>

<p>The difference is that in this scenario we do start expanding the macro before the implicit search failure and we can write arbitrary code to handle the case where it is not found.
Here we used <code class="language-plaintext highlighter-rouge">HashSet</code> and another valid implementation that does not need the <code class="language-plaintext highlighter-rouge">Ordering</code>.</p>


				</div>

				<div class="two-columns">
					
					<a href="macros.html">&larr; <strong>previous</strong></a>
					
					
					<a href="reflection.html"><strong>next</strong> &rarr;</a>
					
				</div>

				<div class="content-contributors">
    <h3>Contributors to this page:</h3>
    <div id="contributors" class="contributors-container"></div>
</div>

			</div>
		</div>

		<!-- TOC -->
		<div class="content-nav">
	<div class="inner-box sidebar-toc-wrapper" style="">
		<h5 class="contents">Contents</h5>
        
        
          <div class="inner-toc book" id="sidebar-toc">
        

      <ul>
        
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang/scala3/guides/macros/index.html">Tutorial</a></li>
              
            
          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang/scala3/guides/macros/inline.html">Inline</a></li>
              
            
          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang/scala3/guides/macros/compiletime.html">Scala Compile-time Operations</a></li>
              
            
          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang/scala3/guides/macros/macros.html">Scala 3 Macros</a></li>
              
            
          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a class="active" href="docs.scala-lang/scala3/guides/macros/quotes.html">Quoted Code</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-section"><a  href="docs.scala-lang/scala3/guides/macros/reflection.html">Reflection</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang/scala3/guides/macros/faq.html">FAQ</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang/scala3/guides/macros/best-practices.html">Best Practices</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
             <!-- this must be English, so get the other documents' titles -->

               <!-- if a type is set in a document, we add it as a class. Used in Scala book to diff between chapter and section -->
                <li class="type-chapter"><a  href="docs.scala-lang/scala3/guides/macros/other-resources.html">Other Resources</a>
						<div id="toc"></div>
						</li>
              
            
          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
					

          
        
      </ul>

      
		</div>
		<hr>
		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
	</div>
</div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="docs.scala-lang/getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="docs.scala-lang/overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.13/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="docs.scala-lang/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="docs.scala-lang/scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="docs.scala-lang/resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>



<script src="docs.scala-lang/scripts/searchbar.js" type="text/javascript"></script>
<link rel="stylesheet" href="docs.scala-lang/scripts/my.css" type="text/css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">

<!-- moment js -->
<script src="docs.scala-lang/resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="docs.scala-lang/resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="docs.scala-lang/resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="docs.scala-lang/resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="docs.scala-lang/resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="docs.scala-lang/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="docs.scala-lang/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="docs.scala-lang/resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="docs.scala-lang/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom JavaScript -->
<script src="docs.scala-lang/resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
if ($("#doc-search-bar").length) {
  docsearch({
    apiKey: 'fbc439670f5d4e3730cdcb715c359391',
    indexName: 'scala-lang',
    inputSelector: '#doc-search-bar',
    algoliaOptions: { 'facetFilters': ["language:en"] },
    debug: false // Set debug to true if you want to inspect the dropdown
  });
}
</script>
</body>

</html>

